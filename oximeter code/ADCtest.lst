CCS PCH C Compiler, Version 5.110P, 62238               09-Nov-23 14:11

               Filename:   C:\BME4390\group 6, Ang, Tu\PICcode\final code\ADCtest.lst

               ROM used:   14482 bytes (59%)
                           Largest free fragment is 10094
               RAM used:   652 (32%) at main() level
                           770 (38%) worst case
               Stack used: 10 locations (5 in main + 5 for interrupts)
               Stack size: 31

*
0000:  GOTO   3774
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.5
0056:  GOTO   0060
005A:  BTFSC  FA1.5
005C:  GOTO   0EE4
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... /////////////////////////////////////////////////////////////////////
.................... // Oximeter.c - firmware for BME4390 oximeter which uses a PIC18F2455
.................... //              MCU and a Maxim MAX1303 16 bit 4 channel SPI ADC
.................... //              The results are displayed on the LCD or sent
.................... //              to the PC via USB.
.................... //////////////////////////////////////////////////////////////////////
.................... 
.................... #include <18F2455.h>
.................... //////////// Standard Header file for the PIC18F2455 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F2455
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,03
00C0:  DATA FF,FF
00C2:  DATA FF,FF
00C4:  DATA FF,FF
00C6:  DATA FF,FF
00C8:  DATA FF,FF
00CA:  DATA FF,FF
00CC:  DATA FF,FF
00CE:  CLRF   FF7
00D0:  ADDLW  DE
00D2:  MOVWF  FF6
00D4:  MOVLW  00
00D6:  ADDWFC FF7,F
00D8:  TBLRD*+
00DA:  MOVF   FF5,W
00DC:  RETURN 0
00DE:  DATA 40,00
00E0:  DATA 40,00
00E2:  DATA 00,00
00E4:  DATA 00,00
00E6:  DATA 00,00
00E8:  DATA 00,00
00EA:  DATA 00,00
00EC:  DATA 00,00
00EE:  DATA 00,00
00F0:  DATA 00,00
00F2:  DATA 00,00
00F4:  DATA 00,00
00F6:  DATA 00,00
00F8:  DATA 00,00
00FA:  DATA 00,00
00FC:  DATA 00,00
00FE:  CLRF   FF7
0100:  ADDLW  0E
0102:  MOVWF  FF6
0104:  MOVLW  01
0106:  ADDWFC FF7,F
0108:  TBLRD*+
010A:  MOVF   FF5,W
010C:  RETURN 0
010E:  DATA 06,00
0110:  DATA FF,09
0112:  DATA 01,A1
0114:  DATA 01,19
0116:  DATA 01,29
0118:  DATA 08,15
011A:  DATA 80,25
011C:  DATA 7F,75
011E:  DATA 08,95
0120:  DATA 40,81
0122:  DATA 02,19
0124:  DATA 01,29
0126:  DATA 08,75
0128:  DATA 08,95
012A:  DATA 40,91
012C:  DATA 40,C0
012E:  CLRF   FF7
0130:  ADDLW  3E
0132:  MOVWF  FF6
0134:  MOVLW  01
0136:  ADDWFC FF7,F
0138:  TBLRD*+
013A:  MOVF   FF5,W
013C:  RETURN 0
013E:  DATA 00,00
0140:  CLRF   FF7
0142:  ADDLW  50
0144:  MOVWF  FF6
0146:  MOVLW  01
0148:  ADDWFC FF7,F
014A:  TBLRD*+
014C:  MOVF   FF5,W
014E:  RETURN 0
0150:  DATA 20,00
0152:  CLRF   FF7
0154:  ADDLW  62
0156:  MOVWF  FF6
0158:  MOVLW  01
015A:  ADDWFC FF7,F
015C:  TBLRD*+
015E:  MOVF   FF5,W
0160:  RETURN 0
0162:  DATA 09,02
0164:  DATA 29,00
0166:  DATA 01,01
0168:  DATA 00,C0
016A:  DATA 32,09
016C:  DATA 04,00
016E:  DATA 00,02
0170:  DATA 03,00
0172:  DATA 00,00
0174:  DATA 09,21
0176:  DATA 00,01
0178:  DATA 00,01
017A:  DATA 22,20
017C:  DATA 00,07
017E:  DATA 05,81
0180:  DATA 03,40
0182:  DATA 00,0A
0184:  DATA 07,05
0186:  DATA 01,03
0188:  DATA 40,00
018A:  DATA 0A,00
018C:  CLRF   FF7
018E:  ADDLW  9C
0190:  MOVWF  FF6
0192:  MOVLW  01
0194:  ADDWFC FF7,F
0196:  TBLRD*+
0198:  MOVF   FF5,W
019A:  RETURN 0
019C:  DATA 01,00
019E:  CLRF   FF7
01A0:  ADDLW  AE
01A2:  MOVWF  FF6
01A4:  MOVLW  01
01A6:  ADDWFC FF7,F
01A8:  TBLRD*+
01AA:  MOVF   FF5,W
01AC:  RETURN 0
01AE:  DATA 12,00
01B0:  CLRF   FF7
01B2:  ADDLW  C0
01B4:  MOVWF  FF6
01B6:  MOVLW  01
01B8:  ADDWFC FF7,F
01BA:  TBLRD*+
01BC:  MOVF   FF5,W
01BE:  RETURN 0
01C0:  DATA 12,01
01C2:  DATA 10,01
01C4:  DATA 00,00
01C6:  DATA 00,40
01C8:  DATA 61,04
01CA:  DATA 04,00
01CC:  DATA 00,01
01CE:  DATA 01,02
01D0:  DATA 00,01
01D2:  CLRF   FF7
01D4:  ADDLW  E2
01D6:  MOVWF  FF6
01D8:  MOVLW  01
01DA:  ADDWFC FF7,F
01DC:  TBLRD*+
01DE:  MOVF   FF5,W
01E0:  RETURN 0
01E2:  DATA 04,03
01E4:  DATA 00,04
01E6:  DATA 08,03
01E8:  DATA 42,00
01EA:  DATA 4D,00
01EC:  DATA 45,00
01EE:  DATA 14,03
01F0:  DATA 42,00
01F2:  DATA 4D,00
01F4:  DATA 45,00
01F6:  DATA 2D,00
01F8:  DATA 34,00
01FA:  DATA 33,00
01FC:  DATA 39,00
01FE:  DATA 30,00
0200:  DATA 20,00
0202:  CLRF   FF7
0204:  ADDLW  12
0206:  MOVWF  FF6
0208:  MOVLW  02
020A:  ADDWFC FF7,F
020C:  TBLRD*+
020E:  MOVF   FF5,W
0210:  RETURN 0
0212:  DATA 28,0C
0214:  DATA 01,06
*
02B6:  MOVLB  1
02B8:  MOVF   xED,W
02BA:  MULWF  xEF
02BC:  MOVFF  FF3,01
02C0:  MOVFF  FF4,00
02C4:  MULWF  xF0
02C6:  MOVF   FF3,W
02C8:  ADDWF  00,F
02CA:  MOVF   xEE,W
02CC:  MULWF  xEF
02CE:  MOVF   FF3,W
02D0:  ADDWFC 00,W
02D2:  MOVWF  02
02D4:  MOVLB  0
02D6:  RETURN 0
*
0478:  ADDWF  FE8,W
047A:  CLRF   FF7
047C:  RLCF   FF7,F
047E:  ADDLW  93
0480:  MOVWF  FF6
0482:  MOVLW  04
0484:  ADDWFC FF7,F
0486:  TBLRD*-
0488:  MOVF   FF5,W
048A:  MOVWF  FFA
048C:  TBLRD*
048E:  MOVF   FF5,W
0490:  MOVWF  FF9
0492:  DATA FA,03
0494:  DATA 0A,04
0496:  DATA 1A,04
0498:  DATA 2A,04
*
0F62:  DATA 0C,42
0F64:  DATA 4D,45
0F66:  DATA 34,33
0F68:  DATA 39,30
0F6A:  DATA 20,4F
0F6C:  DATA 78,69
0F6E:  DATA 6D,65
0F70:  DATA 74,65
0F72:  DATA 72,00
0F74:  DATA 0C,44
0F76:  DATA 61,74
0F78:  DATA 61,20
0F7A:  DATA 72,65
0F7C:  DATA 61,64
0F7E:  DATA 79,20
0F80:  DATA 66,6F
0F82:  DATA 72,0A
0F84:  DATA 75,70
0F86:  DATA 6C,6F
0F88:  DATA 61,64
0F8A:  DATA 00,00
0F8C:  DATA 0C,4D
0F8E:  DATA 65,61
0F90:  DATA 73,75
0F92:  DATA 72,69
0F94:  DATA 6E,67
0F96:  DATA 2E,2E
0F98:  DATA 2E,20
0F9A:  DATA 20,20
0F9C:  DATA 20,00
0F9E:  DATA 0A,20
0FA0:  DATA 20,2D
0FA2:  DATA 2D,2D
0FA4:  DATA 2D,20
0FA6:  DATA 25,30
0FA8:  DATA 32,75
0FAA:  DATA 20,2D
0FAC:  DATA 2D,2D
0FAE:  DATA 2D,20
0FB0:  DATA 20,00
0FB2:  DATA 0C,20
0FB4:  DATA 53,50
0FB6:  DATA 4F,32
0FB8:  DATA 20,52
0FBA:  DATA 65,61
0FBC:  DATA 64,20
0FBE:  DATA 45,72
0FC0:  DATA 72,6F
0FC2:  DATA 72,00
0FC4:  DATA 0C,20
0FC6:  DATA 53,50
0FC8:  DATA 4F,32
0FCA:  DATA 20,3D
0FCC:  DATA 20,25
0FCE:  DATA 33,2E
0FD0:  DATA 32,66
0FD2:  DATA 0A,20
0FD4:  DATA 20,52
0FD6:  DATA 20,3D
0FD8:  DATA 20,25
0FDA:  DATA 32,2E
0FDC:  DATA 34,66
0FDE:  DATA 00,00
0FE0:  DATA 0C,49
0FE2:  DATA 52,3A
0FE4:  DATA 20,25
0FE6:  DATA 31,2E
0FE8:  DATA 33,66
0FEA:  DATA 20,25
0FEC:  DATA 31,2E
0FEE:  DATA 33,66
0FF0:  DATA 0A,52
0FF2:  DATA 65,64
0FF4:  DATA 3A,25
0FF6:  DATA 31,2E
0FF8:  DATA 33,66
0FFA:  DATA 20,25
0FFC:  DATA 31,2E
0FFE:  DATA 33,66
1000:  DATA 00,00
1002:  DATA 0C,42
1004:  DATA 61,64
1006:  DATA 20,44
1008:  DATA 61,74
100A:  DATA 61,20
100C:  DATA 6C,6F
100E:  DATA 61,64
1010:  DATA 0A,63
1012:  DATA 6F,64
1014:  DATA 65,20
1016:  DATA 73,65
1018:  DATA 6E,74
101A:  DATA 2E,00
101C:  DATA 0C,44
101E:  DATA 43,20
1020:  DATA 64,61
1022:  DATA 74,61
1024:  DATA 20,73
1026:  DATA 65,6E
1028:  DATA 74,0A
102A:  DATA 74,6F
102C:  DATA 20,50
102E:  DATA 43,00
1030:  DATA 0C,31
1032:  DATA 73,74
1034:  DATA 20,68
1036:  DATA 61,6C
1038:  DATA 66,20
103A:  DATA 6F,66
103C:  DATA 20,41
103E:  DATA 43,36
1040:  DATA 36,30
1042:  DATA 0A,64
1044:  DATA 61,74
1046:  DATA 61,20
1048:  DATA 73,65
104A:  DATA 6E,74
104C:  DATA 20,74
104E:  DATA 6F,20
1050:  DATA 50,43
1052:  DATA 00,00
1054:  DATA 0C,32
1056:  DATA 6E,64
1058:  DATA 20,68
105A:  DATA 61,6C
105C:  DATA 66,20
105E:  DATA 6F,66
1060:  DATA 20,41
1062:  DATA 43,36
1064:  DATA 36,30
1066:  DATA 0A,64
1068:  DATA 61,74
106A:  DATA 61,20
106C:  DATA 73,65
106E:  DATA 6E,74
1070:  DATA 20,74
1072:  DATA 6F,20
1074:  DATA 50,43
1076:  DATA 00,00
1078:  DATA 0C,31
107A:  DATA 73,74
107C:  DATA 20,68
107E:  DATA 61,6C
1080:  DATA 66,20
1082:  DATA 6F,66
1084:  DATA 20,41
1086:  DATA 43,39
1088:  DATA 34,30
108A:  DATA 0A,64
108C:  DATA 61,74
108E:  DATA 61,20
1090:  DATA 73,65
1092:  DATA 6E,74
1094:  DATA 20,74
1096:  DATA 6F,20
1098:  DATA 50,43
109A:  DATA 00,00
109C:  DATA 0C,32
109E:  DATA 6E,64
10A0:  DATA 20,68
10A2:  DATA 61,6C
10A4:  DATA 66,20
10A6:  DATA 6F,66
10A8:  DATA 20,41
10AA:  DATA 43,39
10AC:  DATA 34,30
10AE:  DATA 0A,64
10B0:  DATA 61,74
10B2:  DATA 61,20
10B4:  DATA 73,65
10B6:  DATA 6E,74
10B8:  DATA 20,74
10BA:  DATA 6F,20
10BC:  DATA 50,43
10BE:  DATA 00,00
10C0:  DATA 2F,66
10C2:  DATA 42,61
10C4:  DATA 64,20
10C6:  DATA 44,61
10C8:  DATA 74,61
10CA:  DATA 20,6C
10CC:  DATA 6F,61
10CE:  DATA 64,2F
10D0:  DATA 6E,63
10D2:  DATA 6F,64
10D4:  DATA 65,20
10D6:  DATA 73,65
10D8:  DATA 6E,74
10DA:  DATA 2E,00
*
1318:  TBLRD*+
131A:  MOVF   FF5,F
131C:  BZ    1336
131E:  MOVFF  FF6,1A0
1322:  MOVFF  FF7,1A1
1326:  MOVFF  FF5,1C7
132A:  RCALL  12BE
132C:  MOVFF  1A0,FF6
1330:  MOVFF  1A1,FF7
1334:  BRA    1318
1336:  RETURN 0
*
1678:  MOVLB  1
167A:  CLRF   x98
167C:  CLRF   x99
167E:  MOVLW  01
1680:  MOVWF  x9A
1682:  CLRF   FDA
1684:  CLRF   FD9
1686:  MOVWF  x9D
1688:  MOVLW  90
168A:  MOVWF  x9C
168C:  MOVLW  01
168E:  MOVWF  FEA
1690:  MOVLW  94
1692:  MOVWF  FE9
1694:  MOVFF  19D,FE2
1698:  MOVFF  19C,FE1
169C:  MOVFF  19A,19B
16A0:  BCF    FD8.0
16A2:  MOVF   FE5,W
16A4:  MULWF  FEE
16A6:  MOVF   FF3,W
16A8:  ADDWFC x98,F
16AA:  MOVF   FF4,W
16AC:  ADDWFC x99,F
16AE:  DECFSZ x9B,F
16B0:  BRA    16A0
16B2:  MOVFF  198,FDE
16B6:  MOVFF  199,198
16BA:  CLRF   x99
16BC:  BTFSC  FD8.0
16BE:  INCF   x99,F
16C0:  INCF   x9C,F
16C2:  BTFSC  FD8.2
16C4:  INCF   x9D,F
16C6:  INCF   x9A,F
16C8:  MOVF   x9A,W
16CA:  SUBLW  05
16CC:  BNZ   168C
16CE:  MOVLB  0
16D0:  RETURN 0
*
1A56:  MOVFF  17A,FEA
1A5A:  MOVFF  179,FE9
1A5E:  MOVLB  1
1A60:  MOVFF  1D3,FEF
1A64:  INCF   FE9,F
1A66:  BTFSC  FD8.2
1A68:  INCF   FEA,F
1A6A:  CLRF   FEF
1A6C:  INCF   x79,F
1A6E:  BTFSC  FD8.2
1A70:  INCF   x7A,F
1A72:  MOVLB  0
1A74:  RETURN 0
1A76:  TBLRD*+
1A78:  MOVFF  FF6,1C7
1A7C:  MOVFF  FF7,1C8
1A80:  MOVFF  FF5,1D3
1A84:  RCALL  1A56
1A86:  MOVFF  1C7,FF6
1A8A:  MOVFF  1C8,FF7
1A8E:  MOVLB  1
1A90:  DECFSZ xC6,F
1A92:  BRA    1A96
1A94:  BRA    1A9A
1A96:  MOVLB  0
1A98:  BRA    1A76
1A9A:  MOVLB  0
1A9C:  RETURN 0
1A9E:  MOVLB  1
1AA0:  MOVF   xA3,W
1AA2:  CLRF   01
1AA4:  SUBWF  xA2,W
1AA6:  BC    1AAE
1AA8:  MOVFF  1A2,00
1AAC:  BRA    1AC6
1AAE:  CLRF   00
1AB0:  MOVLW  08
1AB2:  MOVWF  xA4
1AB4:  RLCF   xA2,F
1AB6:  RLCF   00,F
1AB8:  MOVF   xA3,W
1ABA:  SUBWF  00,W
1ABC:  BTFSC  FD8.0
1ABE:  MOVWF  00
1AC0:  RLCF   01,F
1AC2:  DECFSZ xA4,F
1AC4:  BRA    1AB4
1AC6:  MOVLB  0
1AC8:  RETURN 0
1ACA:  MOVF   01,W
1ACC:  MOVFF  1A0,1A2
1AD0:  MOVLW  64
1AD2:  MOVLB  1
1AD4:  MOVWF  xA3
1AD6:  MOVLB  0
1AD8:  RCALL  1A9E
1ADA:  MOVFF  00,1A0
1ADE:  MOVF   01,W
1AE0:  MOVLW  30
1AE2:  BNZ   1AF4
1AE4:  MOVLB  1
1AE6:  BTFSS  xA1.1
1AE8:  BRA    1B08
1AEA:  BTFSC  xA1.3
1AEC:  BRA    1B08
1AEE:  BTFSC  xA1.4
1AF0:  MOVLW  20
1AF2:  BRA    1AFC
1AF4:  MOVLB  1
1AF6:  BCF    xA1.3
1AF8:  BCF    xA1.4
1AFA:  BSF    xA1.0
1AFC:  ADDWF  01,F
1AFE:  MOVFF  01,1D3
1B02:  MOVLB  0
1B04:  RCALL  1A56
1B06:  MOVLB  1
1B08:  MOVFF  1A0,1A2
1B0C:  MOVLW  0A
1B0E:  MOVWF  xA3
1B10:  MOVLB  0
1B12:  RCALL  1A9E
1B14:  MOVFF  00,1A0
1B18:  MOVF   01,W
1B1A:  MOVLW  30
1B1C:  BNZ   1B2E
1B1E:  MOVLB  1
1B20:  BTFSC  xA1.3
1B22:  BRA    1B38
1B24:  BTFSS  xA1.0
1B26:  BRA    1B38
1B28:  BTFSC  xA1.4
1B2A:  MOVLW  20
1B2C:  MOVLB  0
1B2E:  ADDWF  01,F
1B30:  MOVFF  01,1D3
1B34:  RCALL  1A56
1B36:  MOVLB  1
1B38:  MOVLW  30
1B3A:  ADDWF  xA0,F
1B3C:  MOVFF  1A0,1D3
1B40:  MOVLB  0
1B42:  RCALL  1A56
1B44:  GOTO   1D1E (RETURN)
*
1E04:  MOVLW  8E
1E06:  MOVWF  00
1E08:  MOVFF  1C9,01
1E0C:  MOVFF  1C8,02
1E10:  CLRF   03
1E12:  MOVF   01,F
1E14:  BNZ   1E28
1E16:  MOVFF  02,01
1E1A:  CLRF   02
1E1C:  MOVLW  08
1E1E:  SUBWF  00,F
1E20:  MOVF   01,F
1E22:  BNZ   1E28
1E24:  CLRF   00
1E26:  BRA    1E38
1E28:  BCF    FD8.0
1E2A:  BTFSC  01.7
1E2C:  BRA    1E36
1E2E:  RLCF   02,F
1E30:  RLCF   01,F
1E32:  DECF   00,F
1E34:  BRA    1E28
1E36:  BCF    01.7
1E38:  RETURN 0
1E3A:  MOVLB  1
1E3C:  MOVF   xD3,W
1E3E:  BTFSC  FD8.2
1E40:  BRA    1F24
1E42:  MOVWF  00
1E44:  MOVF   xD7,W
1E46:  BTFSC  FD8.2
1E48:  BRA    1F24
1E4A:  ADDWF  00,F
1E4C:  BNC   1E56
1E4E:  MOVLW  81
1E50:  ADDWF  00,F
1E52:  BC    1F24
1E54:  BRA    1E5E
1E56:  MOVLW  7F
1E58:  SUBWF  00,F
1E5A:  BNC   1F24
1E5C:  BZ    1F24
1E5E:  MOVFF  1D4,1DB
1E62:  MOVF   xD8,W
1E64:  XORWF  xDB,F
1E66:  BSF    xD4.7
1E68:  BSF    xD8.7
1E6A:  MOVF   xD6,W
1E6C:  MULWF  xDA
1E6E:  MOVFF  FF4,1DD
1E72:  MOVF   xD5,W
1E74:  MULWF  xD9
1E76:  MOVFF  FF4,03
1E7A:  MOVFF  FF3,1DC
1E7E:  MULWF  xDA
1E80:  MOVF   FF3,W
1E82:  ADDWF  xDD,F
1E84:  MOVF   FF4,W
1E86:  ADDWFC xDC,F
1E88:  MOVLW  00
1E8A:  ADDWFC 03,F
1E8C:  MOVF   xD6,W
1E8E:  MULWF  xD9
1E90:  MOVF   FF3,W
1E92:  ADDWF  xDD,F
1E94:  MOVF   FF4,W
1E96:  ADDWFC xDC,F
1E98:  MOVLW  00
1E9A:  CLRF   02
1E9C:  ADDWFC 03,F
1E9E:  ADDWFC 02,F
1EA0:  MOVF   xD4,W
1EA2:  MULWF  xDA
1EA4:  MOVF   FF3,W
1EA6:  ADDWF  xDC,F
1EA8:  MOVF   FF4,W
1EAA:  ADDWFC 03,F
1EAC:  MOVLW  00
1EAE:  ADDWFC 02,F
1EB0:  MOVF   xD4,W
1EB2:  MULWF  xD9
1EB4:  MOVF   FF3,W
1EB6:  ADDWF  03,F
1EB8:  MOVF   FF4,W
1EBA:  ADDWFC 02,F
1EBC:  MOVLW  00
1EBE:  CLRF   01
1EC0:  ADDWFC 01,F
1EC2:  MOVF   xD6,W
1EC4:  MULWF  xD8
1EC6:  MOVF   FF3,W
1EC8:  ADDWF  xDC,F
1ECA:  MOVF   FF4,W
1ECC:  ADDWFC 03,F
1ECE:  MOVLW  00
1ED0:  ADDWFC 02,F
1ED2:  ADDWFC 01,F
1ED4:  MOVF   xD5,W
1ED6:  MULWF  xD8
1ED8:  MOVF   FF3,W
1EDA:  ADDWF  03,F
1EDC:  MOVF   FF4,W
1EDE:  ADDWFC 02,F
1EE0:  MOVLW  00
1EE2:  ADDWFC 01,F
1EE4:  MOVF   xD4,W
1EE6:  MULWF  xD8
1EE8:  MOVF   FF3,W
1EEA:  ADDWF  02,F
1EEC:  MOVF   FF4,W
1EEE:  ADDWFC 01,F
1EF0:  INCF   00,F
1EF2:  BTFSC  01.7
1EF4:  BRA    1F00
1EF6:  RLCF   xDC,F
1EF8:  RLCF   03,F
1EFA:  RLCF   02,F
1EFC:  RLCF   01,F
1EFE:  DECF   00,F
1F00:  MOVLW  00
1F02:  BTFSS  xDC.7
1F04:  BRA    1F1A
1F06:  INCF   03,F
1F08:  ADDWFC 02,F
1F0A:  ADDWFC 01,F
1F0C:  MOVF   01,W
1F0E:  BNZ   1F1A
1F10:  MOVF   02,W
1F12:  BNZ   1F1A
1F14:  MOVF   03,W
1F16:  BNZ   1F1A
1F18:  INCF   00,F
1F1A:  BTFSC  xDB.7
1F1C:  BSF    01.7
1F1E:  BTFSS  xDB.7
1F20:  BCF    01.7
1F22:  BRA    1F2C
1F24:  CLRF   00
1F26:  CLRF   01
1F28:  CLRF   02
1F2A:  CLRF   03
1F2C:  MOVLB  0
1F2E:  RETURN 0
1F30:  MOVLB  1
1F32:  MOVF   xB5,W
1F34:  BTFSC  FD8.2
1F36:  BRA    2082
1F38:  MOVWF  xC1
1F3A:  MOVF   xB9,W
1F3C:  BTFSC  FD8.2
1F3E:  BRA    2082
1F40:  SUBWF  xC1,F
1F42:  BNC   1F4E
1F44:  MOVLW  7F
1F46:  ADDWF  xC1,F
1F48:  BTFSC  FD8.0
1F4A:  BRA    2082
1F4C:  BRA    1F5A
1F4E:  MOVLW  81
1F50:  SUBWF  xC1,F
1F52:  BTFSS  FD8.0
1F54:  BRA    2082
1F56:  BTFSC  FD8.2
1F58:  BRA    2082
1F5A:  MOVFF  1C1,00
1F5E:  CLRF   01
1F60:  CLRF   02
1F62:  CLRF   03
1F64:  CLRF   xC0
1F66:  MOVFF  1B6,1BF
1F6A:  BSF    xBF.7
1F6C:  MOVFF  1B7,1BE
1F70:  MOVFF  1B8,1BD
1F74:  MOVLW  19
1F76:  MOVWF  xC1
1F78:  MOVF   xBC,W
1F7A:  SUBWF  xBD,F
1F7C:  BC    1F98
1F7E:  MOVLW  01
1F80:  SUBWF  xBE,F
1F82:  BC    1F98
1F84:  SUBWF  xBF,F
1F86:  BC    1F98
1F88:  SUBWF  xC0,F
1F8A:  BC    1F98
1F8C:  INCF   xC0,F
1F8E:  INCF   xBF,F
1F90:  INCF   xBE,F
1F92:  MOVF   xBC,W
1F94:  ADDWF  xBD,F
1F96:  BRA    1FE8
1F98:  MOVF   xBB,W
1F9A:  SUBWF  xBE,F
1F9C:  BC    1FC2
1F9E:  MOVLW  01
1FA0:  SUBWF  xBF,F
1FA2:  BC    1FC2
1FA4:  SUBWF  xC0,F
1FA6:  BC    1FC2
1FA8:  INCF   xC0,F
1FAA:  INCF   xBF,F
1FAC:  MOVF   xBB,W
1FAE:  ADDWF  xBE,F
1FB0:  MOVF   xBC,W
1FB2:  ADDWF  xBD,F
1FB4:  BNC   1FE8
1FB6:  INCF   xBE,F
1FB8:  BNZ   1FE8
1FBA:  INCF   xBF,F
1FBC:  BNZ   1FE8
1FBE:  INCF   xC0,F
1FC0:  BRA    1FE8
1FC2:  MOVF   xBA,W
1FC4:  IORLW  80
1FC6:  SUBWF  xBF,F
1FC8:  BC    1FE6
1FCA:  MOVLW  01
1FCC:  SUBWF  xC0,F
1FCE:  BC    1FE6
1FD0:  INCF   xC0,F
1FD2:  MOVF   xBA,W
1FD4:  IORLW  80
1FD6:  ADDWF  xBF,F
1FD8:  MOVF   xBB,W
1FDA:  ADDWF  xBE,F
1FDC:  BNC   1FB0
1FDE:  INCF   xBF,F
1FE0:  BNZ   1FB0
1FE2:  INCF   xC0,F
1FE4:  BRA    1FB0
1FE6:  BSF    03.0
1FE8:  DECFSZ xC1,F
1FEA:  BRA    1FEE
1FEC:  BRA    2004
1FEE:  BCF    FD8.0
1FF0:  RLCF   xBD,F
1FF2:  RLCF   xBE,F
1FF4:  RLCF   xBF,F
1FF6:  RLCF   xC0,F
1FF8:  BCF    FD8.0
1FFA:  RLCF   03,F
1FFC:  RLCF   02,F
1FFE:  RLCF   01,F
2000:  RLCF   xC2,F
2002:  BRA    1F78
2004:  BTFSS  xC2.0
2006:  BRA    2014
2008:  BCF    FD8.0
200A:  RRCF   01,F
200C:  RRCF   02,F
200E:  RRCF   03,F
2010:  RRCF   xC2,F
2012:  BRA    2018
2014:  DECF   00,F
2016:  BZ    2082
2018:  BTFSC  xC2.7
201A:  BRA    2058
201C:  BCF    FD8.0
201E:  RLCF   xBD,F
2020:  RLCF   xBE,F
2022:  RLCF   xBF,F
2024:  RLCF   xC0,F
2026:  MOVF   xBC,W
2028:  SUBWF  xBD,F
202A:  BC    203A
202C:  MOVLW  01
202E:  SUBWF  xBE,F
2030:  BC    203A
2032:  SUBWF  xBF,F
2034:  BC    203A
2036:  SUBWF  xC0,F
2038:  BNC   206E
203A:  MOVF   xBB,W
203C:  SUBWF  xBE,F
203E:  BC    204A
2040:  MOVLW  01
2042:  SUBWF  xBF,F
2044:  BC    204A
2046:  SUBWF  xC0,F
2048:  BNC   206E
204A:  MOVF   xBA,W
204C:  IORLW  80
204E:  SUBWF  xBF,F
2050:  BC    2058
2052:  MOVLW  01
2054:  SUBWF  xC0,F
2056:  BNC   206E
2058:  INCF   03,F
205A:  BNZ   206E
205C:  INCF   02,F
205E:  BNZ   206E
2060:  INCF   01,F
2062:  BNZ   206E
2064:  INCF   00,F
2066:  BZ    2082
2068:  RRCF   01,F
206A:  RRCF   02,F
206C:  RRCF   03,F
206E:  MOVFF  1B6,1C1
2072:  MOVF   xBA,W
2074:  XORWF  xC1,F
2076:  BTFSS  xC1.7
2078:  BRA    207E
207A:  BSF    01.7
207C:  BRA    208A
207E:  BCF    01.7
2080:  BRA    208A
2082:  CLRF   00
2084:  CLRF   01
2086:  CLRF   02
2088:  CLRF   03
208A:  MOVLB  0
208C:  GOTO   287A (RETURN)
2090:  MOVLW  80
2092:  BTFSS  FD8.1
2094:  BRA    209A
2096:  MOVLB  1
2098:  XORWF  xD3,F
209A:  MOVLB  1
209C:  CLRF   xD8
209E:  CLRF   xD9
20A0:  MOVFF  1CF,1D7
20A4:  MOVF   xD3,W
20A6:  XORWF  xD7,F
20A8:  MOVF   xCE,W
20AA:  BTFSC  FD8.2
20AC:  BRA    226C
20AE:  MOVWF  xD6
20B0:  MOVWF  00
20B2:  MOVF   xD2,W
20B4:  BTFSC  FD8.2
20B6:  BRA    227E
20B8:  SUBWF  xD6,F
20BA:  BTFSC  FD8.2
20BC:  BRA    21C4
20BE:  BNC   213C
20C0:  MOVFF  1D3,1DC
20C4:  BSF    xDC.7
20C6:  MOVFF  1D4,1DB
20CA:  MOVFF  1D5,1DA
20CE:  CLRF   xD9
20D0:  BCF    FD8.0
20D2:  RRCF   xDC,F
20D4:  RRCF   xDB,F
20D6:  RRCF   xDA,F
20D8:  RRCF   xD9,F
20DA:  DECFSZ xD6,F
20DC:  BRA    20CE
20DE:  BTFSS  xD7.7
20E0:  BRA    20E8
20E2:  BSF    xD8.0
20E4:  BRA    22A6
20E6:  BCF    xD8.0
20E8:  BCF    xD6.0
20EA:  BSF    xD8.4
20EC:  MOVLW  01
20EE:  MOVWF  FEA
20F0:  MOVLW  D1
20F2:  MOVWF  FE9
20F4:  BRA    22CC
20F6:  BCF    xD8.4
20F8:  BTFSC  xD7.7
20FA:  BRA    2110
20FC:  BTFSS  xD6.0
20FE:  BRA    2126
2100:  RRCF   xDC,F
2102:  RRCF   xDB,F
2104:  RRCF   xDA,F
2106:  RRCF   xD9,F
2108:  INCF   00,F
210A:  BTFSC  FD8.2
210C:  BRA    229C
210E:  BRA    2126
2110:  BTFSC  xDC.7
2112:  BRA    212C
2114:  BCF    FD8.0
2116:  RLCF   xD9,F
2118:  RLCF   xDA,F
211A:  RLCF   xDB,F
211C:  RLCF   xDC,F
211E:  DECF   00,F
2120:  BTFSC  FD8.2
2122:  BRA    229C
2124:  BRA    2110
2126:  BSF    xD8.6
2128:  BRA    2204
212A:  BCF    xD8.6
212C:  MOVFF  1CF,1D7
2130:  BTFSS  xCF.7
2132:  BRA    2138
2134:  BSF    xDC.7
2136:  BRA    228E
2138:  BCF    xDC.7
213A:  BRA    228E
213C:  MOVFF  1D2,1D6
2140:  MOVFF  1D2,00
2144:  MOVF   xCE,W
2146:  SUBWF  xD6,F
2148:  MOVFF  1CF,1DC
214C:  BSF    xDC.7
214E:  MOVFF  1D0,1DB
2152:  MOVFF  1D1,1DA
2156:  CLRF   xD9
2158:  BCF    FD8.0
215A:  RRCF   xDC,F
215C:  RRCF   xDB,F
215E:  RRCF   xDA,F
2160:  RRCF   xD9,F
2162:  DECFSZ xD6,F
2164:  BRA    2156
2166:  BTFSS  xD7.7
2168:  BRA    2170
216A:  BSF    xD8.1
216C:  BRA    22A6
216E:  BCF    xD8.1
2170:  BCF    xD6.0
2172:  BSF    xD8.5
2174:  MOVLW  01
2176:  MOVWF  FEA
2178:  MOVLW  D5
217A:  MOVWF  FE9
217C:  BRA    22CC
217E:  BCF    xD8.5
2180:  BTFSC  xD7.7
2182:  BRA    2198
2184:  BTFSS  xD6.0
2186:  BRA    21AE
2188:  RRCF   xDC,F
218A:  RRCF   xDB,F
218C:  RRCF   xDA,F
218E:  RRCF   xD9,F
2190:  INCF   00,F
2192:  BTFSC  FD8.2
2194:  BRA    229C
2196:  BRA    21AE
2198:  BTFSC  xDC.7
219A:  BRA    21B4
219C:  BCF    FD8.0
219E:  RLCF   xD9,F
21A0:  RLCF   xDA,F
21A2:  RLCF   xDB,F
21A4:  RLCF   xDC,F
21A6:  DECF   00,F
21A8:  BTFSC  FD8.2
21AA:  BRA    229C
21AC:  BRA    2198
21AE:  BSF    xD8.7
21B0:  BRA    2204
21B2:  BCF    xD8.7
21B4:  MOVFF  1D3,1D7
21B8:  BTFSS  xD3.7
21BA:  BRA    21C0
21BC:  BSF    xDC.7
21BE:  BRA    228E
21C0:  BCF    xDC.7
21C2:  BRA    228E
21C4:  MOVFF  1D3,1DC
21C8:  BSF    xDC.7
21CA:  MOVFF  1D4,1DB
21CE:  MOVFF  1D5,1DA
21D2:  BTFSS  xD7.7
21D4:  BRA    21DE
21D6:  BCF    xDC.7
21D8:  BSF    xD8.2
21DA:  BRA    22A6
21DC:  BCF    xD8.2
21DE:  CLRF   xD9
21E0:  BCF    xD6.0
21E2:  MOVLW  01
21E4:  MOVWF  FEA
21E6:  MOVLW  D1
21E8:  MOVWF  FE9
21EA:  BRA    22CC
21EC:  BTFSC  xD7.7
21EE:  BRA    2228
21F0:  MOVFF  1CF,1D7
21F4:  BTFSS  xD6.0
21F6:  BRA    2204
21F8:  RRCF   xDC,F
21FA:  RRCF   xDB,F
21FC:  RRCF   xDA,F
21FE:  RRCF   xD9,F
2200:  INCF   00,F
2202:  BZ    229C
2204:  BTFSS  xD9.7
2206:  BRA    221E
2208:  INCF   xDA,F
220A:  BNZ   221E
220C:  INCF   xDB,F
220E:  BNZ   221E
2210:  INCF   xDC,F
2212:  BNZ   221E
2214:  RRCF   xDC,F
2216:  RRCF   xDB,F
2218:  RRCF   xDA,F
221A:  INCF   00,F
221C:  BZ    229C
221E:  BTFSC  xD8.6
2220:  BRA    212A
2222:  BTFSC  xD8.7
2224:  BRA    21B2
2226:  BRA    2260
2228:  MOVLW  80
222A:  XORWF  xDC,F
222C:  BTFSS  xDC.7
222E:  BRA    2238
2230:  BRA    22A6
2232:  MOVFF  1D3,1D7
2236:  BRA    224C
2238:  MOVFF  1CF,1D7
223C:  MOVF   xDC,F
223E:  BNZ   224C
2240:  MOVF   xDB,F
2242:  BNZ   224C
2244:  MOVF   xDA,F
2246:  BNZ   224C
2248:  CLRF   00
224A:  BRA    228E
224C:  BTFSC  xDC.7
224E:  BRA    2260
2250:  BCF    FD8.0
2252:  RLCF   xD9,F
2254:  RLCF   xDA,F
2256:  RLCF   xDB,F
2258:  RLCF   xDC,F
225A:  DECFSZ 00,F
225C:  BRA    224C
225E:  BRA    229C
2260:  BTFSS  xD7.7
2262:  BRA    2268
2264:  BSF    xDC.7
2266:  BRA    228E
2268:  BCF    xDC.7
226A:  BRA    228E
226C:  MOVFF  1D2,00
2270:  MOVFF  1D3,1DC
2274:  MOVFF  1D4,1DB
2278:  MOVFF  1D5,1DA
227C:  BRA    228E
227E:  MOVFF  1CE,00
2282:  MOVFF  1CF,1DC
2286:  MOVFF  1D0,1DB
228A:  MOVFF  1D1,1DA
228E:  MOVFF  1DC,01
2292:  MOVFF  1DB,02
2296:  MOVFF  1DA,03
229A:  BRA    2304
229C:  CLRF   00
229E:  CLRF   01
22A0:  CLRF   02
22A2:  CLRF   03
22A4:  BRA    2304
22A6:  CLRF   xD9
22A8:  COMF   xDA,F
22AA:  COMF   xDB,F
22AC:  COMF   xDC,F
22AE:  COMF   xD9,F
22B0:  INCF   xD9,F
22B2:  BNZ   22BE
22B4:  INCF   xDA,F
22B6:  BNZ   22BE
22B8:  INCF   xDB,F
22BA:  BNZ   22BE
22BC:  INCF   xDC,F
22BE:  BTFSC  xD8.0
22C0:  BRA    20E6
22C2:  BTFSC  xD8.1
22C4:  BRA    216E
22C6:  BTFSC  xD8.2
22C8:  BRA    21DC
22CA:  BRA    2232
22CC:  MOVF   FEF,W
22CE:  ADDWF  xDA,F
22D0:  BNC   22DC
22D2:  INCF   xDB,F
22D4:  BNZ   22DC
22D6:  INCF   xDC,F
22D8:  BTFSC  FD8.2
22DA:  BSF    xD6.0
22DC:  MOVF   FED,F
22DE:  MOVF   FEF,W
22E0:  ADDWF  xDB,F
22E2:  BNC   22EA
22E4:  INCF   xDC,F
22E6:  BTFSC  FD8.2
22E8:  BSF    xD6.0
22EA:  MOVF   FED,F
22EC:  MOVF   FEF,W
22EE:  BTFSC  FEF.7
22F0:  BRA    22F4
22F2:  XORLW  80
22F4:  ADDWF  xDC,F
22F6:  BTFSC  FD8.0
22F8:  BSF    xD6.0
22FA:  BTFSC  xD8.4
22FC:  BRA    20F6
22FE:  BTFSC  xD8.5
2300:  BRA    217E
2302:  BRA    21EC
2304:  MOVLB  0
2306:  RETURN 0
2308:  MOVFF  1B6,1BD
230C:  MOVLB  1
230E:  MOVF   xBA,W
2310:  XORWF  xBD,F
2312:  BTFSS  xBD.7
2314:  BRA    2320
2316:  BCF    FD8.2
2318:  BCF    FD8.0
231A:  BTFSC  xB6.7
231C:  BSF    FD8.0
231E:  BRA    237E
2320:  MOVFF  1B6,1BD
2324:  MOVFF  1B9,1BE
2328:  MOVF   xB5,W
232A:  SUBWF  xBE,F
232C:  BZ    233A
232E:  BTFSS  xBD.7
2330:  BRA    237E
2332:  MOVF   FD8,W
2334:  XORLW  01
2336:  MOVWF  FD8
2338:  BRA    237E
233A:  MOVFF  1BA,1BE
233E:  MOVF   xB6,W
2340:  SUBWF  xBE,F
2342:  BZ    2350
2344:  BTFSS  xBD.7
2346:  BRA    237E
2348:  MOVF   FD8,W
234A:  XORLW  01
234C:  MOVWF  FD8
234E:  BRA    237E
2350:  MOVFF  1BB,1BE
2354:  MOVF   xB7,W
2356:  SUBWF  xBE,F
2358:  BZ    2366
235A:  BTFSS  xBD.7
235C:  BRA    237E
235E:  MOVF   FD8,W
2360:  XORLW  01
2362:  MOVWF  FD8
2364:  BRA    237E
2366:  MOVFF  1BC,1BE
236A:  MOVF   xB8,W
236C:  SUBWF  xBE,F
236E:  BZ    237C
2370:  BTFSS  xBD.7
2372:  BRA    237E
2374:  MOVF   FD8,W
2376:  XORLW  01
2378:  MOVWF  FD8
237A:  BRA    237E
237C:  BCF    FD8.0
237E:  MOVLB  0
2380:  RETURN 0
2382:  TBLRD*+
2384:  MOVF   FF5,F
2386:  BZ    23A2
2388:  MOVFF  FF6,1B5
238C:  MOVFF  FF7,1B6
2390:  MOVFF  FF5,1D3
2394:  CALL   1A56
2398:  MOVFF  1B5,FF6
239C:  MOVFF  1B6,FF7
23A0:  BRA    2382
23A2:  GOTO   2982 (RETURN)
23A6:  MOVLB  1
23A8:  MOVF   xD3,W
23AA:  SUBLW  B6
23AC:  MOVWF  xD3
23AE:  CLRF   03
23B0:  MOVFF  1D4,1D7
23B4:  BSF    xD4.7
23B6:  BCF    FD8.0
23B8:  RRCF   xD4,F
23BA:  RRCF   xD5,F
23BC:  RRCF   xD6,F
23BE:  RRCF   03,F
23C0:  RRCF   02,F
23C2:  RRCF   01,F
23C4:  RRCF   00,F
23C6:  DECFSZ xD3,F
23C8:  BRA    23B6
23CA:  BTFSS  xD7.7
23CC:  BRA    23E4
23CE:  COMF   00,F
23D0:  COMF   01,F
23D2:  COMF   02,F
23D4:  COMF   03,F
23D6:  INCF   00,F
23D8:  BTFSC  FD8.2
23DA:  INCF   01,F
23DC:  BTFSC  FD8.2
23DE:  INCF   02,F
23E0:  BTFSC  FD8.2
23E2:  INCF   03,F
23E4:  MOVLB  0
23E6:  GOTO   24D4 (RETURN)
23EA:  BTFSC  FD8.1
23EC:  BRA    23F6
23EE:  MOVLW  01
23F0:  MOVWF  FEA
23F2:  MOVLW  DB
23F4:  MOVWF  FE9
23F6:  CLRF   00
23F8:  CLRF   01
23FA:  CLRF   02
23FC:  CLRF   03
23FE:  MOVLB  1
2400:  CLRF   xDB
2402:  CLRF   xDC
2404:  CLRF   xDD
2406:  CLRF   xDE
2408:  MOVF   xDA,W
240A:  IORWF  xD9,W
240C:  IORWF  xD8,W
240E:  IORWF  xD7,W
2410:  BZ    246A
2412:  MOVLW  20
2414:  MOVWF  xDF
2416:  BCF    FD8.0
2418:  RLCF   xD3,F
241A:  RLCF   xD4,F
241C:  RLCF   xD5,F
241E:  RLCF   xD6,F
2420:  RLCF   xDB,F
2422:  RLCF   xDC,F
2424:  RLCF   xDD,F
2426:  RLCF   xDE,F
2428:  MOVF   xDA,W
242A:  SUBWF  xDE,W
242C:  BNZ   243E
242E:  MOVF   xD9,W
2430:  SUBWF  xDD,W
2432:  BNZ   243E
2434:  MOVF   xD8,W
2436:  SUBWF  xDC,W
2438:  BNZ   243E
243A:  MOVF   xD7,W
243C:  SUBWF  xDB,W
243E:  BNC   245E
2440:  MOVF   xD7,W
2442:  SUBWF  xDB,F
2444:  MOVF   xD8,W
2446:  BTFSS  FD8.0
2448:  INCFSZ xD8,W
244A:  SUBWF  xDC,F
244C:  MOVF   xD9,W
244E:  BTFSS  FD8.0
2450:  INCFSZ xD9,W
2452:  SUBWF  xDD,F
2454:  MOVF   xDA,W
2456:  BTFSS  FD8.0
2458:  INCFSZ xDA,W
245A:  SUBWF  xDE,F
245C:  BSF    FD8.0
245E:  RLCF   00,F
2460:  RLCF   01,F
2462:  RLCF   02,F
2464:  RLCF   03,F
2466:  DECFSZ xDF,F
2468:  BRA    2416
246A:  MOVFF  1DB,FEF
246E:  MOVFF  1DC,FEC
2472:  MOVFF  1DD,FEC
2476:  MOVFF  1DE,FEC
247A:  MOVLB  0
247C:  RETURN 0
247E:  MOVF   FE9,W
2480:  MOVLB  1
2482:  MOVWF  xCB
2484:  MOVF   xCA,W
2486:  MOVWF  xCD
2488:  BZ    24C0
248A:  MOVFF  1C9,1D6
248E:  MOVFF  1C8,1D5
2492:  MOVFF  1C7,1D4
2496:  MOVFF  1C6,1D3
249A:  CLRF   xDA
249C:  CLRF   xD9
249E:  MOVLW  20
24A0:  MOVWF  xD8
24A2:  MOVLW  82
24A4:  MOVWF  xD7
24A6:  MOVLB  0
24A8:  RCALL  1E3A
24AA:  MOVFF  03,1C9
24AE:  MOVFF  02,1C8
24B2:  MOVFF  01,1C7
24B6:  MOVFF  00,1C6
24BA:  MOVLB  1
24BC:  DECFSZ xCD,F
24BE:  BRA    248A
24C0:  MOVFF  1C9,1D6
24C4:  MOVFF  1C8,1D5
24C8:  MOVFF  1C7,1D4
24CC:  MOVFF  1C6,1D3
24D0:  MOVLB  0
24D2:  BRA    23A6
24D4:  MOVFF  03,1C9
24D8:  MOVFF  02,1C8
24DC:  MOVFF  01,1C7
24E0:  MOVFF  00,1C6
24E4:  MOVLB  1
24E6:  BTFSS  xC9.7
24E8:  BRA    2504
24EA:  DECF   xCB,F
24EC:  BSF    xCB.5
24EE:  COMF   xC6,F
24F0:  COMF   xC7,F
24F2:  COMF   xC8,F
24F4:  COMF   xC9,F
24F6:  INCF   xC6,F
24F8:  BTFSC  FD8.2
24FA:  INCF   xC7,F
24FC:  BTFSC  FD8.2
24FE:  INCF   xC8,F
2500:  BTFSC  FD8.2
2502:  INCF   xC9,F
2504:  MOVLW  3B
2506:  MOVWF  xD2
2508:  MOVLW  9A
250A:  MOVWF  xD1
250C:  MOVLW  CA
250E:  MOVWF  xD0
2510:  CLRF   xCF
2512:  MOVLW  0A
2514:  MOVWF  xCD
2516:  MOVF   xCA,W
2518:  BTFSC  FD8.2
251A:  INCF   xCB,F
251C:  BSF    FD8.1
251E:  MOVLW  01
2520:  MOVWF  FEA
2522:  MOVLW  C6
2524:  MOVWF  FE9
2526:  MOVFF  1C9,1D6
252A:  MOVFF  1C8,1D5
252E:  MOVFF  1C7,1D4
2532:  MOVFF  1C6,1D3
2536:  MOVFF  1D2,1DA
253A:  MOVFF  1D1,1D9
253E:  MOVFF  1D0,1D8
2542:  MOVFF  1CF,1D7
2546:  MOVLB  0
2548:  RCALL  23EA
254A:  MOVF   01,W
254C:  MOVF   00,F
254E:  BNZ   2576
2550:  MOVLB  1
2552:  INCF   xCA,W
2554:  SUBWF  xCD,W
2556:  BTFSS  FD8.2
2558:  BRA    255E
255A:  MOVLB  0
255C:  BRA    2576
255E:  MOVF   xCB,W
2560:  BZ    257C
2562:  ANDLW  0F
2564:  SUBWF  xCD,W
2566:  BZ    256A
2568:  BC    25F2
256A:  BTFSC  xCB.7
256C:  BRA    25F2
256E:  BTFSC  xCB.6
2570:  BRA    257C
2572:  MOVLW  20
2574:  BRA    25E4
2576:  MOVLW  20
2578:  MOVLB  1
257A:  ANDWF  xCB,F
257C:  BTFSS  xCB.5
257E:  BRA    259E
2580:  BCF    xCB.5
2582:  MOVF   xCA,W
2584:  BTFSS  FD8.2
2586:  DECF   xCB,F
2588:  MOVF   00,W
258A:  MOVWF  xCB
258C:  MOVLW  2D
258E:  MOVWF  xD3
2590:  MOVLB  0
2592:  CALL   1A56
2596:  MOVLB  1
2598:  MOVF   xCB,W
259A:  MOVWF  00
259C:  CLRF   xCB
259E:  MOVF   xCA,W
25A0:  SUBWF  xCD,W
25A2:  BNZ   25BE
25A4:  MOVF   00,W
25A6:  MOVWF  xCB
25A8:  MOVLW  2E
25AA:  MOVWF  xD3
25AC:  MOVLB  0
25AE:  CALL   1A56
25B2:  MOVLB  1
25B4:  MOVF   xCB,W
25B6:  MOVWF  00
25B8:  MOVLW  20
25BA:  ANDWF  xCB,F
25BC:  MOVLW  00
25BE:  MOVLW  30
25C0:  BTFSS  xCB.5
25C2:  BRA    25E4
25C4:  BCF    xCB.5
25C6:  MOVF   xCA,W
25C8:  BTFSS  FD8.2
25CA:  DECF   xCB,F
25CC:  MOVF   00,W
25CE:  MOVWF  xCB
25D0:  MOVLW  2D
25D2:  MOVWF  xD3
25D4:  MOVLB  0
25D6:  CALL   1A56
25DA:  MOVLB  1
25DC:  MOVF   xCB,W
25DE:  MOVWF  00
25E0:  CLRF   xCB
25E2:  MOVLW  30
25E4:  ADDWF  00,F
25E6:  MOVFF  00,1D3
25EA:  MOVLB  0
25EC:  CALL   1A56
25F0:  MOVLB  1
25F2:  BCF    FD8.1
25F4:  MOVFF  1D2,1D6
25F8:  MOVFF  1D1,1D5
25FC:  MOVFF  1D0,1D4
2600:  MOVFF  1CF,1D3
2604:  CLRF   xDA
2606:  CLRF   xD9
2608:  CLRF   xD8
260A:  MOVLW  0A
260C:  MOVWF  xD7
260E:  MOVLB  0
2610:  RCALL  23EA
2612:  MOVFF  03,1D2
2616:  MOVFF  02,1D1
261A:  MOVFF  01,1D0
261E:  MOVFF  00,1CF
2622:  MOVLB  1
2624:  DECFSZ xCD,F
2626:  BRA    251C
2628:  MOVLB  0
262A:  RETURN 0
*
2F04:  MOVLW  8E
2F06:  MOVWF  00
2F08:  MOVLB  1
2F0A:  MOVF   x94,W
2F0C:  SUBWF  00,F
2F0E:  MOVFF  195,02
2F12:  MOVFF  196,01
2F16:  BSF    02.7
2F18:  MOVF   00,F
2F1A:  BZ    2F2E
2F1C:  BCF    FD8.0
2F1E:  MOVF   02,F
2F20:  BNZ   2F26
2F22:  MOVF   01,F
2F24:  BZ    2F2E
2F26:  RRCF   02,F
2F28:  RRCF   01,F
2F2A:  DECFSZ 00,F
2F2C:  BRA    2F1C
2F2E:  BTFSS  x95.7
2F30:  BRA    2F3C
2F32:  COMF   01,F
2F34:  COMF   02,F
2F36:  INCF   01,F
2F38:  BTFSC  FD8.2
2F3A:  INCF   02,F
2F3C:  MOVLB  0
2F3E:  RETURN 0
*
374E:  ADDWF  FE8,W
3750:  CLRF   FF7
3752:  RLCF   FF7,F
3754:  ADDLW  69
3756:  MOVWF  FF6
3758:  MOVLW  37
375A:  ADDWFC FF7,F
375C:  TBLRD*-
375E:  MOVF   FF5,W
3760:  MOVWF  FFA
3762:  TBLRD*
3764:  MOVF   FF5,W
3766:  MOVWF  FF9
3768:  DATA 5E,36
376A:  DATA 82,36
376C:  DATA FE,36
376E:  DATA DA,36
3770:  DATA AA,36
3772:  DATA 22,37
.................... 
.................... #list
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
1B48:  MOVFF  1C7,1C9
1B4C:  MOVFF  1C6,1C8
1B50:  MOVFF  1C9,FEA
1B54:  MOVLB  1
1B56:  MOVFF  1C8,FE9
1B5A:  MOVF   FEF,F
1B5C:  BZ    1B6A
1B5E:  INCF   xC8,F
1B60:  BTFSC  FD8.2
1B62:  INCF   xC9,F
1B64:  MOVLB  0
1B66:  BRA    1B50
1B68:  MOVLB  1
....................    return(sc - s);
1B6A:  MOVF   xC6,W
1B6C:  SUBWF  xC8,W
1B6E:  MOVWF  00
1B70:  MOVF   xC7,W
1B72:  SUBWFB xC9,W
1B74:  MOVWF  03
1B76:  MOVFF  00,01
1B7A:  MOVWF  02
1B7C:  MOVLB  0
1B7E:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
2F40:  MOVLB  1
2F42:  BCF    x93.0
....................    y = x;
2F44:  MOVFF  187,18C
2F48:  MOVFF  186,18B
2F4C:  MOVFF  185,18A
2F50:  MOVFF  184,189
.................... 
....................    if (x < 0)
2F54:  MOVFF  187,1B8
2F58:  MOVFF  186,1B7
2F5C:  MOVFF  185,1B6
2F60:  MOVFF  184,1B5
2F64:  CLRF   xBC
2F66:  CLRF   xBB
2F68:  CLRF   xBA
2F6A:  CLRF   xB9
2F6C:  MOVLB  0
2F6E:  CALL   2308
2F72:  BNC   2F80
....................    {
....................       s = 1;
2F74:  MOVLB  1
2F76:  BSF    x93.0
....................       y = -y;
2F78:  MOVF   x8A,W
2F7A:  XORLW  80
2F7C:  MOVWF  x8A
2F7E:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
2F80:  MOVFF  18C,1B8
2F84:  MOVFF  18B,1B7
2F88:  MOVFF  18A,1B6
2F8C:  MOVFF  189,1B5
2F90:  MOVLB  1
2F92:  CLRF   xBC
2F94:  CLRF   xBB
2F96:  CLRF   xBA
2F98:  MOVLW  8E
2F9A:  MOVWF  xB9
2F9C:  MOVLB  0
2F9E:  CALL   2308
2FA2:  BC    2FA6
2FA4:  BNZ   2FD6
....................       res = (float32)(unsigned int16)y;
2FA6:  MOVFF  18C,197
2FAA:  MOVFF  18B,196
2FAE:  MOVFF  18A,195
2FB2:  MOVFF  189,194
2FB6:  RCALL  2F04
2FB8:  MOVFF  02,1C9
2FBC:  MOVFF  01,1C8
2FC0:  CALL   1E04
2FC4:  MOVFF  03,190
2FC8:  MOVFF  02,18F
2FCC:  MOVFF  01,18E
2FD0:  MOVFF  00,18D
2FD4:  BRA    3178
.................... 
....................  else if (y < 10000000.0)
2FD6:  MOVFF  18C,1B8
2FDA:  MOVFF  18B,1B7
2FDE:  MOVFF  18A,1B6
2FE2:  MOVFF  189,1B5
2FE6:  MOVLW  80
2FE8:  MOVLB  1
2FEA:  MOVWF  xBC
2FEC:  MOVLW  96
2FEE:  MOVWF  xBB
2FF0:  MOVLW  18
2FF2:  MOVWF  xBA
2FF4:  MOVLW  96
2FF6:  MOVWF  xB9
2FF8:  MOVLB  0
2FFA:  CALL   2308
2FFE:  BTFSS  FD8.0
3000:  BRA    3168
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
3002:  MOVFF  18C,1D6
3006:  MOVFF  18B,1D5
300A:  MOVFF  18A,1D4
300E:  MOVFF  189,1D3
3012:  MOVLB  1
3014:  CLRF   xDA
3016:  CLRF   xD9
3018:  CLRF   xD8
301A:  MOVLW  70
301C:  MOVWF  xD7
301E:  MOVLB  0
3020:  CALL   1E3A
3024:  MOVFF  03,197
3028:  MOVFF  02,196
302C:  MOVFF  01,195
3030:  MOVFF  00,194
3034:  RCALL  2F04
3036:  MOVFF  02,192
303A:  MOVFF  01,191
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
303E:  MOVFF  18C,1D6
3042:  MOVFF  18B,1D5
3046:  MOVFF  18A,1D4
304A:  MOVFF  189,1D3
304E:  MOVLB  1
3050:  CLRF   xDA
3052:  CLRF   xD9
3054:  CLRF   xD8
3056:  MOVLW  70
3058:  MOVWF  xD7
305A:  MOVLB  0
305C:  CALL   1E3A
3060:  MOVFF  03,197
3064:  MOVFF  02,196
3068:  MOVFF  01,195
306C:  MOVFF  00,194
3070:  MOVFF  192,1C9
3074:  MOVFF  191,1C8
3078:  CALL   1E04
307C:  BSF    FD8.1
307E:  MOVFF  197,1D1
3082:  MOVFF  196,1D0
3086:  MOVFF  195,1CF
308A:  MOVFF  194,1CE
308E:  MOVFF  03,1D5
3092:  MOVFF  02,1D4
3096:  MOVFF  01,1D3
309A:  MOVFF  00,1D2
309E:  CALL   2090
30A2:  MOVLB  1
30A4:  CLRF   xD6
30A6:  CLRF   xD5
30A8:  CLRF   xD4
30AA:  MOVLW  8E
30AC:  MOVWF  xD3
30AE:  MOVFF  03,1DA
30B2:  MOVFF  02,1D9
30B6:  MOVFF  01,1D8
30BA:  MOVFF  00,1D7
30BE:  MOVLB  0
30C0:  CALL   1E3A
30C4:  MOVFF  03,18C
30C8:  MOVFF  02,18B
30CC:  MOVFF  01,18A
30D0:  MOVFF  00,189
....................       res = 32768.0*(float32)l;
30D4:  MOVFF  192,1C9
30D8:  MOVFF  191,1C8
30DC:  CALL   1E04
30E0:  MOVLB  1
30E2:  CLRF   xD6
30E4:  CLRF   xD5
30E6:  CLRF   xD4
30E8:  MOVLW  8E
30EA:  MOVWF  xD3
30EC:  MOVFF  03,1DA
30F0:  MOVFF  02,1D9
30F4:  MOVFF  01,1D8
30F8:  MOVFF  00,1D7
30FC:  MOVLB  0
30FE:  CALL   1E3A
3102:  MOVFF  03,190
3106:  MOVFF  02,18F
310A:  MOVFF  01,18E
310E:  MOVFF  00,18D
....................       res += (float32)(unsigned int16)y;
3112:  MOVFF  18C,197
3116:  MOVFF  18B,196
311A:  MOVFF  18A,195
311E:  MOVFF  189,194
3122:  RCALL  2F04
3124:  MOVFF  02,1C9
3128:  MOVFF  01,1C8
312C:  CALL   1E04
3130:  BCF    FD8.1
3132:  MOVFF  190,1D1
3136:  MOVFF  18F,1D0
313A:  MOVFF  18E,1CF
313E:  MOVFF  18D,1CE
3142:  MOVFF  03,1D5
3146:  MOVFF  02,1D4
314A:  MOVFF  01,1D3
314E:  MOVFF  00,1D2
3152:  CALL   2090
3156:  MOVFF  03,190
315A:  MOVFF  02,18F
315E:  MOVFF  01,18E
3162:  MOVFF  00,18D
....................    }
3166:  BRA    3178
.................... 
....................  else
....................   res = y;
3168:  MOVFF  18C,190
316C:  MOVFF  18B,18F
3170:  MOVFF  18A,18E
3174:  MOVFF  189,18D
.................... 
....................  y = y - (float32)(unsigned int16)y;
3178:  MOVFF  18C,197
317C:  MOVFF  18B,196
3180:  MOVFF  18A,195
3184:  MOVFF  189,194
3188:  RCALL  2F04
318A:  MOVFF  02,1C9
318E:  MOVFF  01,1C8
3192:  CALL   1E04
3196:  BSF    FD8.1
3198:  MOVFF  18C,1D1
319C:  MOVFF  18B,1D0
31A0:  MOVFF  18A,1CF
31A4:  MOVFF  189,1CE
31A8:  MOVFF  03,1D5
31AC:  MOVFF  02,1D4
31B0:  MOVFF  01,1D3
31B4:  MOVFF  00,1D2
31B8:  CALL   2090
31BC:  MOVFF  03,18C
31C0:  MOVFF  02,18B
31C4:  MOVFF  01,18A
31C8:  MOVFF  00,189
.................... 
....................  if (s)
31CC:  MOVLB  1
31CE:  BTFSS  x93.0
31D0:  BRA    31D8
....................   res = -res;
31D2:  MOVF   x8E,W
31D4:  XORLW  80
31D6:  MOVWF  x8E
.................... 
....................  if (y != 0)
31D8:  MOVFF  18C,1B8
31DC:  MOVFF  18B,1B7
31E0:  MOVFF  18A,1B6
31E4:  MOVFF  189,1B5
31E8:  CLRF   xBC
31EA:  CLRF   xBB
31EC:  CLRF   xBA
31EE:  CLRF   xB9
31F0:  MOVLB  0
31F2:  CALL   2308
31F6:  BZ    3270
....................  {
....................   if (s == 1 && n == 0)
31F8:  MOVLB  1
31FA:  BTFSS  x93.0
31FC:  BRA    3236
31FE:  MOVF   x88,F
3200:  BNZ   3236
....................    res -= 1.0;
3202:  BSF    FD8.1
3204:  MOVFF  190,1D1
3208:  MOVFF  18F,1D0
320C:  MOVFF  18E,1CF
3210:  MOVFF  18D,1CE
3214:  CLRF   xD5
3216:  CLRF   xD4
3218:  CLRF   xD3
321A:  MOVLW  7F
321C:  MOVWF  xD2
321E:  MOVLB  0
3220:  CALL   2090
3224:  MOVFF  03,190
3228:  MOVFF  02,18F
322C:  MOVFF  01,18E
3230:  MOVFF  00,18D
3234:  MOVLB  1
.................... 
....................   if (s == 0 && n == 1)
3236:  BTFSC  x93.0
3238:  BRA    3272
323A:  DECFSZ x88,W
323C:  BRA    3272
....................    res += 1.0;
323E:  BCF    FD8.1
3240:  MOVFF  190,1D1
3244:  MOVFF  18F,1D0
3248:  MOVFF  18E,1CF
324C:  MOVFF  18D,1CE
3250:  CLRF   xD5
3252:  CLRF   xD4
3254:  CLRF   xD3
3256:  MOVLW  7F
3258:  MOVWF  xD2
325A:  MOVLB  0
325C:  CALL   2090
3260:  MOVFF  03,190
3264:  MOVFF  02,18F
3268:  MOVFF  01,18E
326C:  MOVFF  00,18D
3270:  MOVLB  1
....................  }
....................  if (x == 0)
3272:  MOVFF  187,1B8
3276:  MOVFF  186,1B7
327A:  MOVFF  185,1B6
327E:  MOVFF  184,1B5
3282:  CLRF   xBC
3284:  CLRF   xBB
3286:  CLRF   xBA
3288:  CLRF   xB9
328A:  MOVLB  0
328C:  CALL   2308
3290:  BNZ   329E
....................     res = 0;
3292:  MOVLB  1
3294:  CLRF   x90
3296:  CLRF   x8F
3298:  CLRF   x8E
329A:  CLRF   x8D
329C:  MOVLB  0
.................... 
....................  return (res);
329E:  MOVFF  18D,00
32A2:  MOVFF  18E,01
32A6:  MOVFF  18F,02
32AA:  MOVFF  190,03
32AE:  GOTO   32CA (RETURN)
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
32B2:  MOVFF  183,187
32B6:  MOVFF  182,186
32BA:  MOVFF  181,185
32BE:  MOVFF  180,184
32C2:  MOVLB  1
32C4:  CLRF   x88
32C6:  MOVLB  0
32C8:  BRA    2F40
32CA:  RETURN 0
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN,MCLR
.................... #use delay(clock=48000000)
*
116C:  MOVLW  01
116E:  MOVWF  FEA
1170:  MOVLW  C8
1172:  MOVWF  FE9
1174:  MOVF   FEF,W
1176:  BZ    1194
1178:  MOVLW  0F
117A:  MOVWF  01
117C:  CLRF   00
117E:  DECFSZ 00,F
1180:  BRA    117E
1182:  DECFSZ 01,F
1184:  BRA    117C
1186:  MOVLW  8F
1188:  MOVWF  00
118A:  DECFSZ 00,F
118C:  BRA    118A
118E:  NOP   
1190:  DECFSZ FEF,F
1192:  BRA    1178
1194:  RETURN 0
*
1A2E:  MOVLW  01
1A30:  MOVLB  1
1A32:  SUBWF  xA1,F
1A34:  BNC   1A50
1A36:  MOVLW  01
1A38:  MOVWF  FEA
1A3A:  MOVLW  A1
1A3C:  MOVWF  FE9
1A3E:  MOVF   FEF,W
1A40:  BZ    1A50
1A42:  MOVLW  02
1A44:  MOVWF  00
1A46:  DECFSZ 00,F
1A48:  BRA    1A46
1A4A:  BRA    1A4C
1A4C:  DECFSZ FEF,F
1A4E:  BRA    1A42
1A50:  MOVLB  0
1A52:  GOTO   1CEE (RETURN)
.................... 
.................... // In usb.c/h - tells the CCS PIC USB firmware to include HID handling code.
.................... #DEFINE USB_HID_DEVICE  TRUE
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP1 for IN bulk/interrupt transfers
.................... #define USB_EP1_TX_SIZE    64  //allocate 64 bytes in the hardware for transmission   
.................... 
.................... #define USB_EP1_RX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP1 for OUT bulk/interrupt transfers
.................... #define USB_EP1_RX_SIZE    64    // allocate 64 bytes in the hardware for reception   
.................... 
.................... #include <pic18_usb.h>            // Microchip 18Fxx5x hardware layer for usb.c
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.h                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////
.................... //// supported families are:                                         ////
.................... ////     PIC18F2455/2550/4455/4550                                   ////
.................... ////     PIC18F2450/4450                                             ////
.................... ////     PIC18F2458/2553/4458/4553                                   ////
.................... ////     PIC18F13K50/14K50                                           ////
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     ////
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////
.................... ////     PIC18FxxK50                                                 ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      ////
.................... //// that are specific to only this HW peripheral that you may       ////
.................... //// find useful to use in your application.                         ////
.................... ////                                                                 ////
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////
.................... ////  The HW actually supports more endpoints, but to simplify       ////
.................... ////  driver development this driver will only support the first 3   ////
.................... ////  so there is an easier memory block to work with.               ////
.................... ////                                                                 ////
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////
.................... ////  of USB speed, to save RAM.                                     ////
.................... ////                                                                 ////
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////
.................... ////  If you are not using internal pullups, you will need to put    ////
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    ////
.................... ////  want to use slow speed or full speed.  This code configures    ////
.................... ////  the device to use internal pullups, see usb_init() if you      ////
.................... ////  want to change that.                                           ////
.................... ////                                                                 ////
.................... ////  You need approximately 470nF cap on Vusb, even if you are      ////
.................... ////  using the internal 3.3V USB regulator.                         ////
.................... ////                                                                 ////
.................... ////  To run at full speed, you must use the oscillator              ////
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////
.................... ////  96MHz clock.  See the datasheet for details.                   ////
.................... ////                                                                 ////
.................... ////  To run at slow speed you must configure your MCU to run at     ////
.................... ////  24Mhz.  See the datasheet for details.                         ////
.................... ////                                                                 ////
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////
.................... //// this code enables interrupts.  A user modification can be made  ////
.................... //// to poll the USB interrupt flag instead of relying on an         ////
.................... //// interrupt.                                                      ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_H__
.................... #DEFINE __PIC18_USB_H__
.................... 
.................... #DEFINE __USB_HARDWARE__
.................... 
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral
.................... #DEFINE __PIC__   1
.................... 
.................... #ifndef USB_USE_FULL_SPEED
....................  #define USB_USE_FULL_SPEED   1
.................... #endif
.................... 
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................    //due to limited ram, force max packet length to 8 for this chip
....................    #define USB_MAX_EP0_PACKET_LENGTH   8
.................... #else
....................    #if USB_USE_FULL_SPEED==0
....................       //slow speed requires 8byte max packet size for endpoint 0
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8
....................    #else
....................       //for full speed you can still use 8bytes, but 64 will be faster
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64
....................    #endif
.................... #endif
.................... #endif
.................... 
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8))
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8
....................  #error Max Endpoint 0 length can't be less than 8!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64
....................  #error Max Endpoint 0 length can't be greater than 64!
.................... #endif
.................... 
.................... #include <usb_hw_layer.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_hw_layer.h                            ////
.................... ////                                                                   ////
.................... //// HW Layer for the USB Stack.                                       ////
.................... ////                                                                   ////
.................... //// HW drivers for the USB stack must support this API.               ////
.................... ////                                                                   ////
.................... //// The HW driver must also have a token handler that will call       ////
.................... //// usb_token_reset() when the device is init/reset, will call        ////
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          ////
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    ////
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     ////
.................... //// See usb.h for documentation of these functions.                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __USB_HW_LAYER_H__
.................... #define __USB_HW_LAYER_H__
.................... 
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0,
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4};
.................... 
.................... 
.................... // USER LEVEL FUNCTIONS:
.................... 
.................... /*****************************************************************************
.................... /* usb_init()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_init_cs()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_cs(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_task()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_task(void);
.................... 
.................... /******************************************************************************
.................... /* usb_attach()
.................... /*
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.
.................... /*
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt.
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_attach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_detach()
.................... /*
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.
.................... /*
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* If the user does call this function while USB is connected, the USB 
.................... /* peripheral will be disabled only momentarily because usb_task() will
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB
.................... /* reset of the device.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_detach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_put_packet()
.................... /*
.................... /* Input: endpoint - endpoint to send packet to (0..15).
.................... /*        ptr - points to data to send.
.................... /*        len - amount of data to send.
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, 
.................... /*                 or toggle from the last DATAx pid.
.................... /*
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only 
.................... /*         reason it will return FALSE is if because the TX buffer is still full 
.................... /*         from the last time it tried to send a packet.
.................... /*
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a 
.................... /*          difference between a packet and a message.  If you wanted to send a 
.................... /*          512 byte message on an endpoint that only supported 64 byte packets,
.................... /*          this would be accomplished this by sending 8 64-byte packets, 
.................... /*          followed by a 0 length packet.  If the last (or only packet) being 
.................... /*          sent is less than the max packet size defined in your descriptor 
.................... /*          then you do not need to send a 0 length packet to identify
.................... /*          an end of message.
.................... /*
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message 
.................... /*          correctly and know if a 0 lenght packet needs to be sent.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl);
.................... 
.................... /*******************************************************************************
.................... /* usb_get_packet(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer and saved to ptr.
.................... /*
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!
.................... /*
.................... /* Summary: Gets a packet of data from the USB endpoint buffer.
.................... /*          Until this is called, if there is data in the receive buffer the
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be
.................... /*          allowed to send a new packet.  Only receives one packet, if you need 
.................... /*          to receive multiple packets or handle 0-length terminator packets,
.................... /*          then use usb_gets().
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /********************************************************************************/
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max);
.................... 
.................... /****************************************************************************
.................... /* usb_kbhit(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check (0..15)
.................... /*
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not.
.................... /*
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers.
.................... /*          See API section of USB.H for more information.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_kbhit(unsigned int8 en);
.................... 
.................... /******************************************************************************
.................... /* usb_tbe(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last
.................... /*         transmit or if this endpoint is invalid.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_tbe(unsigned int8 en);
.................... 
.................... //////////////// END USER LEVEL FUNCTIONS /////////////////////////////////////
.................... 
.................... 
.................... ///
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by
.................... ///            the USB stack, and are not meant to be called by the 
.................... ///            user/application.
.................... ///
.................... 
.................... /*****************************************************************************
.................... /* usb_stall_ep()
.................... /*
.................... /* Input: endpoint - endpoint to stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will
.................... /*          send STALL packet if the host tries to access this endpoint's 
.................... /*          buffer.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_stall_ep(unsigned int8 endpoint);
.................... 
.................... 
.................... /*****************************************************************************
.................... /* usb_unstall_ep(endpoint, direction)
.................... /*
.................... /* Input: endpoint - endpoint to un-stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Un-stalls endpoint.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_unstall_ep(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_endpoint_stalled()
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.
.................... /*
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to
.................... /*          see if endpoint has been issued a STALL, just whether or not it is
.................... /*          configured to STALL on the next packet.  See Set_Feature and 
.................... /*          Clear_Feature Chapter 9 requests.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_set_address(address)
.................... /*
.................... /* Input: address - address the host specified that we use
.................... /*
.................... /* Summary: Configures the USB Peripheral for the specified device address.  
.................... /*          The host will now talk to use with the following address.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_address(unsigned int8 address);
.................... 
.................... /******************************************************************************
.................... /* usb_set_configured()
.................... /*
.................... /* Input: config - Configuration to use.  0 to uncofigure device.
.................... /*
.................... /* Summary: Configures or unconfigures device.  If configuring device it will
.................... /*          enable all the endpoints the user specified for this configuration.
.................... /*          If un-configuring device it will disable all endpoints.
.................... /*
.................... /*          NOTE: CCS only provides code to handle 1 configuration.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_configured(unsigned int8 config);
.................... 
.................... /******************************************************************************
.................... /* usb_disable_endpoints()
.................... /*
.................... /* Summary: Disables endpoints (all endpoints but 0)
.................... /*
.................... /*****************************************************************************/
.................... void usb_disable_endpoints(void);
.................... 
.................... 
.................... /*******************************************************************************
.................... /* usb_disable_endpoint()
.................... /*
.................... /* Input: Endpoint to disable (0..15)
.................... /*
.................... /* Summary: Disables specified endpoint
.................... /*
.................... /********************************************************************************/
.................... void usb_disable_endpoint(unsigned int8 en);
.................... 
.................... /**************************************************************
.................... /* usb_request_send_response(len)
.................... /* usb_request_get_data()
.................... /* usb_request_stall()
.................... /*
.................... /* Input: len - size of packet to send
.................... /*
.................... /* Summary: One of these 3 functions will be called by the USB stack after
.................... /*          handling a SETUP packet.
.................... /*          
.................... /*          After we process a SETUP request, we have 1 of three responses:
.................... /*            1.) send a response IN packet
.................... /*            2.) wait for followup OUT packet(s) with data
.................... /*            3.) stall because we don't support that SETUP request
.................... /*
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold
.................... /*          the response and the USB Request handler code will call
.................... /*          usb_request_send_response() to let us know how big the packet is.
.................... /*
.................... /*          If we are waiting for more data, usb_request_get_data() will
.................... /*          be called by the USB request handler code to configure the EP0 OUT
.................... /*          endpoint to be ready for more data
.................... /*
.................... /*          If we don't support a request, usb_request_stall() will be called
.................... /*          by the USB request handler code to stall the endpoint 0.
.................... /*
.................... /*          The operation of these functions depends on how SETUP packets
.................... /*          are handled in the hardware layer.
.................... /*
.................... /***************************************************************/
.................... void usb_request_send_response(unsigned int8 len);
.................... void usb_request_get_data(void);
.................... void usb_request_stall(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... //////////////////////// EXTRA USER FUNCTIONS /////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_flush_in()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for transfer
.................... /*        len - length of data that is being tramsferred
.................... /*        tgl - Data toggle synchronization for this packet
.................... /*
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)
.................... /*
.................... /* Summary: Marks the endpoint ready for transmission.  You must
.................... /*          have already loaded the endpoint buffer with data.
.................... /*          (IN is PIC -> PC).
.................... /*          This routine is useful if you want to setup an endpoint by
.................... /*          writing to the buffer directly.
.................... /*          This routine is not necessary if you use usb_put_packet().
.................... /***************************************************************/
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_flush_out()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for release
.................... /*        tgl - Data toggle synchronization to expect in the next packet
.................... /*
.................... /* Output: NONE
.................... /*
.................... /* Summary: Clears the previously received packet, and then marks this
.................... /*          endpoint's receive buffer as ready for more data.
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not
.................... /*          want to use usb_get_packet(), instead you want to handle with
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size().
.................... /*          This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_rx_packet_size()
.................... /*
.................... /* Input: endpoint - which endpoint to mark to check
.................... /*
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer.
.................... /*
.................... /* Summary: Read the number of data stored in the receive buffer.  When you
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint.
.................... /*    This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... int16 usb_rx_packet_size(int8 endpoint);
.................... 
.................... #ENDIF
.................... 
.................... #include "PIC18F2455_desc64.h"    // HID descriptor file
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///                      PIC18F2544_USBcounterDesc64.h                 ////
.................... ////                                                                   ////
.................... //// Device / configuration descriptors for USB 4 channel controller   ////
.................... //// based on CCS's HID Demo example (see ex_usb_hid.c)                ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// 01/01/07 version 1                                                ////
.................... //// PIC18Fxx5x initial release                                        ////
.................... //// 08/14/07 modified to transfer 6 bytes                             ////
.................... //// 06/24/08 modified to transfer 50 bytes
.................... //// 06/25/08 modified to transfer 54 bytes
.................... ///  07/27/09 modified to transfer 32 bytes, desc to "MPP SCANCARD"
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
.................... #DEFINE __USB_DESCRIPTORS__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
....................    //////////////////////////////////////////////////////////////////
....................    ///
....................    ///  HID Report.  Tells HID driver how to handle and deal with
....................    ///  received data.  HID Reports can be extremely complex,
....................    ///  see HID specifcation for help on writing your own.
....................    ///
....................    //////////////////////////////////////////////////////////////////
....................    const char USB_CLASS_SPECIFIC_DESC[] = {
....................       6, 0, 255,    // Usage Page = Vendor Defined
....................       9, 1,         // Usage = IO device
....................       0xa1, 1,      // Collection = Application
....................       0x19, 1,      // Usage minimum
....................       0x29, 8,      // Usage maximum
.................... 
....................       0x15, 0x80,   // Logical minimum (-128)
....................       0x25, 0x7F,   // Logical maximum (127)
.................... 
....................       0x75, 8,      // Report size = 8 (bits)
....................       0x95, 64,     // Report count =  64 bytes   
....................       0x81, 2,      // Input (Data, Var, Abs)
....................       0x19, 1,      // Usage minimum
....................       0x29, 8,      // Usage maximum
....................       0x75, 8,      // Report size = 8 (bits)
....................       0x95, 64,     // Report count = 64 bytes   
....................       0x91, 64,      // Output (Data, Var, Abs)
....................       0xc0          // End Collection
....................    };
.................... 
....................    //if a class has an extra descriptor not part of the config descriptor,
....................    // this lookup table defines where to look for it in the const
....................    // USB_CLASS_SPECIFIC_DESC[] array.
....................    //first element is the config number (if your device has more than one config)
....................    //second element is which interface number
....................    //set element to 0xFFFF if this config/interface combo doesn't exist
....................    const int16 USB_CLASS_SPECIFIC_DESC_LOOKUP[USB_NUM_CONFIGURATIONS][1] =
....................    {
....................    //config 1
....................       //interface 0
....................          0
....................    };
.................... 
....................    //if a class has an extra descriptor not part of the config descriptor,
....................    // this lookup table defines the size of that descriptor.
....................    //first element is the config number (if your device has more than one config)
....................    //second element is which interface number
....................    //set element to 0xFFFF if this config/interface combo doesn't exist
....................    const int16 USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[USB_NUM_CONFIGURATIONS][1] =
....................    {
....................    //config 1
....................       //interface 0
....................          32
....................    };
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start config descriptor
.................... ///   right now CCS only supports one configuration descriptor.
.................... ///   the config, interface, class, and endpoint goes into this array.
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    #DEFINE USB_TOTAL_CONFIG_LEN      41  //config+interface+class+endpoint+endpoint (2 endpoints)
.................... 
....................    const char USB_CONFIG_DESC[] = {
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE:
....................       //    config(s)
....................       //    interface(s)
....................       //    class(es)
....................       //    endpoint(s)
.................... 
....................    //config_descriptor for config index 1
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==1
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==2
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==3,4
....................          1, //number of interfaces this device supports       ==5
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==6
....................          0x00, //index of string descriptor for this configuration      ==7
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==8
....................          0x32, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)
.................... 
....................    //interface descriptor 1
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =10
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =11
....................          0x00, //number defining this interface (IF we had more than one interface)    ==12
....................          0x00, //alternate setting     ==13
....................          2, //number of endpoins, except 0 (pic167xx has 3, but we dont have to use all).       ==14
....................          0x03, //class code, 03 = HID     ==15
....................          0x00, //subclass code //boot     ==16
....................          0x00, //protocol code      ==17
....................          0x00, //index of string descriptor for interface      ==18
.................... 
....................    //class descriptor 1  (HID)
....................          USB_DESC_CLASS_LEN, //length of descriptor    ==19
....................          USB_DESC_CLASS_TYPE, //descriptor type (0x21 == HID)      ==20
....................          0x00,0x01, //hid class release number (1.0) (try 1.10)      ==21,22
....................          0x00, //localized country code (0 = none)       ==23
....................          0x01, //number of hid class descriptors that follow (1)      ==24
....................          0x22, //report descriptor type (0x22 == HID)                ==25
....................          USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][0], 0x00, //length of report descriptor   ==26,27
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==28
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==29
....................          0x81, //endpoint number and direction (0x81 = EP1 IN)       ==30
....................          0x03, //transfer type supported (0x03 is interrupt)         ==31
....................          USB_EP1_TX_SIZE,0x00, //maximum packet size supported                  ==32,33
....................          10,  //polling interval, in ms.  (cant be smaller than 10)      ==34
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==35
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==36
....................          0x01, //endpoint number and direction (0x01 = EP1 OUT)      ==37
....................          0x03, //transfer type supported (0x03 is interrupt)         ==38
....................          USB_EP1_RX_SIZE,0x00, //maximum packet size supported                  ==39,40
....................          10 //polling interval, in ms.  (cant be smaller than 10)    ==41
....................    };
.................... 
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find
....................    //  a specific descriptor in the above table.
.................... 
....................    //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL
....................    //      FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1
....................    #define USB_NUM_HID_INTERFACES   1
.................... 
....................    //the maximum number of interfaces seen on any config
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2
....................    #define USB_MAX_NUM_INTERFACES   1
.................... 
....................    //define how many interfaces there are per config.  [0] is the first config, etc.
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={1};
.................... 
....................    //define where to find class descriptors
....................    //first dimension is the config number
....................    //second dimension specifies which interface
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface
....................    //if a class descriptor is not valid, set the value to 0xFFFF
....................    const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][1][1]=
....................    {
....................    //config 1
....................       //interface 0
....................          //class 1
....................          18
....................    };
.................... 
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN)
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly
....................    #endif
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start device descriptors
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={
....................       //starts of with device configuration. only one possible
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==1
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==2
....................          0x10,0x01, //usb version in bcd (pic167xx is 1.1) ==3,4
....................          0x00, //class code ==5
....................          0x00, //subclass code ==6
....................          0x00, //protocol code ==7
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==8
....................          0x61,0x04, //vendor id (0x0461)
....................          0x04,0x00, //product id (0x0004 - see HID_device_configurations.docx)   ==11,12  // don't use ffff says usb-by-example guy. 
....................          0x00,0x01, //device release number  ==13,14
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==15
....................          0x02, //index of string descriptor of the product  ==16
....................          0x00, //index of string descriptor of serial number  ==17
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==18
....................    };
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start string descriptors
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone.
.................... ///
.................... ///   You must define the length else get_next_string_character() will not see the string
.................... ///   Current code only supports 10 strings (0 thru 9)
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc.
.................... char USB_STRING_DESC_OFFSET[]={0,4,12};
.................... 
.................... char const USB_STRING_DESC[]={
....................    //string 0 = S/N
....................          4, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          0x00,0x04,   //Microsoft Defined for US-English
....................    //string 1 = Manufacturer
....................          8, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'B',0,
....................          'M',0,
....................          'E',0,
....................    //string 2 = product name
....................          20, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'B',0,
....................          'M',0,
....................          'E',0,
....................          '-',0,
....................          '4',0,
....................          '3',0,
....................          '9',0,
....................          '0',0,
....................          ' ',0
....................         
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <usb.c>                  // handles usb setup tokens and get descriptor reports
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             usb.c                                 ////
.................... ////                                                                   ////
.................... //// Standard USB request and token handler code.                      ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... //// The majority of this code is called and used by the interrupt     ////
.................... //// generated by the hardware level, and therefore it is not meant    ////
.................... //// to be called by the user.  The functions that are meant to be     ////
.................... //// called by the user (init, put packet, get packet, etc) are        ////
.................... //// documented in USB.H.                                              ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////    This code will not create a multiple configuration device.     ////
.................... ////    If you wish to create a multiple configuration device then you ////
.................... ////    will have to modify these drivers.                             ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    ////
.................... ////   requests.  These requests are optional.  If you want to support ////
.................... ////   these requests you must provide the code yourself.  See         ////
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      ////
.................... ////   support.                                                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// If you wish to provide your own USB peripheral hardware layer, it ////
.................... //// must must provide the API as described in usb_hw_layer.h.         ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 20, 2015                                                    ////
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        ////
.................... ////                                                                   ////
.................... //// Feb 6th, 2015                                                     ////
.................... ////     Fixed 'len' not being intiailized in usb_gets()               ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// June 8th, 2011:                                                   ////
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  ////
.................... ////     (for no timeout) resolved.                                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// November 13th, 2009:                                              ////
.................... ////  usb_endpoint_is_valid() has an extra check.                      ////
.................... ////                                                                   ////
.................... //// June 9th, 2009:                                                   ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// Dec 14, 2007:                                                     ////
.................... ////  usb_kbhit() moved to device driver.                              ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    ////
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release.                                         ////
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     ////
.................... ////    layer.                                                         ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////  TODO: alot of indexing and length handling for descriptors is    ////
.................... ////   only 8bit, so make sure all descriptor tables are less than     ////
.................... ////   256 bytes long.                                                 ////
.................... ////                                                                   ////
.................... //// Apr 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     ////
.................... ////   usb_ep_tx_size[] defined in usb.h                               ////
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             ////
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  ////
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     ////
.................... ////   the endpoint buffer until you usb_get_packet(), which will      ////
.................... ////   then free the endpoint buffer for more data.  This affects      ////
.................... ////   routines such as usb_gets() and usb_kbhit().                    ////
.................... ////  usb_gets() no longer reads buffered data (see above note),       ////
.................... ////   now it reads multiple packets in the same way usb_puts()        ////
.................... ////   writes multiple packets                                         ////
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  ////
.................... ////   layer.                                                          ////
.................... ////                                                                   ////
.................... //// Nov 11th, 2004:                                                   ////
.................... ////  No longer includes wrong descriptor header.                      ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   ////
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    ////
.................... ////                     although it didn't cause any serious problems ////
.................... ////                                                                   ////
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  ////
.................... ////                     problems with multiple packet messages        ////
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   ////
.................... ////                     descriptors that require a 0 len packet to    ////
.................... ////                     end message.                                  ////
.................... ////                                                                   ////
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DRIVER__
.................... #DEFINE __USB_DRIVER__
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #else
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) 
....................    {
....................       while(len--)
....................       {
....................          debug_usb_packet(debug_putc, "%02X", *ptr++);
....................       }
....................    }
.................... #endif
.................... 
.................... // legacy
.................... #ifndef debug_usb
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l)
.................... #endif
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if defined(__PIC16F_USB_H__)
....................  #include <pic16f_usb.c>
.................... #endif
.................... 
.................... #if defined(__PIC18_USB_H__)
....................  #include <pic18_usb.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.c                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     ////
.................... //// documentation about the PIC18 hardware layer.                   ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Dec 12, 2016:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Mar 20, 2015:                                                   ////
.................... ////  When TXing a packet, set UOWN bit as a different instruction   ////
.................... ////     as the rest of the BDSTAT flags.  Doing it this way         ////
.................... ////     prevents PIC18F45K50 family USB from locking up.            ////
.................... ////                                                                 ////
.................... //// Mar 1, 2015:                                                    ////
.................... ////  Added __STALL_ON_UEP_ERRATA__ and __UIDLE_JAM_ERRATA__ from    ////
.................... ////     PIC24 USB library, in case those erratas found              ////
.................... ////     their way on the PIC18 USB parts.                           ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added 18FxxJ9x family support.                                 ////
.................... ////                                                                 ////
.................... //// Dec 11, 2013:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// July 9th, 2012:                                                 ////
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     ////
.................... ////     for non-setup packets on endpoint 0 or all other            ////
.................... ////     endpoints.  This really only affects people using           ////
.................... ////     usb_put_packet() or usb_get_packet() inside of other        ////
.................... ////     interrupts.                                                 ////
.................... ////                                                                 ////
.................... //// Sep 22, 2011:                                                   ////
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   ////
.................... ////     primarily developed for users developing code where         ////
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work.                          ////
.................... ////                                                                 ////
.................... //// Nov 13th, 2009:                                                 ////
.................... ////  usb_disable_endpoint() won't touch BD status registers for     ////
.................... ////     endpoints that aren't allocated.                            ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_C__
.................... #DEFINE __PIC18_USB_C__
.................... 
.................... // i got these from PIC24 library, but maybe these bugs made their way
.................... // into PIC18 usb peripherals.
.................... // __STALL_ON_UEP_ERRATA__ looked wrong on the PIC24 library.
.................... #define __STALL_ON_UEP_ERRATA__
.................... #define __UIDLE_JAM_ERRATA__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #endif
.................... 
.................... #bit USBIE=getenv("BIT:USBIE")
.................... 
.................... //if you are worried that the PIC is not receiving packets because a bug in the
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on
.................... //receiving.
.................... #ifndef USB_IGNORE_RX_DTS
....................  #define USB_IGNORE_RX_DTS false
.................... #endif
.................... 
.................... #ifndef USB_IGNORE_TX_DTS
....................  #define USB_IGNORE_TX_DTS false
.................... #endif
.................... 
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM
.................... //    but endpoint memory can be anywhere on the PIC.
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed
.................... //    location in RAM (BDT first, endpoint second).
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed
.................... //    location in RAM and the endpoint buffers have a different location
.................... //    in RAM.
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))
....................  #define __USB_87J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \
....................        (getenv("DEVICE")=="PIC18F24K50") || \
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF24K50"))
....................  #define __USB_45K50__
....................  #define USB_TOTAL_RAM_SPACE  1024
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50"))
....................  #define __USB_46J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || \
....................        (getenv("DEVICE")=="PIC18LF2450") || (getenv("DEVICE")=="PIC18LF4450"))
....................  #define __USB_4450__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................  #define __USB_K50__ //backwards compatability
....................  #define __USB_14K50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x200
....................  #define USB_NUM_UEP 8
....................  //technically this device supports 8 endpoints, but for RAM reasons you should
....................  //attempt to only use the first 3 endpoints.
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") || \
....................        (getenv("DEVICE")=="PIC18LF2455") || (getenv("DEVICE")=="PIC18LF2550") || \
....................        (getenv("DEVICE")=="PIC18LF4455") || (getenv("DEVICE")=="PIC18LF4550") || \
....................        (getenv("DEVICE")=="PIC18LF2458") || (getenv("DEVICE")=="PIC18LF2553") || \
....................        (getenv("DEVICE")=="PIC18LF4458") || (getenv("DEVICE")=="PIC18LF4553") \
....................        )
....................  #define __USB_4550__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \       
....................        )
....................  #define __USB_18FJ53__
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use
....................  #define USB_BDT_START  0xD00
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \
....................        (getenv("DEVICE")=="PIC18F65J94"))
....................  #define __USB_18FJ94__
....................  #define USB_BDT_START  0x100
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library.
.................... #endif
.................... 
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  15
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  14
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  13
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  12
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  11
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  10
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  9
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  8
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  7
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  6
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  5
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  4
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  3
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  2
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  1
.................... #else
....................  #define USB_LAST_DEFINED_ENDPOINT  0
.................... #endif
.................... 
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8)
.................... 
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)
.................... 
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT)
....................  #error You are trying to use an invalid endpoint for this hardware!
.................... #endif
.................... 
.................... typedef struct
.................... {
....................    unsigned int8 stat;
....................    unsigned int8 cnt;
....................    unsigned int16 addr;
.................... } STRUCT_BD;
.................... 
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START)
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       struct
....................       {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1];
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer)
....................    
....................    #locate g_USBRAM=USB_RAM_START
....................    
....................    #define g_USBBDT g_USBRAM.bd
.................... #else
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #if defined(USB_RAM_START)
....................       #locate g_USBRAM=USB_RAM_START
....................    #endif
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM)
....................    
....................    struct
....................    {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1];
....................    
....................    #locate g_USBBDT=USB_BDT_START
.................... #endif
.................... 
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer
.................... 
.................... //these buffer definitions needed for CDC library
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer
.................... 
.................... //if you enable this it will keep a counter of the 6 possible errors the
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.
.................... #if !defined(USB_USE_ERROR_COUNTER)
....................    #define USB_USE_ERROR_COUNTER false
.................... #endif
.................... 
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints
.................... 
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!
.................... #if !defined(USB_PING_PONG_MODE)
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF
.................... #endif
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................    unsigned int ERROR_COUNTER[6];
.................... #endif
.................... 
.................... //---pic18fxx5x memory locations
.................... #if defined(__USB_4550__) || defined(__USB_4450__)
....................    #byte UFRML   =  0xF66
....................    #byte UFRMH   =  0xF67
....................    #byte UIR     =  0xF68
....................    #byte UIE     =  0xF69
....................    #byte UEIR    =  0xF6A
....................    #byte UEIE    =  0xF6B
....................    #byte U1STAT   =  0xF6C
....................    #byte UCON    =  0xF6D
....................    #byte UADDR   =  0xF6E
....................    #byte UCFG    =  0xF6F
....................    #define  UEP0_LOC 0xF70
.................... #elif defined(__USB_46J50__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #elif defined(__USB_14K50__)
....................    #byte UFRML   =  0xF5D
....................    #byte UFRMH   =  0xF5E
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF60
....................    #byte UEIR    =  0xF5F
....................    #byte UEIE    =  0xF5B
....................    #byte U1STAT   =  0xF63
....................    #byte UCON    =  0xF64
....................    #byte UADDR   =  0xF5C
....................    #byte UCFG    =  0xF61
....................    #define  UEP0_LOC 0xF53
.................... #elif defined(__USB_18FJ53__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #else
....................    #byte UFRML = getenv("SFR:UFRML")
....................    #byte UFRMH = getenv("SFR:UFRMH")
....................    #byte UIR = getenv("SFR:UIR")
....................    #byte UIE = getenv("SFR:UIE")
....................    #byte UEIR = getenv("SFR:UEIR")
....................    #byte UEIE = getenv("SFR:UEIE")
....................    #byte U1STAT = getenv("SFR:USTAT")
....................    #byte UCON = getenv("SFR:UCON")
....................    #byte UADDR = getenv("SFR:UADDR")
....................    #byte UCFG = getenv("SFR:UCFG")
.................... #endif
.................... 
.................... unsigned int8 USTATCopy;
.................... 
.................... unsigned int8 g_UEP[USB_NUM_UEP];
.................... #if defined(UEP0_LOC)
.................... #locate g_UEP=UEP0_LOC
.................... #else
.................... #locate g_UEP=getenv("SFR:UEP0")
.................... #endif
.................... #define UEP(x) g_UEP[x]
.................... 
.................... #define BIT_SOF   6
.................... #define BIT_STALL 5
.................... #define BIT_IDLE  4
.................... #define BIT_TRN   3
.................... #define BIT_ACTV  2
.................... #define BIT_UERR  1
.................... #define BIT_URST  0
.................... 
.................... #BIT UIR_SOF = UIR.BIT_SOF
.................... #BIT UIR_STALL = UIR.BIT_STALL
.................... #BIT UIR_IDLE = UIR.BIT_IDLE
.................... #BIT UIR_TRN = UIR.BIT_TRN
.................... #BIT UIR_ACTV = UIR.BIT_ACTV
.................... #BIT UIR_UERR = UIR.BIT_UERR
.................... #BIT UIR_URST = UIR.BIT_URST
.................... 
.................... #BIT UIE_SOF = UIE.BIT_SOF
.................... #BIT UIE_STALL = UIE.BIT_STALL
.................... #BIT UIE_IDLE = UIE.BIT_IDLE
.................... #BIT UIE_TRN = UIE.BIT_TRN
.................... #BIT UIE_ACTV = UIE.BIT_ACTV
.................... #BIT UIE_UERR = UIE.BIT_UERR
.................... #BIT UIE_URST = UIE.BIT_URST
.................... 
.................... #if getenv("BIT_VALID:PPBRST")
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST")
.................... #endif
.................... #bit UCON_SE0=UCON.5
.................... #bit UCON_PKTDIS=UCON.4
.................... #bit UCON_USBEN=UCON.3
.................... #bit UCON_RESUME=UCON.2
.................... #bit UCON_SUSPND=UCON.1
.................... 
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr
.................... #else
.................... #error Right now this driver only supports no ping pong
.................... #endif
.................... 
.................... //See UEPn (0xF70-0xF7F)
.................... #define ENDPT_DISABLED   0x00   //endpoint not used
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions
.................... 
.................... //Define the states that the USB interface can be in
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3,
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state;
.................... 
.................... //--BDendST has their PIDs upshifed 2
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction
.................... 
.................... #define USTAT_IN_E0        4
.................... #define USTAT_OUT_SETUP_E0 0
.................... 
.................... #define __USB_UIF_RESET    0x01
.................... #define __USB_UIF_ERROR    0x02
.................... #define __USB_UIF_ACTIVE   0x04
.................... #define __USB_UIF_TOKEN    0x08
.................... #define __USB_UIF_IDLE     0x10
.................... #define __USB_UIF_STALL    0x20
.................... #define __USB_UIF_SOF      0x40
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET
.................... #else
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET
.................... #endif
.................... 
.................... #define __USB_UCFG_UTEYE   0x80
.................... #if defined(__USB_4550__)
....................  #define __USB_UCFG_UOEMON  0x40
.................... #endif
.................... #define __USB_UCFG_UPUEN   0x10
.................... #if !defined(__USB_14K50__)
....................  #define __USB_UCFG_UTRDIS  0x08
.................... #endif
.................... #define __USB_UCFG_FSEN    0x04
.................... 
.................... #if defined(USB_EXTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  0
.................... #endif
.................... 
.................... #if defined(USB_INTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if !defined(__USB_UCFG_MY_UPUEN)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if USB_USE_FULL_SPEED
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)
.................... #else
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE);
.................... #endif
.................... 
.................... #if defined(__USB_UCFG_UTRDIS)
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS
.................... #else
....................  #define __UCFG_VAL_DISABLED__   0
.................... #endif
.................... 
.................... 
.................... unsigned int8 __setup_0_tx_size;
.................... 
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only
.................... void usb_handle_interrupt();
.................... void usb_isr_rst();
.................... void usb_isr_uerr();
.................... void usb_isr_sof(void);
.................... void usb_isr_activity();
.................... void usb_isr_uidle();
.................... void usb_isr_tok_dne();
.................... void usb_isr_stall(void);
.................... void usb_init_ep0_setup(void);
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... void usb_isr(void);
.................... #endif
.................... 
.................... //// BEGIN User Functions:
.................... 
.................... // see usb_hw_layer.h for more documentation
.................... int1 usb_kbhit(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7)));
*
13DA:  CLRF   03
13DC:  MOVLB  1
13DE:  MOVF   x8C,W
13E0:  ADDLW  70
13E2:  MOVWF  FE9
13E4:  MOVLW  0F
13E6:  ADDWFC 03,W
13E8:  MOVWF  FEA
13EA:  MOVF   FEF,F
13EC:  BZ    1428
13EE:  CLRF   19
13F0:  BTFSC  FF2.7
13F2:  BSF    19.7
13F4:  BCF    FF2.7
13F6:  CLRF   xEE
13F8:  MOVFF  18C,1ED
13FC:  CLRF   xF0
13FE:  MOVLW  08
1400:  MOVWF  xEF
1402:  MOVLB  0
1404:  CALL   02B6
1408:  BTFSC  19.7
140A:  BSF    FF2.7
140C:  MOVFF  02,18E
1410:  MOVFF  01,18D
1414:  MOVLB  1
1416:  MOVFF  01,FE9
141A:  MOVLW  04
141C:  ADDWF  02,W
141E:  MOVWF  FEA
1420:  MOVFF  FEF,18F
1424:  BTFSS  x8F.7
1426:  BRA    142C
1428:  MOVLW  00
142A:  BRA    142E
142C:  MOVLW  01
142E:  MOVWF  01
1430:  MOVLB  0
1432:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_tbe(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7)));
*
0BF4:  CLRF   03
0BF6:  MOVLB  1
0BF8:  MOVF   xE8,W
0BFA:  ADDLW  70
0BFC:  MOVWF  FE9
0BFE:  MOVLW  0F
0C00:  ADDWFC 03,W
0C02:  MOVWF  FEA
0C04:  MOVF   FEF,F
0C06:  BZ    0C3E
0C08:  CLRF   xEE
0C0A:  MOVFF  1E8,1ED
0C0E:  CLRF   xF0
0C10:  MOVLW  08
0C12:  MOVWF  xEF
0C14:  MOVLB  0
0C16:  CALL   02B6
0C1A:  MOVFF  02,1EA
0C1E:  MOVFF  01,1E9
0C22:  MOVLW  04
0C24:  MOVLB  1
0C26:  ADDWF  xE9,F
0C28:  MOVLW  00
0C2A:  ADDWFC xEA,F
0C2C:  MOVFF  1E9,FE9
0C30:  MOVLW  04
0C32:  ADDWF  xEA,W
0C34:  MOVWF  FEA
0C36:  MOVFF  FEF,1EB
0C3A:  BTFSS  xEB.7
0C3C:  BRA    0C42
0C3E:  MOVLW  00
0C40:  BRA    0C44
0C42:  MOVLW  01
0C44:  MOVWF  01
0C46:  MOVLB  0
0C48:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_detach(void)
.................... {
....................    UCON_SUSPND = 0;
*
10DC:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware
10DE:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts
10E0:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;
10E2:  MOVLW  08
10E4:  MOVWF  F6F
.................... 
....................    // set D+/D- to inputs
....................   #if defined(__USB_87J50__)
....................    set_tris_f(get_tris_f() | 0x18);
....................   #elif defined(__USB_14K50__)
....................    set_tris_a(get_tris_a() | 0x3);
....................   #elif defined(__USB_18FJ94__)
....................    output_float(PIN_F4);
....................    output_float(PIN_F3);
....................   #elif !defined(USB_PIC_NO_USB_GPIO)
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5
10E6:  MOVF   F94,W
10E8:  IORLW  30
10EA:  MOVLB  1
10EC:  MOVWF  F94
....................   #endif
....................   
....................    usb_state = USB_STATE_DETACHED;
10EE:  CLRF   28
10F0:  CLRF   19
10F2:  BTFSC  FF2.7
10F4:  BSF    19.7
10F6:  BCF    FF2.7
....................    
....................    usb_token_reset();              //clear the chapter9 stack
10F8:  MOVLB  0
10FA:  CALL   0366
10FE:  BTFSC  19.7
1100:  BSF    FF2.7
1102:  GOTO   1108 (RETURN)
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_attach(void) 
*
110C:  CLRF   19
110E:  BTFSC  FF2.7
1110:  BSF    19.7
1112:  BCF    FF2.7
.................... {
....................    usb_token_reset();
1114:  CALL   0366
1118:  BTFSC  19.7
111A:  BSF    FF2.7
....................    UCON_SUSPND = 0;
111C:  BCF    F6D.1
....................    UCON = 0;
111E:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST")
....................    UCON_PPBRST = 1;
1120:  BSF    F6D.6
....................    delay_cycles(5);
1122:  BRA    1124
1124:  BRA    1126
1126:  NOP   
....................    UCON_PPBRST = 0;
1128:  BCF    F6D.6
....................   #endif
....................    UCFG = __UCFG_VAL_ENABLED__;
112A:  MOVLW  14
112C:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts
112E:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus
1130:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h
1132:  MOVLW  01
1134:  MOVWF  28
1136:  GOTO   1140 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init_cs(void)
.................... {
....................    usb_detach();
*
1106:  BRA    10DC
1108:  GOTO   1160 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_task(void) 
.................... {
....................   #if defined(USB_ISR_POLLING)
....................    if (interrupt_active(INT_USB))
....................    {
....................       usb_isr();
....................    }
....................   #endif
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_enumerated())
....................    {
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    if (usb_attached()) 
....................    {
....................       if (UCON_USBEN==0) 
*
113A:  BTFSC  F6D.3
113C:  BRA    1140
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: ATTACH");
....................          usb_attach();
113E:  BRA    110C
....................       }
....................    }
....................    else 
....................    {
....................       if (UCON_USBEN==1)  
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");
....................          usb_detach();
....................       }
....................    }
.................... 
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
1140:  DECFSZ 28,W
1142:  BRA    115A
1144:  BTFSC  F6D.5
1146:  BRA    115A
....................    {
....................       UIR = 0;
1148:  CLRF   F68
....................       UIE = 0;
114A:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING)
....................       enable_interrupts(INT_USB);
114C:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);
114E:  MOVLW  C0
1150:  IORWF  FF2,F
....................      #endif
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR
1152:  MOVLW  11
1154:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER
....................       UIE |= __USB_UIF_ERROR;
....................      #endif
....................       usb_state=USB_STATE_POWERED;
1156:  MOVLW  02
1158:  MOVWF  28
....................       debug_usb_control(debug_putc, "\r\n\nUSB TASK: POWERED");
....................    }
115A:  GOTO   1162 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init(void) 
.................... {
....................    usb_init_cs();
115E:  BRA    1106
.................... 
....................    do 
....................    {
....................       usb_task();
1160:  BRA    113A
....................    } while (usb_state != USB_STATE_POWERED);
1162:  MOVF   28,W
1164:  SUBLW  02
1166:  BNZ   1160
1168:  GOTO   380C (RETURN)
.................... }
.................... 
.................... 
.................... // see pic18_usb.h for documentation
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
.................... 
....................    debug_usb_packet(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);
.................... 
....................    if (usb_tbe(endpoint)) 
*
0C4A:  MOVFF  1E3,1E8
0C4E:  RCALL  0BF4
0C50:  MOVF   01,F
0C52:  BTFSC  FD8.2
0C54:  BRA    0D8C
....................    {
....................       EP_BDxCNT_I(endpoint)=len;
0C56:  MOVLB  1
0C58:  CLRF   xEE
0C5A:  MOVFF  1E3,1ED
0C5E:  CLRF   xF0
0C60:  MOVLW  08
0C62:  MOVWF  xEF
0C64:  MOVLB  0
0C66:  CALL   02B6
0C6A:  MOVFF  02,1E9
0C6E:  MOVFF  01,1E8
0C72:  MOVLW  04
0C74:  MOVLB  1
0C76:  ADDWF  xE8,F
0C78:  MOVLW  00
0C7A:  ADDWFC xE9,F
0C7C:  MOVLW  01
0C7E:  ADDWF  xE8,W
0C80:  MOVWF  01
0C82:  MOVLW  00
0C84:  ADDWFC xE9,W
0C86:  MOVWF  03
0C88:  MOVFF  01,FE9
0C8C:  MOVLW  04
0C8E:  ADDWF  03,W
0C90:  MOVWF  FEA
0C92:  MOVFF  1E4,FEF
.................... 
....................       debug_display_ram(len, EP_BDxADR_I(endpoint));
.................... 
....................      #if USB_IGNORE_TX_DTS
....................       i=0x80;
....................      #else
....................       if (tgl == USB_DTS_TOGGLE) 
0C96:  MOVF   xE6,W
0C98:  SUBLW  02
0C9A:  BNZ   0CDC
....................       {
....................          i = EP_BDxST_I(endpoint);
0C9C:  CLRF   xEE
0C9E:  MOVFF  1E3,1ED
0CA2:  CLRF   xF0
0CA4:  MOVLW  08
0CA6:  MOVWF  xEF
0CA8:  MOVLB  0
0CAA:  CALL   02B6
0CAE:  MOVFF  02,1E9
0CB2:  MOVFF  01,1E8
0CB6:  MOVLW  04
0CB8:  MOVLB  1
0CBA:  ADDWF  xE8,F
0CBC:  MOVLW  00
0CBE:  ADDWFC xE9,F
0CC0:  MOVFF  1E8,FE9
0CC4:  MOVLW  04
0CC6:  ADDWF  xE9,W
0CC8:  MOVWF  FEA
0CCA:  MOVFF  FEF,1E7
....................          if (bit_test(i,6))
0CCE:  BTFSS  xE7.6
0CD0:  BRA    0CD6
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0CD2:  CLRF   xE6
0CD4:  BRA    0CDA
....................          else
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0CD6:  MOVLW  01
0CD8:  MOVWF  xE6
....................       }
0CDA:  BRA    0D10
....................       else if (tgl == USB_DTS_USERX) 
0CDC:  MOVF   xE6,W
0CDE:  SUBLW  04
0CE0:  BNZ   0D10
....................       {
....................          i = EP_BDxST_O(endpoint);
0CE2:  CLRF   xEE
0CE4:  MOVFF  1E3,1ED
0CE8:  CLRF   xF0
0CEA:  MOVLW  08
0CEC:  MOVWF  xEF
0CEE:  MOVLB  0
0CF0:  CALL   02B6
0CF4:  MOVLB  1
0CF6:  MOVFF  01,FE9
0CFA:  MOVLW  04
0CFC:  ADDWF  02,W
0CFE:  MOVWF  FEA
0D00:  MOVFF  FEF,1E7
....................          if (bit_test(i,6))
0D04:  BTFSS  xE7.6
0D06:  BRA    0D0E
....................             tgl = USB_DTS_DATA1;
0D08:  MOVLW  01
0D0A:  MOVWF  xE6
0D0C:  BRA    0D10
....................          else
....................             tgl = USB_DTS_DATA0;
0D0E:  CLRF   xE6
....................       }
....................       if (tgl == USB_DTS_DATA1) 
0D10:  DECFSZ xE6,W
0D12:  BRA    0D1A
....................          i=0x48;  //DATA1, UOWN  //change mar2015
0D14:  MOVLW  48
0D16:  MOVWF  xE7
0D18:  BRA    0D1E
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x08; //DATA0, UOWN   //change mar2015
0D1A:  MOVLW  08
0D1C:  MOVWF  xE7
....................      #endif
.................... 
....................       //set BC8 and BC9
....................       //if (bit_test(len,8)) {bit_set(i,0);}
....................       //if (bit_test(len,9)) {bit_set(i,1);}
.................... 
....................       debug_usb_packet(debug_putc, " %X", i);
.................... 
....................       EP_BDxST_I(endpoint) = i;  //save changes
0D1E:  CLRF   xEE
0D20:  MOVFF  1E3,1ED
0D24:  CLRF   xF0
0D26:  MOVLW  08
0D28:  MOVWF  xEF
0D2A:  MOVLB  0
0D2C:  CALL   02B6
0D30:  MOVFF  02,1E9
0D34:  MOVFF  01,1E8
0D38:  MOVLW  04
0D3A:  MOVLB  1
0D3C:  ADDWF  xE8,F
0D3E:  MOVLW  00
0D40:  ADDWFC xE9,F
0D42:  MOVFF  1E8,FE9
0D46:  MOVLW  04
0D48:  ADDWF  xE9,W
0D4A:  MOVWF  FEA
0D4C:  MOVFF  1E7,FEF
....................       
....................       EP_BDxST_I(endpoint) |= 0x80; //change mar2015
0D50:  CLRF   xEE
0D52:  MOVFF  1E3,1ED
0D56:  CLRF   xF0
0D58:  MOVLW  08
0D5A:  MOVWF  xEF
0D5C:  MOVLB  0
0D5E:  CALL   02B6
0D62:  MOVFF  02,1E9
0D66:  MOVFF  01,1E8
0D6A:  MOVLW  04
0D6C:  MOVLB  1
0D6E:  ADDWF  xE8,F
0D70:  MOVLW  00
0D72:  ADDWFC xE9,F
0D74:  MOVFF  1E8,FE9
0D78:  MOVLW  04
0D7A:  ADDWF  xE9,W
0D7C:  MOVWF  FEA
0D7E:  MOVF   FEF,W
0D80:  IORLW  80
0D82:  MOVWF  FEF
....................       
....................       //putc('!');
....................       
....................       return(1);
0D84:  MOVLW  01
0D86:  MOVWF  01
0D88:  BRA    0D92
....................    }
0D8A:  MOVLB  0
....................    else 
....................    {
....................       //putc('_');
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
....................    return(0);
0D8C:  MOVLW  00
0D8E:  MOVWF  01
0D90:  MOVLB  1
0D92:  MOVLB  0
0D94:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
*
16D2:  CLRF   19
16D4:  BTFSC  FF2.7
16D6:  BSF    19.7
16D8:  BCF    FF2.7
.................... {
....................    unsigned int8 * buff_add;    
.................... 
....................    if (usb_tbe(endpoint)) 
16DA:  MOVFF  18E,1E8
16DE:  CALL   0BF4
16E2:  BTFSC  19.7
16E4:  BSF    FF2.7
16E6:  MOVF   01,F
16E8:  BZ    1792
16EA:  CLRF   19
16EC:  BTFSC  FF2.7
16EE:  BSF    19.7
16F0:  BCF    FF2.7
....................    {
....................       buff_add = EP_BDxADR_I(endpoint);
16F2:  MOVLB  1
16F4:  CLRF   xEE
16F6:  MOVFF  18E,1ED
16FA:  CLRF   xF0
16FC:  MOVLW  08
16FE:  MOVWF  xEF
1700:  MOVLB  0
1702:  CALL   02B6
1706:  BTFSC  19.7
1708:  BSF    FF2.7
170A:  MOVFF  02,197
170E:  MOVFF  01,196
1712:  MOVLW  04
1714:  MOVLB  1
1716:  ADDWF  x96,F
1718:  MOVLW  00
171A:  ADDWFC x97,F
171C:  MOVLW  02
171E:  ADDWF  x96,W
1720:  MOVWF  01
1722:  MOVLW  00
1724:  ADDWFC x97,W
1726:  MOVWF  03
1728:  MOVFF  01,FE9
172C:  MOVLW  04
172E:  ADDWF  03,W
1730:  MOVWF  FEA
1732:  MOVFF  FEC,195
1736:  MOVF   FED,F
1738:  MOVFF  FEF,194
....................       memcpy(buff_add, ptr, len);     
173C:  MOVFF  195,FEA
1740:  MOVFF  194,FE9
1744:  MOVFF  190,FE2
1748:  MOVFF  18F,FE1
174C:  MOVFF  192,02
1750:  MOVFF  191,01
1754:  MOVF   01,F
1756:  BZ    175C
1758:  INCF   02,F
175A:  BRA    1760
175C:  MOVF   02,F
175E:  BZ    176C
1760:  MOVFF  FE6,FEE
1764:  DECFSZ 01,F
1766:  BRA    1760
1768:  DECFSZ 02,F
176A:  BRA    1760
176C:  CLRF   19
176E:  BTFSC  FF2.7
1770:  BSF    19.7
1772:  BCF    FF2.7
....................       
....................       return(usb_flush_in(endpoint, len, tgl));
1774:  MOVFF  18E,1E3
1778:  MOVFF  192,1E5
177C:  MOVFF  191,1E4
1780:  MOVFF  193,1E6
1784:  MOVLB  0
1786:  CALL   0C4A
178A:  BTFSC  19.7
178C:  BSF    FF2.7
178E:  MOVF   01,W
1790:  BRA    1796
....................    }
....................    else 
....................    {
....................       //putc('-');
....................       //printf("%X", EP_BDxST_I(endpoint));
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
.................... 
....................    return(0);
1792:  MOVLW  00
1794:  MOVWF  01
1796:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
....................    unsigned int16 len;
.................... 
....................   #if USB_IGNORE_RX_DTS
....................    if (tgl == USB_DTS_STALL) 
....................    {
....................       debug_usb_token(debug_putc, '*');
....................       EP_BDxCNT_O(endpoint) = 0x84;
....................       EP_BDxST_I(endpoint) = 0x84;
....................       return;
....................    }
....................    else
....................       i=0x80;
....................   #else
....................    i = EP_BDxST_O(endpoint);
*
0AF4:  MOVLB  1
0AF6:  CLRF   xEE
0AF8:  MOVFF  1E3,1ED
0AFC:  CLRF   xF0
0AFE:  MOVLW  08
0B00:  MOVWF  xEF
0B02:  MOVLB  0
0B04:  CALL   02B6
0B08:  MOVLB  1
0B0A:  MOVFF  01,FE9
0B0E:  MOVLW  04
0B10:  ADDWF  02,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEF,1E5
....................    if (tgl == USB_DTS_TOGGLE) 
0B18:  MOVF   xE4,W
0B1A:  SUBLW  02
0B1C:  BNZ   0B2A
....................    {
....................       if (bit_test(i,6))
0B1E:  BTFSS  xE5.6
0B20:  BRA    0B26
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0B22:  CLRF   xE4
0B24:  BRA    0B2A
....................       else
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0B26:  MOVLW  01
0B28:  MOVWF  xE4
....................    }
....................    if (tgl == USB_DTS_STALL) 
0B2A:  MOVF   xE4,W
0B2C:  SUBLW  03
0B2E:  BNZ   0B68
....................    {
....................       i = 0x84;
0B30:  MOVLW  84
0B32:  MOVWF  xE5
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints
0B34:  CLRF   xEE
0B36:  MOVFF  1E3,1ED
0B3A:  CLRF   xF0
0B3C:  MOVLW  08
0B3E:  MOVWF  xEF
0B40:  MOVLB  0
0B42:  CALL   02B6
0B46:  MOVFF  02,1E9
0B4A:  MOVFF  01,1E8
0B4E:  MOVLW  04
0B50:  MOVLB  1
0B52:  ADDWF  xE8,F
0B54:  MOVLW  00
0B56:  ADDWFC xE9,F
0B58:  MOVFF  1E8,FE9
0B5C:  MOVLW  04
0B5E:  ADDWF  xE9,W
0B60:  MOVWF  FEA
0B62:  MOVLW  84
0B64:  MOVWF  FEF
....................    }
0B66:  BRA    0B76
....................    else if (tgl == USB_DTS_DATA1)
0B68:  DECFSZ xE4,W
0B6A:  BRA    0B72
....................       i = 0xC8;  //DATA1, UOWN
0B6C:  MOVLW  C8
0B6E:  MOVWF  xE5
0B70:  BRA    0B76
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN
0B72:  MOVLW  88
0B74:  MOVWF  xE5
....................   #endif
.................... 
....................    //bit_clear(__usb_kbhit_status,endpoint);
.................... 
....................    len = usb_ep_rx_size[endpoint];
0B76:  BCF    FD8.0
0B78:  RLCF   xE3,W
0B7A:  CLRF   03
0B7C:  MOVLB  0
0B7E:  CALL   00CE
0B82:  TBLRD*+
0B84:  MOVFF  FF5,03
0B88:  MOVLB  1
0B8A:  MOVWF  xE6
0B8C:  MOVFF  03,1E7
....................    EP_BDxCNT_O(endpoint) = len;
0B90:  CLRF   xEE
0B92:  MOVFF  1E3,1ED
0B96:  CLRF   xF0
0B98:  MOVLW  08
0B9A:  MOVWF  xEF
0B9C:  MOVLB  0
0B9E:  CALL   02B6
0BA2:  MOVFF  01,1E8
0BA6:  MOVLW  01
0BA8:  MOVLB  1
0BAA:  ADDWF  01,W
0BAC:  MOVWF  01
0BAE:  MOVLW  00
0BB0:  ADDWFC 02,W
0BB2:  MOVWF  03
0BB4:  MOVFF  01,FE9
0BB8:  MOVLW  04
0BBA:  ADDWF  03,W
0BBC:  MOVWF  FEA
0BBE:  MOVFF  1E6,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}
0BC2:  BTFSS  xE7.0
0BC4:  BRA    0BC8
0BC6:  BSF    xE5.0
....................    if (bit_test(len,9)) {bit_set(i,1);}
0BC8:  BTFSS  xE7.1
0BCA:  BRA    0BCE
0BCC:  BSF    xE5.1
.................... 
....................    EP_BDxST_O(endpoint) = i;
0BCE:  CLRF   xEE
0BD0:  MOVFF  1E3,1ED
0BD4:  CLRF   xF0
0BD6:  MOVLW  08
0BD8:  MOVWF  xEF
0BDA:  MOVLB  0
0BDC:  CALL   02B6
0BE0:  MOVLB  1
0BE2:  MOVFF  01,FE9
0BE6:  MOVLW  04
0BE8:  ADDWF  02,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  1E5,FEF
0BF0:  MOVLB  0
0BF2:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... {
....................    return(EP_BDxCNT_O(endpoint));
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN Hardware layer functions required by USB.
.................... 
.................... /*****************************************************************************
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer.
.................... /*
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM.
.................... /*          Does not mark the endpoint as ready for more data.  Once you are
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready
.................... /*          to receive more data.
.................... /*
.................... /*****************************************************************************/
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
*
1434:  CLRF   19
1436:  BTFSC  FF2.7
1438:  BSF    19.7
143A:  BCF    FF2.7
.................... {
....................    unsigned int8 * al;
....................    unsigned int8 st;
....................    unsigned int16 i;
.................... 
....................    al = EP_BDxADR_O(endpoint);
143C:  MOVLB  1
143E:  CLRF   xEE
1440:  MOVFF  191,1ED
1444:  CLRF   xF0
1446:  MOVLW  08
1448:  MOVWF  xEF
144A:  MOVLB  0
144C:  CALL   02B6
1450:  BTFSC  19.7
1452:  BSF    FF2.7
1454:  MOVFF  01,19B
1458:  MOVLW  02
145A:  MOVLB  1
145C:  ADDWF  01,W
145E:  MOVWF  01
1460:  MOVLW  00
1462:  ADDWFC 02,W
1464:  MOVWF  03
1466:  MOVFF  01,FE9
146A:  MOVLW  04
146C:  ADDWF  03,W
146E:  MOVWF  FEA
1470:  MOVFF  FEC,197
1474:  MOVF   FED,F
1476:  MOVFF  FEF,196
147A:  CLRF   19
147C:  BTFSC  FF2.7
147E:  BSF    19.7
1480:  BCF    FF2.7
....................    i = EP_BDxCNT_O(endpoint);
1482:  CLRF   xEE
1484:  MOVFF  191,1ED
1488:  CLRF   xF0
148A:  MOVLW  08
148C:  MOVWF  xEF
148E:  MOVLB  0
1490:  CALL   02B6
1494:  BTFSC  19.7
1496:  BSF    FF2.7
1498:  MOVFF  01,19B
149C:  MOVLW  01
149E:  MOVLB  1
14A0:  ADDWF  01,W
14A2:  MOVWF  01
14A4:  MOVLW  00
14A6:  ADDWFC 02,W
14A8:  MOVWF  03
14AA:  MOVFF  01,FE9
14AE:  MOVLW  04
14B0:  ADDWF  03,W
14B2:  MOVWF  FEA
14B4:  CLRF   x9A
14B6:  MOVFF  FEF,199
14BA:  CLRF   19
14BC:  BTFSC  FF2.7
14BE:  BSF    19.7
14C0:  BCF    FF2.7
....................    st = EP_BDxST_O(endpoint);
14C2:  CLRF   xEE
14C4:  MOVFF  191,1ED
14C8:  CLRF   xF0
14CA:  MOVLW  08
14CC:  MOVWF  xEF
14CE:  MOVLB  0
14D0:  CALL   02B6
14D4:  BTFSC  19.7
14D6:  BSF    FF2.7
14D8:  MOVLB  1
14DA:  MOVFF  01,FE9
14DE:  MOVLW  04
14E0:  ADDWF  02,W
14E2:  MOVWF  FEA
14E4:  MOVFF  FEF,198
.................... 
....................    //read BC8 and BC9
....................    if (bit_test(st,0)) {bit_set(i,8);}
14E8:  BTFSS  x98.0
14EA:  BRA    14EE
14EC:  BSF    x9A.0
....................    if (bit_test(st,1)) {bit_set(i,9);}
14EE:  BTFSS  x98.1
14F0:  BRA    14F4
14F2:  BSF    x9A.1
.................... 
....................    if (i < max) {max = i;}
14F4:  MOVF   x9A,W
14F6:  SUBWF  x95,W
14F8:  BNC   150A
14FA:  BNZ   1502
14FC:  MOVF   x94,W
14FE:  SUBWF  x99,W
1500:  BC    150A
1502:  MOVFF  19A,195
1506:  MOVFF  199,194
....................    
....................    memcpy(ptr, al ,max);
150A:  MOVFF  193,FEA
150E:  MOVFF  192,FE9
1512:  MOVFF  197,FE2
1516:  MOVFF  196,FE1
151A:  MOVFF  195,02
151E:  MOVFF  194,01
1522:  MOVF   01,F
1524:  BZ    152A
1526:  INCF   02,F
1528:  BRA    152E
152A:  MOVF   02,F
152C:  BZ    153A
152E:  MOVFF  FE6,FEE
1532:  DECFSZ 01,F
1534:  BRA    152E
1536:  DECFSZ 02,F
1538:  BRA    152E
.................... 
....................    return(max);
153A:  MOVFF  194,01
153E:  MOVFF  195,02
1542:  MOVLB  0
1544:  GOTO   155E (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max)
.................... {
....................    max = usb_get_packet_buffer(endpoint, ptr, max);
1548:  MOVFF  18C,191
154C:  MOVFF  18E,193
1550:  MOVFF  18D,192
1554:  MOVFF  190,195
1558:  MOVFF  18F,194
155C:  BRA    1434
155E:  MOVFF  02,190
1562:  MOVFF  01,18F
1566:  CLRF   19
1568:  BTFSC  FF2.7
156A:  BSF    19.7
156C:  BCF    FF2.7
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);
156E:  MOVFF  18C,1E3
1572:  MOVLW  02
1574:  MOVLB  1
1576:  MOVWF  xE4
1578:  MOVLB  0
157A:  CALL   0AF4
157E:  BTFSC  19.7
1580:  BSF    FF2.7
.................... 
....................    return(max);
1582:  MOVLB  1
1584:  MOVFF  18F,01
1588:  MOVFF  190,02
158C:  MOVLB  0
158E:  GOTO   1600 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=s%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0970:  MOVLB  1
0972:  BCF    xE4.0
0974:  BTFSC  xE3.7
0976:  BSF    xE4.0
....................    endpoint &= 0x7F;
0978:  BCF    xE3.7
....................    
....................    if (direction) 
097A:  BTFSS  xE4.0
097C:  BRA    09B0
....................    {
....................       EP_BDxST_I(endpoint) = 0x84;
097E:  CLRF   xEE
0980:  MOVFF  1E3,1ED
0984:  CLRF   xF0
0986:  MOVLW  08
0988:  MOVWF  xEF
098A:  MOVLB  0
098C:  RCALL  02B6
098E:  MOVFF  02,1E6
0992:  MOVFF  01,1E5
0996:  MOVLW  04
0998:  MOVLB  1
099A:  ADDWF  xE5,F
099C:  MOVLW  00
099E:  ADDWFC xE6,F
09A0:  MOVFF  1E5,FE9
09A4:  MOVLW  04
09A6:  ADDWF  xE6,W
09A8:  MOVWF  FEA
09AA:  MOVLW  84
09AC:  MOVWF  FEF
....................    }
09AE:  BRA    09D0
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x84;
09B0:  CLRF   xEE
09B2:  MOVFF  1E3,1ED
09B6:  CLRF   xF0
09B8:  MOVLW  08
09BA:  MOVWF  xEF
09BC:  MOVLB  0
09BE:  RCALL  02B6
09C0:  MOVLB  1
09C2:  MOVFF  01,FE9
09C6:  MOVLW  04
09C8:  ADDWF  02,W
09CA:  MOVWF  FEA
09CC:  MOVLW  84
09CE:  MOVWF  FEF
....................    }
09D0:  MOVLB  0
09D2:  GOTO   0A80 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=u%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
08F6:  MOVLB  1
08F8:  BCF    xE4.0
08FA:  BTFSC  xE3.7
08FC:  BSF    xE4.0
....................    endpoint &= 0x7F;
08FE:  BCF    xE3.7
....................    
....................    if (direction) 
0900:  BTFSS  xE4.0
0902:  BRA    0936
....................    {
....................      #if USB_IGNORE_RX_DTS
....................       EP_BDxST_I(endpoint) = 0x80;
....................      #else
....................       EP_BDxST_I(endpoint) = 0x88;
0904:  CLRF   xEE
0906:  MOVFF  1E3,1ED
090A:  CLRF   xF0
090C:  MOVLW  08
090E:  MOVWF  xEF
0910:  MOVLB  0
0912:  RCALL  02B6
0914:  MOVFF  02,1E6
0918:  MOVFF  01,1E5
091C:  MOVLW  04
091E:  MOVLB  1
0920:  ADDWF  xE5,F
0922:  MOVLW  00
0924:  ADDWFC xE6,F
0926:  MOVFF  1E5,FE9
092A:  MOVLW  04
092C:  ADDWF  xE6,W
092E:  MOVWF  FEA
0930:  MOVLW  88
0932:  MOVWF  FEF
....................      #endif
....................    }
0934:  BRA    0954
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x00;
0936:  CLRF   xEE
0938:  MOVFF  1E3,1ED
093C:  CLRF   xF0
093E:  MOVLW  08
0940:  MOVWF  xEF
0942:  MOVLB  0
0944:  RCALL  02B6
0946:  MOVLB  1
0948:  MOVFF  01,FE9
094C:  MOVLW  04
094E:  ADDWF  02,W
0950:  MOVWF  FEA
0952:  CLRF   FEF
....................    }
....................    
....................   #if defined(__STALL_ON_UEP_ERRATA__)
....................    bit_clear(UEP(endpoint), 0);
0954:  CLRF   03
0956:  MOVF   xE3,W
0958:  ADDLW  70
095A:  MOVWF  01
095C:  MOVLW  0F
095E:  ADDWFC 03,F
0960:  MOVFF  01,FE9
0964:  MOVFF  03,FEA
0968:  BCF    FEF.0
....................   #endif
096A:  MOVLB  0
096C:  GOTO   0A70 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    unsigned int8 st;
....................    
....................    direction = bit_test(endpoint,7);
*
09D6:  MOVLB  1
09D8:  BCF    xE4.0
09DA:  BTFSC  xE3.7
09DC:  BSF    xE4.0
....................    endpoint &= 0x7F;
09DE:  BCF    xE3.7
....................    
....................    if (direction) 
09E0:  BTFSS  xE4.0
09E2:  BRA    0A16
....................    {
....................       st=EP_BDxST_I(endpoint);
09E4:  CLRF   xEE
09E6:  MOVFF  1E3,1ED
09EA:  CLRF   xF0
09EC:  MOVLW  08
09EE:  MOVWF  xEF
09F0:  MOVLB  0
09F2:  RCALL  02B6
09F4:  MOVFF  02,1E7
09F8:  MOVFF  01,1E6
09FC:  MOVLW  04
09FE:  MOVLB  1
0A00:  ADDWF  xE6,F
0A02:  MOVLW  00
0A04:  ADDWFC xE7,F
0A06:  MOVFF  1E6,FE9
0A0A:  MOVLW  04
0A0C:  ADDWF  xE7,W
0A0E:  MOVWF  FEA
0A10:  MOVFF  FEF,1E5
....................    }
0A14:  BRA    0A36
....................    else 
....................    {
....................       st=EP_BDxST_O(endpoint);
0A16:  CLRF   xEE
0A18:  MOVFF  1E3,1ED
0A1C:  CLRF   xF0
0A1E:  MOVLW  08
0A20:  MOVWF  xEF
0A22:  MOVLB  0
0A24:  RCALL  02B6
0A26:  MOVLB  1
0A28:  MOVFF  01,FE9
0A2C:  MOVLW  04
0A2E:  ADDWF  02,W
0A30:  MOVWF  FEA
0A32:  MOVFF  FEF,1E5
....................    }
....................    
....................    return(bit_test(st,7) && bit_test(st,2));
0A36:  BTFSS  xE5.7
0A38:  BRA    0A3E
0A3A:  BTFSC  xE5.2
0A3C:  BRA    0A42
0A3E:  MOVLW  00
0A40:  BRA    0A44
0A42:  MOVLW  01
0A44:  MOVWF  01
0A46:  MOVLB  0
0A48:  GOTO   0A98 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_address(unsigned int8 address) 
.................... {
....................    UADDR = address;
*
0DA0:  MOVFF  1E4,F6E
....................    
....................    if (address) 
0DA4:  MOVLB  1
0DA6:  MOVF   xE4,F
0DA8:  BZ    0DB0
....................    {
....................       usb_state = USB_STATE_ADDRESS;
0DAA:  MOVLW  04
0DAC:  MOVWF  28
....................    }
0DAE:  BRA    0DB4
....................    else 
....................    {
....................       usb_state = USB_STATE_POWERED;
0DB0:  MOVLW  02
0DB2:  MOVWF  28
....................    }
0DB4:  MOVLB  0
0DB6:  GOTO   0DC4 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_configured(unsigned int8 config) 
.................... {
....................    unsigned int8 en;
....................    unsigned int16 addy;
....................    unsigned int8 new_uep;
....................    unsigned int16 len;
....................    unsigned int8 i;
....................    
....................    if (config == 0)
*
05A8:  MOVLB  1
05AA:  MOVF   xE3,F
05AC:  BNZ   05BA
....................    {
....................       // if config=0 then set addressed state
....................       usb_state = USB_STATE_ADDRESS;
05AE:  MOVLW  04
05B0:  MOVWF  28
....................       usb_disable_endpoints();
05B2:  MOVLB  0
05B4:  RCALL  0348
....................    }
05B6:  BRA    078C
05B8:  MOVLB  1
....................    else 
....................    {
....................       // else set configed state
....................       usb_state = USB_STATE_CONFIGURED; 
05BA:  MOVLW  05
05BC:  MOVWF  28
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH);
05BE:  MOVLW  04
05C0:  MOVWF  xE6
05C2:  MOVLW  90
05C4:  MOVWF  xE5
....................       for (en=1; en<USB_NUM_UEP; en++) 
05C6:  MOVLW  01
05C8:  MOVWF  xE4
05CA:  MOVF   xE4,W
05CC:  SUBLW  0F
05CE:  BTFSS  FD8.0
05D0:  BRA    078C
....................       {
....................          // enable and config endpoints based upon user configuration
....................          usb_disable_endpoint(en);
05D2:  MOVFF  1E4,1EC
05D6:  MOVLB  0
05D8:  RCALL  02D8
....................          new_uep = 0;
05DA:  MOVLB  1
05DC:  CLRF   xE7
....................          if (usb_ep_rx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
05DE:  CLRF   03
05E0:  MOVF   xE4,W
05E2:  MOVLB  0
05E4:  RCALL  00AE
05E6:  SUBLW  FF
05E8:  BZ    06B8
....................          {
....................             new_uep = 0x04;
05EA:  MOVLW  04
05EC:  MOVLB  1
05EE:  MOVWF  xE7
....................             len = usb_ep_rx_size[en];
05F0:  BCF    FD8.0
05F2:  RLCF   xE4,W
05F4:  CLRF   03
05F6:  MOVLB  0
05F8:  RCALL  00CE
05FA:  TBLRD*+
05FC:  MOVFF  FF5,03
0600:  MOVLB  1
0602:  MOVWF  xE8
0604:  MOVFF  03,1E9
....................             EP_BDxCNT_O(en) = len;
0608:  CLRF   xEE
060A:  MOVFF  1E4,1ED
060E:  CLRF   xF0
0610:  MOVLW  08
0612:  MOVWF  xEF
0614:  MOVLB  0
0616:  RCALL  02B6
0618:  MOVFF  01,1EB
061C:  MOVLW  01
061E:  MOVLB  1
0620:  ADDWF  01,W
0622:  MOVWF  01
0624:  MOVLW  00
0626:  ADDWFC 02,W
0628:  MOVWF  03
062A:  MOVFF  01,FE9
062E:  MOVLW  04
0630:  ADDWF  03,W
0632:  MOVWF  FEA
0634:  MOVFF  1E8,FEF
....................             EP_BDxADR_O(en) = addy;
0638:  CLRF   xEE
063A:  MOVFF  1E4,1ED
063E:  CLRF   xF0
0640:  MOVLW  08
0642:  MOVWF  xEF
0644:  MOVLB  0
0646:  RCALL  02B6
0648:  MOVFF  01,1EB
064C:  MOVLW  02
064E:  MOVLB  1
0650:  ADDWF  01,W
0652:  MOVWF  01
0654:  MOVLW  00
0656:  ADDWFC 02,W
0658:  MOVWF  03
065A:  MOVFF  01,FE9
065E:  MOVLW  04
0660:  ADDWF  03,W
0662:  MOVWF  FEA
0664:  MOVFF  1E6,FEC
0668:  MOVF   FED,F
066A:  MOVFF  1E5,FEF
....................             addy += usb_ep_rx_size[en];
066E:  BCF    FD8.0
0670:  RLCF   xE4,W
0672:  CLRF   03
0674:  MOVLB  0
0676:  RCALL  00CE
0678:  TBLRD*+
067A:  MOVFF  FF5,03
067E:  MOVLB  1
0680:  ADDWF  xE5,F
0682:  MOVF   03,W
0684:  ADDWFC xE6,F
....................            #if USB_IGNORE_RX_DTS
....................             i = 0x80;
....................            #else
....................             i = 0x88;
0686:  MOVLW  88
0688:  MOVWF  xEA
....................            #endif
....................             if (bit_test(len,8)) {bit_set(i,0);}
068A:  BTFSS  xE9.0
068C:  BRA    0690
068E:  BSF    xEA.0
....................             if (bit_test(len,9)) {bit_set(i,1);}
0690:  BTFSS  xE9.1
0692:  BRA    0696
0694:  BSF    xEA.1
....................             EP_BDxST_O(en) = i;
0696:  CLRF   xEE
0698:  MOVFF  1E4,1ED
069C:  CLRF   xF0
069E:  MOVLW  08
06A0:  MOVWF  xEF
06A2:  MOVLB  0
06A4:  RCALL  02B6
06A6:  MOVLB  1
06A8:  MOVFF  01,FE9
06AC:  MOVLW  04
06AE:  ADDWF  02,W
06B0:  MOVWF  FEA
06B2:  MOVFF  1EA,FEF
06B6:  MOVLB  0
....................          }
....................          if (usb_ep_tx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
06B8:  CLRF   03
06BA:  MOVLB  1
06BC:  MOVF   xE4,W
06BE:  MOVLB  0
06C0:  RCALL  00AE
06C2:  SUBLW  FF
06C4:  BZ    0756
....................          {
....................             new_uep |= 0x02;
06C6:  MOVLB  1
06C8:  BSF    xE7.1
....................             EP_BDxADR_I(en) = addy;
06CA:  CLRF   xEE
06CC:  MOVFF  1E4,1ED
06D0:  CLRF   xF0
06D2:  MOVLW  08
06D4:  MOVWF  xEF
06D6:  MOVLB  0
06D8:  RCALL  02B6
06DA:  MOVFF  02,1EC
06DE:  MOVFF  01,1EB
06E2:  MOVLW  04
06E4:  MOVLB  1
06E6:  ADDWF  xEB,F
06E8:  MOVLW  00
06EA:  ADDWFC xEC,F
06EC:  MOVLW  02
06EE:  ADDWF  xEB,W
06F0:  MOVWF  01
06F2:  MOVLW  00
06F4:  ADDWFC xEC,W
06F6:  MOVWF  03
06F8:  MOVFF  01,FE9
06FC:  MOVLW  04
06FE:  ADDWF  03,W
0700:  MOVWF  FEA
0702:  MOVFF  1E6,FEC
0706:  MOVF   FED,F
0708:  MOVFF  1E5,FEF
....................             addy += usb_ep_tx_size[en];
070C:  BCF    FD8.0
070E:  RLCF   xE4,W
0710:  CLRF   03
0712:  MOVLB  0
0714:  RCALL  00CE
0716:  TBLRD*+
0718:  MOVFF  FF5,03
071C:  MOVLB  1
071E:  ADDWF  xE5,F
0720:  MOVF   03,W
0722:  ADDWFC xE6,F
....................             EP_BDxST_I(en) = 0x40;
0724:  CLRF   xEE
0726:  MOVFF  1E4,1ED
072A:  CLRF   xF0
072C:  MOVLW  08
072E:  MOVWF  xEF
0730:  MOVLB  0
0732:  RCALL  02B6
0734:  MOVFF  02,1EC
0738:  MOVFF  01,1EB
073C:  MOVLW  04
073E:  MOVLB  1
0740:  ADDWF  xEB,F
0742:  MOVLW  00
0744:  ADDWFC xEC,F
0746:  MOVFF  1EB,FE9
074A:  MOVLW  04
074C:  ADDWF  xEC,W
074E:  MOVWF  FEA
0750:  MOVLW  40
0752:  MOVWF  FEF
0754:  MOVLB  0
....................          }
....................          if (new_uep == 0x06) {new_uep = 0x0E;}
0756:  MOVLB  1
0758:  MOVF   xE7,W
075A:  SUBLW  06
075C:  BNZ   0762
075E:  MOVLW  0E
0760:  MOVWF  xE7
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;}
0762:  CLRF   03
0764:  MOVF   xE4,W
0766:  MOVLB  0
0768:  RCALL  00AE
076A:  SUBLW  01
076C:  BZ    0774
076E:  MOVLB  1
0770:  BSF    xE7.4
0772:  MOVLB  0
....................          
....................          UEP(en) = new_uep;
0774:  CLRF   03
0776:  MOVLB  1
0778:  MOVF   xE4,W
077A:  ADDLW  70
077C:  MOVWF  FE9
077E:  MOVLW  0F
0780:  ADDWFC 03,W
0782:  MOVWF  FEA
0784:  MOVFF  1E7,FEF
0788:  INCF   xE4,F
078A:  BRA    05CA
078C:  MOVLB  0
....................       }
....................    }
078E:  GOTO   083A (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... {
....................    UEP(en) = ENDPT_DISABLED;
*
02D8:  CLRF   03
02DA:  MOVLB  1
02DC:  MOVF   xEC,W
02DE:  ADDLW  70
02E0:  MOVWF  FE9
02E2:  MOVLW  0F
02E4:  ADDWFC 03,W
02E6:  MOVWF  FEA
02E8:  CLRF   FEF
....................    
....................    if (usb_endpoint_is_valid(en))
02EA:  MOVFF  1EC,1ED
02EE:  MOVLB  0
02F0:  RCALL  0268
02F2:  MOVF   01,F
02F4:  BZ    0346
....................    {
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary      
02F6:  MOVLB  1
02F8:  CLRF   xEE
02FA:  MOVFF  1EC,1ED
02FE:  CLRF   xF0
0300:  MOVLW  08
0302:  MOVWF  xEF
0304:  MOVLB  0
0306:  RCALL  02B6
0308:  MOVLB  1
030A:  MOVFF  01,FE9
030E:  MOVLW  04
0310:  ADDWF  02,W
0312:  MOVWF  FEA
0314:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary
0316:  CLRF   xEE
0318:  MOVFF  1EC,1ED
031C:  CLRF   xF0
031E:  MOVLW  08
0320:  MOVWF  xEF
0322:  MOVLB  0
0324:  RCALL  02B6
0326:  MOVFF  02,1EE
032A:  MOVFF  01,1ED
032E:  MOVLW  04
0330:  MOVLB  1
0332:  ADDWF  xED,F
0334:  MOVLW  00
0336:  ADDWFC xEE,F
0338:  MOVFF  1ED,FE9
033C:  MOVLW  04
033E:  ADDWF  xEE,W
0340:  MOVWF  FEA
0342:  CLRF   FEF
0344:  MOVLB  0
....................    }
0346:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoints(void) 
.................... {
....................    unsigned int8 i;
....................    
....................    for (i=1; i<USB_NUM_UEP; i++)
0348:  MOVLW  01
034A:  MOVLB  1
034C:  MOVWF  xEB
034E:  MOVF   xEB,W
0350:  SUBLW  0F
0352:  BNC   0362
....................       usb_disable_endpoint(i);
0354:  MOVFF  1EB,1EC
0358:  MOVLB  0
035A:  RCALL  02D8
035C:  MOVLB  1
035E:  INCF   xEB,F
0360:  BRA    034E
0362:  MOVLB  0
0364:  RETURN 0
....................       
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... /// END Hardware layer functions required by USB.C
.................... 
.................... 
.................... /// BEGIN USB Interrupt Service Routine
.................... 
.................... static void usb_clear_trn(void)
.................... {
....................    //UIR_TRN = 0;
....................    //delay_cycles(6);
....................    UIR &= ~(1 << BIT_TRN);
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_handle_interrupt()
.................... /*
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished
.................... /*          tokens is the majority of this code, and is handled by usb.c
.................... /*
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and
.................... /*       disable it.
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt.
.................... /******************************************************************************/
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR)
.................... #int_usb NOCLEAR
.................... #endif
.................... void usb_isr(void)
.................... {
....................    unsigned int8 TRNAttempts;
....................    
....................    clear_interrupt(INT_USB);
*
0EE4:  BCF    FA1.5
....................    
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though
0EE6:  MOVF   28,F
0EE8:  BTFSC  FD8.2
0EEA:  BRA    0F5E
....................    if (UIR) 
0EEC:  MOVF   F68,F
0EEE:  BTFSC  FD8.2
0EF0:  BRA    0F5E
....................    {
....................       //debug_usb(debug_putc,"\r\n\n[%X] ",UIR);
.................... 
....................       //activity detected.  (only enable after sleep)
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}
0EF2:  BTFSS  F68.2
0EF4:  BRA    0EFC
0EF6:  BTFSC  F69.2
0EF8:  GOTO   0216
.................... 
....................       if (UCON_SUSPND) return;
0EFC:  BTFSC  F6D.1
0EFE:  BRA    0F5E
.................... 
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent
0F00:  BTFSS  F68.5
0F02:  BRA    0F0A
0F04:  BTFSC  F69.5
0F06:  GOTO   0252
.................... 
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected
0F0A:  BTFSS  F68.1
0F0C:  BRA    0F14
0F0E:  BTFSC  F69.1
0F10:  GOTO   0260
.................... 
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected
0F14:  BTFSS  F68.0
0F16:  BRA    0F1E
0F18:  BTFSC  F69.0
0F1A:  GOTO   0392
.................... 
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep
0F1E:  BTFSS  F68.4
0F20:  BRA    0F28
0F22:  BTFSC  F69.4
0F24:  GOTO   03C2
....................       
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}
0F28:  BTFSS  F68.6
0F2A:  BRA    0F32
0F2C:  BTFSC  F69.6
0F2E:  GOTO   03CC
.................... 
....................       TRNAttempts = 0;
0F32:  MOVLB  1
0F34:  CLRF   xE0
....................       do
....................       {
....................          if (UIR_TRN && UIE_TRN) 
0F36:  BTFSS  F68.3
0F38:  BRA    0F4E
0F3A:  BTFSS  F69.3
0F3C:  BRA    0F4E
....................          {
....................             USTATCopy = U1STAT;
0F3E:  MOVFF  F6C,27
....................             usb_clear_trn();
0F42:  MOVLB  0
0F44:  CALL   0004
....................             usb_isr_tok_dne();
0F48:  BRA    0DEC
....................          }
0F4A:  BRA    0F52
0F4C:  MOVLB  1
....................          else
....................             break;
0F4E:  BRA    0F5C
0F50:  MOVLB  0
....................       } while (TRNAttempts++ < 4);
0F52:  MOVLB  1
0F54:  MOVF   xE0,W
0F56:  INCF   xE0,F
0F58:  SUBLW  03
0F5A:  BC    0F36
0F5C:  MOVLB  0
.................... 
....................      #if defined(USB_CDC_ISR)
....................       //has to be done here, can't be done until TRN is empty.
....................       if (usb_cdc_kbhit())
....................       {
....................          USB_CDC_ISR();
....................       }
....................      #endif
....................    }
0F5E:  GOTO   0060
.................... }
.................... 
.................... // SOF interrupt not handled.  user must add this depending on application
.................... void usb_isr_sof(void) 
.................... {
....................    //debug_usb(debug_putc, "\r\nSOF");
....................    
....................    //UIR_SOF = 0;
....................    UIR &= ~(1 << BIT_SOF);
*
03CC:  BCF    F68.6
03CE:  GOTO   0F32 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_rst()
.................... /*
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device
.................... /*          and token handler code to initial state.
.................... /*
.................... /******************************************************************************/
.................... void usb_isr_rst(void) 
.................... {
....................    debug_usb_control(debug_putc,"-R-");
.................... 
....................    UEIE = 0;
*
0392:  CLRF   F6B
....................    UIE = 0;
0394:  CLRF   F69
....................    UEIR = 0;
0396:  CLRF   F6A
....................    UIR = 0;
0398:  CLRF   F68
.................... 
....................    UADDR = 0;
039A:  CLRF   F6E
....................    
....................    UEP(0) = ENDPT_DISABLED;
039C:  CLRF   F70
.................... 
....................    usb_disable_endpoints();
039E:  RCALL  0348
....................    
....................    usb_token_reset();
03A0:  RCALL  0366
.................... 
....................    UEP(0) = ENDPT_CONTROL | 0x10;
03A2:  MOVLW  16
03A4:  MOVWF  F70
.................... 
....................    while (UIR_TRN) 
03A6:  BTFSS  F68.3
03A8:  BRA    03AE
....................    {
....................       usb_clear_trn();
03AA:  RCALL  0004
03AC:  BRA    03A6
....................    }
.................... 
.................... 
....................    UEIE = 0x9F;
03AE:  MOVLW  9F
03B0:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE;
03B2:  MOVLW  3D
03B4:  MOVWF  F69
.................... 
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled
03B6:  BCF    F6D.4
.................... 
....................    usb_init_ep0_setup();
03B8:  RCALL  0228
.................... 
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state
03BA:  MOVLW  03
03BC:  MOVWF  28
03BE:  GOTO   0F1E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_init_ep0_setup()
.................... /*
.................... /* Summary: Configure EP0 to receive setup packets
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_ep0_setup(void) 
.................... {
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;
*
0228:  MOVLW  40
022A:  MOVLB  4
022C:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION;
022E:  MOVLW  04
0230:  MOVLB  1
0232:  MOVWF  xE2
0234:  MOVLW  10
0236:  MOVFF  1E2,403
023A:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off
....................    #else
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on
023E:  MOVLW  88
0240:  MOVLB  4
0242:  MOVWF  x00
....................    #endif
.................... 
....................     EP_BDxST_I(0) = 0;
0244:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH;
0246:  MOVLW  04
0248:  MOVWF  x07
024A:  MOVLW  50
024C:  MOVWF  x06
024E:  MOVLB  0
0250:  RETURN 0
.................... }
.................... 
.................... /*******************************************************************************
.................... /* usb_isr_uerr()
.................... /*
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter
.................... /*          will incerement.  If having problems check the status of these 8 bytes.
.................... /*
.................... /* NOTE: This code is not enabled by default.
.................... /********************************************************************************/
.................... void usb_isr_uerr(void)
.................... {
....................   #if USB_USE_ERROR_COUNTER
....................    int ints;
....................   #endif
.................... 
....................    debug_usb_control(debug_putc,"-E%X-",UEIR);
.................... 
....................   #if USB_USE_ERROR_COUNTER
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled
.................... 
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter
....................       //debug_usb(debug_putc,"PID ");
....................       ERROR_COUNTER[0]++;
....................    }
.................... 
....................    if ( bit_test(ints,1) ) 
....................    {  
....................       //increment crc5 error counter
....................       //debug_usb(debug_putc,"CRC5 ");
....................       ERROR_COUNTER[1]++;
....................    }
.................... 
....................    if ( bit_test(ints,2) ) 
....................    {
....................       //increment crc16 error counter
....................       //debug_usb(debug_putc,"CRC16 ");
....................       ERROR_COUNTER[2]++;
....................    }
.................... 
....................    if ( bit_test(ints,3) ) 
....................    {  
....................       //increment dfn8 error counter
....................       //debug_usb(debug_putc,"DFN8 ");
....................       ERROR_COUNTER[3]++;
....................    }
.................... 
....................    if ( bit_test(ints,4) ) 
....................    {  
....................       //increment bto error counter
....................       //debug_usb(debug_putc,"BTO ");
....................       ERROR_COUNTER[4]++;
....................    }
.................... 
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter
....................       //debug_usb(debug_putc,"BTS ");
....................       ERROR_COUNTER[5]++;
....................    }
....................   #endif
.................... 
....................    UEIR = 0;
*
0260:  CLRF   F6A
....................    
....................    //UIR_UERR = 0;
....................    UIR &= ~(1 << BIT_UERR);
0262:  BCF    F68.1
0264:  GOTO   0F14 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_uidle()
.................... /*
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_uidle(void)
.................... {
....................    debug_usb_control(debug_putc, "-I-");
.................... 
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)
*
03C2:  BSF    F69.2
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
....................    // turn off isr instead of clearing flag
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE;
03C4:  BCF    F69.4
....................   #else
....................    UIR &= ~(1 << BIT_IDLE);
....................   #endif
....................    
....................    UCON_SUSPND = 1; //set suspend. we are now suspended
03C6:  BSF    F6D.1
03C8:  GOTO   0F28 (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
.................... /* usb_isr_activity()
.................... /*
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB
.................... /*          peripheral.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_activity(void)
.................... {
....................    debug_usb_control(debug_putc, "-A-");
.................... 
....................    UCON_SUSPND = 0; //turn off low power suspending
*
0216:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling
0218:  BCF    F69.2
....................    
....................    while(UIR_ACTV)
021A:  BTFSS  F68.2
021C:  BRA    0222
....................    {
....................       //UIR_ACTV = 0;
....................       UIR &= ~(1 << BIT_ACTV);
021E:  BCF    F68.2
....................    }
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
0220:  BRA    021A
....................    // now it's safe to clear the flag
....................    UIR &= ~(1 << BIT_IDLE);
0222:  BCF    F68.4
....................   #endif   
0224:  GOTO   0EFC (RETURN)
.................... }
.................... 
.................... /******************************************************************************
.................... /* usb_isr_stall()
.................... /*
.................... /* Summary: Stall handshake detected.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_stall(void) 
.................... {
....................    debug_usb_control(debug_putc, "-S-");
....................    
....................    
....................    if (bit_test(UEP(0),0)) 
*
0252:  BTFSS  F70.0
0254:  BRA    025A
....................    {
....................       usb_init_ep0_setup();
0256:  RCALL  0228
....................       bit_clear(UEP(0), 0);
0258:  BCF    F70.0
....................    }
....................    
....................    //UIR_STALL = 0;
....................    UIR &= ~(1 << BIT_STALL);
025A:  BCF    F68.5
025C:  GOTO   0F0A (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;}
*
03D2:  MOVFF  1E7,29
03D6:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;}
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;}
03D8:  SETF   29
03DA:  RETURN 0
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_tok_dne()
.................... /*
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and
.................... /*          handle the request.
.................... /*          If an IN token on EP0 was received, continue transmitting any
.................... /*          unfinished requests that may take more than one packet to transmit
.................... /*          (if necessary).
.................... /*          If an OUT token on any other EP was received, mark that EP as ready
.................... /*          for a usb_get_packet().
.................... /*          Does not handle any IN or OUT tokens on EP0.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_tok_dne(void) 
.................... {
....................    unsigned int8 en;
.................... 
....................    en = USTATCopy>>3;
*
0DEC:  RRCF   27,W
0DEE:  MOVLB  1
0DF0:  MOVWF  xE1
0DF2:  RRCF   xE1,F
0DF4:  RRCF   xE1,F
0DF6:  MOVLW  1F
0DF8:  ANDWF  xE1,F
.................... 
....................    debug_usb_control(debug_putc, "-T%X-", USTATCopy);
.................... 
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
0DFA:  MOVF   27,F
0DFC:  BNZ   0E9A
....................    {
....................       //new out or setup token in the buffer
....................       int8 pidKey;
....................       
....................       //debug_usb(debug_putc,"%X ", EP_BDxST_O(0));
....................       
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID
0DFE:  MOVLB  4
0E00:  MOVF   x00,W
0E02:  ANDLW  3C
0E04:  MOVLB  1
0E06:  MOVWF  xE2
....................       
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion
0E08:  MOVLW  43
0E0A:  MOVLB  4
0E0C:  ANDWF  x00,F
....................       
....................       if (pidKey == USB_PIC_PID_SETUP) 
0E0E:  MOVLB  1
0E10:  MOVF   xE2,W
0E12:  SUBLW  34
0E14:  BNZ   0E60
....................       {
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00)
0E16:  MOVLB  4
0E18:  MOVF   x04,W
0E1A:  ANDLW  80
0E1C:  BZ    0E20
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)
0E1E:  CLRF   x04
.................... 
....................          //debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));
....................          //debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);
.................... 
....................          usb_isr_tok_setup_dne();
0E20:  MOVLB  0
0E22:  BRA    0AC2
.................... 
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
0E24:  BCF    F6D.4
.................... 
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall())
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data())
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response())
....................          if (__setup_0_tx_size == 0xFF)
0E26:  INCFSZ 29,W
0E28:  BRA    0E38
....................             usb_flush_out(0, USB_DTS_STALL);
0E2A:  MOVLB  1
0E2C:  CLRF   xE3
0E2E:  MOVLW  03
0E30:  MOVWF  xE4
0E32:  MOVLB  0
0E34:  RCALL  0AF4
0E36:  BRA    0E5C
....................          else 
....................          {
....................             usb_flush_out(0, USB_DTS_TOGGLE);
0E38:  MOVLB  1
0E3A:  CLRF   xE3
0E3C:  MOVLW  02
0E3E:  MOVWF  xE4
0E40:  MOVLB  0
0E42:  RCALL  0AF4
....................             if (__setup_0_tx_size != 0xFE)
0E44:  MOVF   29,W
0E46:  SUBLW  FE
0E48:  BZ    0E5C
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX);
0E4A:  MOVLB  1
0E4C:  CLRF   xE3
0E4E:  CLRF   xE5
0E50:  MOVFF  29,1E4
0E54:  MOVLW  04
0E56:  MOVWF  xE6
0E58:  MOVLB  0
0E5A:  RCALL  0C4A
....................          }
....................          //why was this here?
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
....................       }
0E5C:  BRA    0E96
0E5E:  MOVLB  1
....................       else if (pidKey == USB_PIC_PID_OUT) 
0E60:  MOVF   xE2,W
0E62:  SUBLW  04
0E64:  BNZ   0E98
....................       {
....................          usb_isr_tok_out_dne(0);
0E66:  CLRF   xE3
0E68:  MOVLB  0
0E6A:  RCALL  0D96
....................          usb_flush_out(0, USB_DTS_TOGGLE);
0E6C:  MOVLB  1
0E6E:  CLRF   xE3
0E70:  MOVLW  02
0E72:  MOVWF  xE4
0E74:  MOVLB  0
0E76:  RCALL  0AF4
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF))
0E78:  MOVF   29,W
0E7A:  SUBLW  FE
0E7C:  BZ    0E96
0E7E:  INCFSZ 29,W
0E80:  BRA    0E84
0E82:  BRA    0E96
....................          {
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)
0E84:  MOVLB  1
0E86:  CLRF   xE3
0E88:  CLRF   xE5
0E8A:  MOVFF  29,1E4
0E8E:  MOVLW  01
0E90:  MOVWF  xE6
0E92:  MOVLB  0
0E94:  RCALL  0C4A
0E96:  MOVLB  1
....................          }
....................       }
....................       //else
....................       //{
....................       //   debug_usb(debug_putc, "!!! ");
....................       //}
....................    }
0E98:  BRA    0EDE
....................    else if (USTATCopy == USTAT_IN_E0) 
0E9A:  MOVF   27,W
0E9C:  SUBLW  04
0E9E:  BNZ   0EC4
....................    {   
....................       //pic -> host transfer completed
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion
....................       __setup_0_tx_size = 0xFF;
0EA0:  SETF   29
....................       usb_isr_tok_in_dne(0);
0EA2:  CLRF   xE3
0EA4:  MOVLB  0
0EA6:  RCALL  0DC8
....................       if (__setup_0_tx_size!=0xFF)
0EA8:  INCFSZ 29,W
0EAA:  BRA    0EAE
0EAC:  BRA    0EC0
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE);
0EAE:  MOVLB  1
0EB0:  CLRF   xE3
0EB2:  CLRF   xE5
0EB4:  MOVFF  29,1E4
0EB8:  MOVLW  02
0EBA:  MOVWF  xE6
0EBC:  MOVLB  0
0EBE:  RCALL  0C4A
....................       else
....................       {
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................       }  
....................    }
0EC0:  BRA    0EDC
0EC2:  MOVLB  1
....................    else 
....................    {
....................       if (!bit_test(USTATCopy, 2)) 
0EC4:  BTFSC  27.2
0EC6:  BRA    0ED4
....................       {
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_out_dne(en);
0EC8:  MOVFF  1E1,1E3
0ECC:  MOVLB  0
0ECE:  RCALL  0D96
....................       }
0ED0:  BRA    0EDC
0ED2:  MOVLB  1
....................       else 
....................       {
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_in_dne(en);
0ED4:  MOVFF  1E1,1E3
0ED8:  MOVLB  0
0EDA:  RCALL  0DC8
0EDC:  MOVLB  1
....................       }
....................    }
0EDE:  MOVLB  0
0EE0:  GOTO   0F4A (RETURN)
.................... }
.................... 
.................... /// END USB Interrupt Service Routine
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... #if defined(__PIC24_USB_H__)
....................  #include <pic24_usb.c>
.................... #endif
.................... 
.................... #if defined(__USBN960X_H__)
....................  #include <usbn960x.c>
.................... #endif
.................... 
.................... 
.................... #IFNDEF __USB_HARDWARE__
....................    #ERROR You must include USB hardware driver.
.................... #ENDIF
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
....................    #ERROR You must include USB descriptors.
.................... #ENDIF
.................... 
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1))
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  64
.................... #else
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  8
.................... #endif
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors
.................... 
.................... #IF USB_HID_BOOT_PROTOCOL
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES];
.................... #ENDIF
.................... 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size);
.................... 
.................... void usb_isr_tkn_setup_StandardEndpoint(void);
.................... void usb_isr_tkn_setup_StandardDevice(void);
.................... void usb_isr_tkn_setup_StandardInterface(void);
.................... #IF USB_HID_DEVICE
....................    void usb_isr_tkn_setup_ClassInterface(void);
.................... #ENDIF
.................... void usb_Get_Descriptor(void);
.................... void usb_copy_desc_seg_to_ep(void);
.................... void usb_finish_set_address(void);
.................... 
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors
.................... 
.................... /// BEGIN User Functions
.................... 
.................... // see usb.h for documentation
.................... int1 usb_enumerated(void)
.................... {
....................    return(USB_stack_status.curr_config);
*
13D2:  MOVF   21,W
13D4:  MOVWF  01
13D6:  GOTO   3844 (RETURN)
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_wait_for_enumeration(void) 
.................... {
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();}
.................... }
.................... 
.................... // see USB.H for documentation
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) {
*
1798:  MOVLB  1
179A:  CLRF   x82
179C:  CLRF   x81
....................    unsigned int16 i=0;
....................    int1 res;
....................    unsigned int16 this_packet_len;
....................    unsigned int16 packet_size;
....................    unsigned int32 timeout_1us;
.................... 
....................    packet_size = usb_ep_tx_size[endpoint];
179E:  BCF    FD8.0
17A0:  RLCF   x7B,W
17A2:  CLRF   03
17A4:  MOVLB  0
17A6:  CALL   00CE
17AA:  TBLRD*+
17AC:  MOVFF  FF5,03
17B0:  MOVLB  1
17B2:  MOVWF  x86
17B4:  MOVFF  03,187
....................    
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size);
.................... 
....................    //send data packets until timeout or no more packets to send
....................    while (i < len) 
17B8:  MOVF   x82,W
17BA:  SUBWF  x7F,W
17BC:  BTFSS  FD8.0
17BE:  BRA    1892
17C0:  BNZ   17C8
17C2:  MOVF   x7E,W
17C4:  SUBWF  x81,W
17C6:  BC    1892
....................    {
....................       timeout_1us = (int32)timeout*1000;
17C8:  CLRF   x93
17CA:  CLRF   x92
17CC:  CLRF   x91
17CE:  MOVFF  180,190
17D2:  CLRF   x97
17D4:  CLRF   x96
17D6:  MOVLW  03
17D8:  MOVWF  x95
17DA:  MOVLW  E8
17DC:  MOVWF  x94
17DE:  MOVLB  0
17E0:  RCALL  1678
17E2:  MOVFF  03,18B
17E6:  MOVFF  02,18A
17EA:  MOVFF  01,189
17EE:  MOVFF  00,188
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;}
17F2:  MOVLB  1
17F4:  MOVF   x81,W
17F6:  SUBWF  x7E,W
17F8:  MOVWF  x8C
17FA:  MOVF   x82,W
17FC:  SUBWFB x7F,W
17FE:  MOVWF  x8D
1800:  MOVF   x87,W
1802:  SUBWF  x8D,W
1804:  BNC   1818
1806:  BNZ   180E
1808:  MOVF   x8C,W
180A:  SUBWF  x86,W
180C:  BC    1818
180E:  MOVFF  187,185
1812:  MOVFF  186,184
1816:  BRA    1824
....................       else {this_packet_len = len-i;}
1818:  MOVF   x81,W
181A:  SUBWF  x7E,W
181C:  MOVWF  x84
181E:  MOVF   x82,W
1820:  SUBWFB x7F,W
1822:  MOVWF  x85
....................       //putc('*');
....................       do 
....................       {
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets
1824:  MOVF   x81,W
1826:  ADDWF  x7C,W
1828:  MOVWF  x8C
182A:  MOVF   x82,W
182C:  ADDWFC x7D,W
182E:  MOVWF  x8D
1830:  MOVFF  17B,18E
1834:  MOVWF  x90
1836:  MOVFF  18C,18F
183A:  MOVFF  185,192
183E:  MOVFF  184,191
1842:  MOVLW  02
1844:  MOVWF  x93
1846:  MOVLB  0
1848:  RCALL  16D2
184A:  MOVLB  1
184C:  BCF    x83.0
184E:  BTFSC  01.0
1850:  BSF    x83.0
....................          //putc('.');
....................          if (!res)
1852:  BTFSC  x83.0
1854:  BRA    1870
....................          {
....................             delay_us(1);
1856:  MOVLW  03
1858:  MOVWF  00
185A:  DECFSZ 00,F
185C:  BRA    185A
185E:  BRA    1860
....................             //delay_ms(500);
....................             timeout_1us--;
1860:  MOVLW  FF
1862:  ADDWF  x88,F
1864:  BTFSS  FD8.0
1866:  ADDWF  x89,F
1868:  BTFSS  FD8.0
186A:  ADDWF  x8A,F
186C:  BTFSS  FD8.0
186E:  ADDWF  x8B,F
....................          }
....................       } while (!res && (!timeout || timeout_1us));
1870:  BTFSC  x83.0
1872:  BRA    1888
1874:  MOVF   x80,F
1876:  BZ    1824
1878:  MOVF   x88,F
187A:  BNZ   1824
187C:  MOVF   x89,F
187E:  BNZ   1824
1880:  MOVF   x8A,F
1882:  BNZ   1824
1884:  MOVF   x8B,F
1886:  BNZ   1824
....................       i += packet_size;
1888:  MOVF   x86,W
188A:  ADDWF  x81,F
188C:  MOVF   x87,W
188E:  ADDWFC x82,F
1890:  BRA    17B8
....................    }
.................... 
.................... 
....................    //send 0len packet if needed
....................    if (i==len) {
1892:  MOVF   x7E,W
1894:  SUBWF  x81,W
1896:  BNZ   193A
1898:  MOVF   x7F,W
189A:  SUBWF  x82,W
189C:  BNZ   193A
....................       timeout_1us=(int32)timeout*1000;
189E:  CLRF   x93
18A0:  CLRF   x92
18A2:  CLRF   x91
18A4:  MOVFF  180,190
18A8:  CLRF   x97
18AA:  CLRF   x96
18AC:  MOVLW  03
18AE:  MOVWF  x95
18B0:  MOVLW  E8
18B2:  MOVWF  x94
18B4:  MOVLB  0
18B6:  RCALL  1678
18B8:  MOVFF  03,18B
18BC:  MOVFF  02,18A
18C0:  MOVFF  01,189
18C4:  MOVFF  00,188
....................       do {
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message
18C8:  MOVFF  17B,18E
18CC:  MOVLB  1
18CE:  CLRF   x90
18D0:  CLRF   x8F
18D2:  CLRF   x92
18D4:  CLRF   x91
18D6:  MOVLW  02
18D8:  MOVWF  x93
18DA:  MOVLB  0
18DC:  RCALL  16D2
18DE:  MOVLB  1
18E0:  BCF    x83.0
18E2:  BTFSC  01.0
18E4:  BSF    x83.0
....................          if (!res) {
18E6:  BTFSC  x83.0
18E8:  BRA    1904
....................             delay_us(1);
18EA:  MOVLW  03
18EC:  MOVWF  00
18EE:  DECFSZ 00,F
18F0:  BRA    18EE
18F2:  BRA    18F4
....................             timeout_1us--;
18F4:  MOVLW  FF
18F6:  ADDWF  x88,F
18F8:  BTFSS  FD8.0
18FA:  ADDWF  x89,F
18FC:  BTFSS  FD8.0
18FE:  ADDWF  x8A,F
1900:  BTFSS  FD8.0
1902:  ADDWF  x8B,F
....................          }
....................       } while (!res && (!timeout || timeout_1us));
1904:  BTFSC  x83.0
1906:  BRA    193A
1908:  MOVF   x80,F
190A:  BTFSS  FD8.2
190C:  BRA    1912
190E:  MOVLB  0
1910:  BRA    18C8
1912:  MOVF   x88,F
1914:  BTFSC  FD8.2
1916:  BRA    191C
1918:  MOVLB  0
191A:  BRA    18C8
191C:  MOVF   x89,F
191E:  BTFSC  FD8.2
1920:  BRA    1926
1922:  MOVLB  0
1924:  BRA    18C8
1926:  MOVF   x8A,F
1928:  BTFSC  FD8.2
192A:  BRA    1930
192C:  MOVLB  0
192E:  BRA    18C8
1930:  MOVF   x8B,F
1932:  BTFSC  FD8.2
1934:  BRA    193A
1936:  MOVLB  0
1938:  BRA    18C8
....................    }
.................... 
....................    return(res);
193A:  MOVLW  00
193C:  BTFSC  x83.0
193E:  MOVLW  01
1940:  MOVWF  01
1942:  MOVLB  0
1944:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... unsigned int16 usb_gets(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max, unsigned int16 timeout) {
*
1592:  MOVLB  1
1594:  CLRF   x83
1596:  CLRF   x82
....................    unsigned int16 ret=0;
....................    unsigned int16 to;
....................    unsigned int16 len;
....................    unsigned int16 packet_size;
....................    unsigned int16 this_packet_max;
.................... 
....................    packet_size=usb_ep_rx_size[endpoint];
1598:  BCF    FD8.0
159A:  RLCF   x7B,W
159C:  CLRF   03
159E:  MOVLB  0
15A0:  CALL   00CE
15A4:  TBLRD*+
15A6:  MOVFF  FF5,03
15AA:  MOVLB  1
15AC:  MOVWF  x88
15AE:  MOVFF  03,189
.................... 
....................    do {
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;}
15B2:  MOVF   x89,W
15B4:  SUBWF  x7F,W
15B6:  BNC   15CA
15B8:  BNZ   15C0
15BA:  MOVF   x7E,W
15BC:  SUBWF  x88,W
15BE:  BC    15CA
15C0:  MOVFF  189,18B
15C4:  MOVFF  188,18A
15C8:  BRA    15D2
15CA:  MOVFF  17F,18B
15CE:  MOVFF  17E,18A
....................       to=0;
15D2:  CLRF   x85
15D4:  CLRF   x84
....................       do {
....................          len = packet_size;
15D6:  MOVFF  189,187
15DA:  MOVFF  188,186
....................          if (usb_kbhit(endpoint)) {
15DE:  MOVFF  17B,18C
15E2:  MOVLB  0
15E4:  RCALL  13DA
15E6:  MOVF   01,F
15E8:  BZ    1628
....................             len=usb_get_packet(endpoint,ptr,this_packet_max);
15EA:  MOVFF  17B,18C
15EE:  MOVFF  17D,18E
15F2:  MOVFF  17C,18D
15F6:  MOVFF  18B,190
15FA:  MOVFF  18A,18F
15FE:  BRA    1548
1600:  MOVFF  02,187
1604:  MOVFF  01,186
....................             ptr+=len;
1608:  MOVLB  1
160A:  MOVF   x86,W
160C:  ADDWF  x7C,F
160E:  MOVF   x87,W
1610:  ADDWFC x7D,F
....................             max-=len;
1612:  MOVF   x86,W
1614:  SUBWF  x7E,F
1616:  MOVF   x87,W
1618:  SUBWFB x7F,F
....................             ret+=len;
161A:  MOVF   x86,W
161C:  ADDWF  x82,F
161E:  MOVF   x87,W
1620:  ADDWFC x83,F
....................             break;
1622:  BRA    1646
....................          }
1624:  BRA    163A
1626:  MOVLB  0
....................          else {
....................             to++;
1628:  MOVLB  1
162A:  INCF   x84,F
162C:  BTFSC  FD8.2
162E:  INCF   x85,F
....................             delay_ms(1);
1630:  MOVLW  01
1632:  MOVWF  xC8
1634:  MOVLB  0
1636:  RCALL  116C
1638:  MOVLB  1
....................          }
....................       } while (to!=timeout);
163A:  MOVF   x80,W
163C:  SUBWF  x84,W
163E:  BNZ   15D6
1640:  MOVF   x81,W
1642:  SUBWF  x85,W
1644:  BNZ   15D6
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max);
1646:  MOVF   x88,W
1648:  SUBWF  x86,W
164A:  BNZ   166A
164C:  MOVF   x89,W
164E:  SUBWF  x87,W
1650:  BNZ   166A
1652:  MOVF   x80,W
1654:  IORWF  x81,W
1656:  BZ    1664
1658:  MOVF   x80,W
165A:  SUBWF  x84,W
165C:  BNZ   1664
165E:  MOVF   x81,W
1660:  SUBWF  x85,W
1662:  BZ    166A
1664:  MOVF   x7E,W
1666:  IORWF  x7F,W
1668:  BNZ   15B2
.................... 
....................    return(ret);
166A:  MOVFF  182,01
166E:  MOVFF  183,02
1672:  MOVLB  0
1674:  GOTO   3876 (RETURN)
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR)
.................... 
.................... // see usb.h for documentation
.................... void usb_token_reset(void) 
.................... {
....................    unsigned int i;
.................... 
....................    usb_getdesc_len = 0;
*
0366:  CLRF   2E
0368:  CLRF   2D
....................    
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++) 
036A:  MOVLB  1
036C:  CLRF   xE1
036E:  MOVF   xE1,F
0370:  BNZ   0386
....................       USB_Interface[i] = 0;   //reset each interface to default
0372:  CLRF   03
0374:  MOVF   xE1,W
0376:  ADDLW  2F
0378:  MOVWF  FE9
037A:  MOVLW  00
037C:  ADDWFC 03,W
037E:  MOVWF  FEA
0380:  CLRF   FEF
.................... 
....................   #IF USB_HID_BOOT_PROTOCOL
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++)
....................       hid_protocol[i] = 1;
....................   #endif
.................... 
....................   #if USB_CDC_DEVICE
0382:  INCF   xE1,F
0384:  BRA    036E
....................    usb_cdc_init();
....................   #endif
.................... 
....................    USB_stack_status.curr_config = 0;      //unconfigured device
0386:  CLRF   21
.................... 
....................    USB_stack_status.status_device = 1;    //previous state.  init at none
0388:  MOVLW  01
038A:  MOVWF  22
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none
038C:  CLRF   20
038E:  MOVLB  0
0390:  RETURN 0
.................... }
.................... 
.................... //send a 0len packet to endpoint 0 (optimization)
.................... //notice that this doesnt return the status
.................... #define usb_put_0len_0() usb_request_send_response(0)
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    direction = bit_test(endpoint,7);
*
0268:  MOVLB  1
026A:  BCF    xEE.0
026C:  BTFSC  xED.7
026E:  BSF    xEE.0
....................    
....................    endpoint &= 0x7F;
0270:  BCF    xED.7
....................    
....................    if (endpoint > 16)
0272:  MOVF   xED,W
0274:  SUBLW  10
0276:  BC    027E
....................       return(false);
0278:  MOVLW  00
027A:  MOVWF  01
027C:  BRA    02B2
....................    
....................    if (direction) { //IN
027E:  BTFSS  xEE.0
0280:  BRA    029C
....................       return(usb_ep_tx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
0282:  CLRF   03
0284:  MOVF   xED,W
0286:  MOVLB  0
0288:  RCALL  00AE
028A:  SUBLW  FF
028C:  BNZ   0292
028E:  MOVLW  00
0290:  BRA    0294
0292:  MOVLW  01
0294:  MOVWF  01
0296:  MOVLB  1
0298:  BRA    02B2
....................    }
029A:  BRA    02B2
....................    else {   //OUT
....................       return(usb_ep_rx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
029C:  CLRF   03
029E:  MOVF   xED,W
02A0:  MOVLB  0
02A2:  RCALL  00AE
02A4:  SUBLW  FF
02A6:  BNZ   02AC
02A8:  MOVLW  00
02AA:  BRA    02AE
02AC:  MOVLW  01
02AE:  MOVWF  01
02B0:  MOVLB  1
....................    }
02B2:  MOVLB  0
02B4:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) {
....................    if (endpoint==0) {
*
0DC8:  MOVLB  1
0DCA:  MOVF   xE3,F
0DCC:  BNZ   0DE8
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor?
0DCE:  DECFSZ 20,W
0DD0:  BRA    0DDC
0DD2:  MOVLB  0
0DD4:  CALL   03DC
0DD8:  BRA    0DE6
0DDA:  MOVLB  1
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();}
0DDC:  MOVF   20,W
0DDE:  SUBLW  02
0DE0:  BNZ   0DE8
0DE2:  MOVLB  0
0DE4:  BRA    0DBA
0DE6:  MOVLB  1
....................    }
....................   #if USB_CDC_DEVICE
0DE8:  MOVLB  0
0DEA:  RETURN 0
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
....................       usb_isr_tok_in_cdc_data_dne();
....................   }
....................   #endif
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint)
.................... {
....................    //TODO:
....................    if (endpoint==0) {
*
0D96:  MOVLB  1
0D98:  MOVF   xE3,F
0D9A:  BNZ   0D9C
....................      debug_usb(debug_putc,"TOUT 0 ");
....................      #if USB_CDC_DEVICE
....................       usb_isr_tok_out_cdc_control_dne();
....................      //#else   //REMOVED JUN/9/2009
....................      //usb_init_ep0_setup();
....................      #endif
....................    }
....................   #if USB_CDC_DEVICE
0D9C:  MOVLB  0
0D9E:  RETURN 0
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
....................       usb_isr_tok_out_cdc_data_dne();
....................    }
....................   #endif
....................    //else {
....................    //   bit_set(__usb_kbhit_status,endpoint);
....................    //}
.................... }
.................... 
.................... 
.................... //---- process setup message stage -----------//
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_setup_dne(void) 
.................... {
....................    USB_stack_status.dev_req=NONE; // clear the device request..
*
0AC2:  CLRF   20
.................... 
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) {
0AC4:  MOVLB  4
0AC6:  MOVF   x10,W
0AC8:  ANDLW  7F
0ACA:  XORLW  00
0ACC:  MOVLB  0
0ACE:  BZ    0ADE
0AD0:  XORLW  01
0AD2:  BZ    0AE2
0AD4:  XORLW  03
0AD6:  BZ    0AE6
0AD8:  XORLW  23
0ADA:  BZ    0AEA
0ADC:  BRA    0AEE
.................... 
....................       case 0x00:  //standard to device
....................          debug_usb_token(debug_putc," d");
....................          usb_isr_tkn_setup_StandardDevice();
0ADE:  BRA    0792
....................          break;
0AE0:  BRA    0AF0
.................... 
....................       case 0x01:  //standard to interface
....................          debug_usb_token(debug_putc," i");
....................          usb_isr_tkn_setup_StandardInterface();
0AE2:  BRA    084E
....................          break;
0AE4:  BRA    0AF0
.................... 
....................       case 0x02:  //standard to endpoint
....................          debug_usb_token(debug_putc," e");
....................          usb_isr_tkn_setup_StandardEndpoint();
0AE6:  BRA    0A4C
....................          break;
0AE8:  BRA    0AF0
....................          
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case 0x21:  //class specific request.  the only class this driver supports is HID
....................          debug_usb_token(debug_putc, " class");
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE)
....................          {
....................             usb_isr_tkn_setup_ClassInterface();
....................          }
....................          else
....................          {
....................             usb_isr_tkn_cdc();
....................          }
....................         #elif USB_HID_DEVICE
....................          usb_isr_tkn_setup_ClassInterface();
0AEA:  BRA    0AB6
....................         #else
....................          usb_isr_tkn_cdc();
....................         #endif
....................          break;
0AEC:  BRA    0AF0
.................... #endif
.................... 
.................... 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE
.................... 
....................       default:
....................          usb_request_stall();
0AEE:  RCALL  03D8
....................          break;
....................    }
0AF0:  GOTO   0E24 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardDevice()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Device request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardDevice(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
*
0792:  MOVLB  4
0794:  MOVF   x11,W
0796:  XORLW  00
0798:  MOVLB  0
079A:  BZ    07B6
079C:  XORLW  01
079E:  BZ    07CA
07A0:  XORLW  02
07A2:  BZ    07E6
07A4:  XORLW  06
07A6:  BZ    0800
07A8:  XORLW  03
07AA:  BZ    0812
07AC:  XORLW  0E
07AE:  BZ    0816
07B0:  XORLW  01
07B2:  BZ    0826
07B4:  BRA    0848
.................... 
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device;
07B6:  MOVFF  22,450
....................             usb_ep0_tx_buffer[1]=0;
07BA:  MOVLB  4
07BC:  CLRF   x51
....................             usb_request_send_response(2);
07BE:  MOVLW  02
07C0:  MOVLB  1
07C2:  MOVWF  xE7
07C4:  MOVLB  0
07C6:  RCALL  03D2
....................             break;
07C8:  BRA    084A
.................... 
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1
....................             if (usb_ep0_rx_buffer[2] == 1) {
07CA:  MOVLB  4
07CC:  DECFSZ x12,W
07CE:  BRA    07E0
....................                debug_usb_token(debug_putc,"CF");
....................                USB_stack_status.status_device &= 1;
07D0:  MOVLW  01
07D2:  ANDWF  22,F
....................                usb_put_0len_0();
07D4:  MOVLB  1
07D6:  CLRF   xE7
07D8:  MOVLB  0
07DA:  RCALL  03D2
....................             }
07DC:  BRA    07E4
07DE:  MOVLB  4
....................             else
....................                usb_request_stall();
07E0:  MOVLB  0
07E2:  RCALL  03D8
....................             break;
07E4:  BRA    084A
.................... 
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3
....................             if (usb_ep0_rx_buffer[2] == 1) {
07E6:  MOVLB  4
07E8:  DECFSZ x12,W
07EA:  BRA    07FA
....................                debug_usb_token(debug_putc,"SF");
....................                USB_stack_status.status_device |= 2;
07EC:  BSF    22.1
....................                usb_put_0len_0();
07EE:  MOVLB  1
07F0:  CLRF   xE7
07F2:  MOVLB  0
07F4:  RCALL  03D2
....................             }
07F6:  BRA    07FE
07F8:  MOVLB  4
....................             else
....................                usb_request_stall();
07FA:  MOVLB  0
07FC:  RCALL  03D8
....................             break;
07FE:  BRA    084A
.................... 
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5
....................             debug_usb_token(debug_putc,"SA");
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request
0800:  MOVLW  02
0802:  MOVWF  20
....................             USB_address_pending=usb_ep0_rx_buffer[2];
0804:  MOVFF  412,2A
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request
....................             usb_set_address(USB_address_pending);
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0
....................             #endif
....................             usb_put_0len_0();
0808:  MOVLB  1
080A:  CLRF   xE7
080C:  MOVLB  0
080E:  RCALL  03D2
....................             break;
0810:  BRA    084A
.................... 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6
....................             debug_usb_token(debug_putc,"GD");
....................             usb_Get_Descriptor();
0812:  RCALL  049A
....................             break;
0814:  BRA    084A
.................... 
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8
....................             debug_usb_token(debug_putc,"GC");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config;
0816:  MOVFF  21,450
....................             usb_request_send_response(1);
081A:  MOVLW  01
081C:  MOVLB  1
081E:  MOVWF  xE7
0820:  MOVLB  0
0822:  RCALL  03D2
....................             break;
0824:  BRA    084A
.................... 
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) {
0826:  MOVLB  4
0828:  MOVF   x12,W
082A:  SUBLW  01
082C:  BNC   0844
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2];
082E:  MOVFF  412,21
....................                usb_set_configured(usb_ep0_rx_buffer[2]);
0832:  MOVFF  412,1E3
0836:  MOVLB  0
0838:  BRA    05A8
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);               
....................                usb_put_0len_0();
083A:  MOVLB  1
083C:  CLRF   xE7
083E:  MOVLB  0
0840:  RCALL  03D2
0842:  MOVLB  4
....................             }
....................             break;
0844:  MOVLB  0
0846:  BRA    084A
.................... 
....................       default:
....................             usb_request_stall();
0848:  RCALL  03D8
....................             break;
....................    }
084A:  GOTO   0AF0 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Interface request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardInterface(void) {
....................    unsigned int8 curr_config;
.................... 
....................    curr_config=USB_stack_status.curr_config;
084E:  MOVFF  21,1E3
.................... 
....................    switch (usb_ep0_rx_buffer[1]) {
0852:  MOVLB  4
0854:  MOVF   x11,W
0856:  XORLW  00
0858:  MOVLB  0
085A:  BZ    086A
085C:  XORLW  0A
085E:  BZ    087C
0860:  XORLW  01
0862:  BZ    08C0
0864:  XORLW  0D
0866:  BZ    08EC
0868:  BRA    08F0
....................       case USB_STANDARD_REQUEST_GET_STATUS:
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=0;
086A:  MOVLB  4
086C:  CLRF   x50
....................             usb_ep0_tx_buffer[1]=0;
086E:  CLRF   x51
....................             usb_request_send_response(2);
0870:  MOVLW  02
0872:  MOVLB  1
0874:  MOVWF  xE7
0876:  MOVLB  0
0878:  RCALL  03D2
....................             break;
087A:  BRA    08F2
.................... 
....................       case USB_STANDARD_REQUEST_GET_INTERFACE:
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state
087C:  MOVLB  1
087E:  MOVF   xE3,F
0880:  BZ    08BA
0882:  MOVLW  01
0884:  SUBWF  xE3,W
0886:  CLRF   03
0888:  MOVLB  0
088A:  RCALL  018C
088C:  MOVWF  01
088E:  MOVLB  4
0890:  SUBWF  x14,W
0892:  BTFSS  FD8.0
0894:  BRA    089A
0896:  MOVLB  1
0898:  BRA    08BA
....................                debug_usb_token(debug_putc,"GI");
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte
089A:  CLRF   03
089C:  MOVF   x14,W
089E:  ADDLW  2F
08A0:  MOVWF  FE9
08A2:  MOVLW  00
08A4:  ADDWFC 03,W
08A6:  MOVWF  FEA
08A8:  MOVFF  FEF,450
....................                usb_request_send_response(1); //send byte back
08AC:  MOVLW  01
08AE:  MOVLB  1
08B0:  MOVWF  xE7
08B2:  MOVLB  0
08B4:  RCALL  03D2
....................             }
08B6:  BRA    08BE
08B8:  MOVLB  1
....................             else
....................                usb_request_stall();
08BA:  MOVLB  0
08BC:  RCALL  03D8
....................             break;
08BE:  BRA    08F2
.................... 
....................       case USB_STANDARD_REQUEST_SET_INTERFACE:
....................             if (curr_config) { //if configured state
08C0:  MOVLB  1
08C2:  MOVF   xE3,F
08C4:  BZ    08E6
....................                debug_usb_token(debug_putc,"SI");
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
08C6:  CLRF   03
08C8:  MOVLB  4
08CA:  MOVF   x14,W
08CC:  ADDLW  2F
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC 03,W
08D4:  MOVWF  FEA
08D6:  MOVFF  412,FEF
....................                usb_put_0len_0();
08DA:  MOVLB  1
08DC:  CLRF   xE7
08DE:  MOVLB  0
08E0:  RCALL  03D2
....................             }
08E2:  BRA    08EA
08E4:  MOVLB  1
....................             else
....................                usb_request_stall();
08E6:  MOVLB  0
08E8:  RCALL  03D8
....................             break;
08EA:  BRA    08F2
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR:
....................             debug_usb_token(debug_putc,"GDh");
....................             usb_Get_Descriptor();
08EC:  RCALL  049A
....................             break;
08EE:  BRA    08F2
.................... #endif
.................... 
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE:
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE:
.................... //                let default take care of these, goto wrongstate
....................       default:
....................             usb_request_stall();
08F0:  RCALL  03D8
....................             break;
....................    }
08F2:  GOTO   0AF0 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardEndpoint()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardEndpoint(void) {
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) {
*
0A4C:  MOVFF  414,1ED
0A50:  RCALL  0268
0A52:  MOVF   01,F
0A54:  BZ    0AB2
....................       switch(usb_ep0_rx_buffer[1]) {
0A56:  MOVLB  4
0A58:  MOVF   x11,W
0A5A:  XORLW  01
0A5C:  MOVLB  0
0A5E:  BZ    0A6A
0A60:  XORLW  02
0A62:  BZ    0A7A
0A64:  XORLW  03
0A66:  BZ    0A8A
0A68:  BRA    0AB0
.................... 
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE:
....................                debug_usb_token(debug_putc,"CF");
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]);
0A6A:  MOVFF  414,1E3
0A6E:  BRA    08F6
....................                usb_put_0len_0();
0A70:  MOVLB  1
0A72:  CLRF   xE7
0A74:  MOVLB  0
0A76:  RCALL  03D2
....................                break;
0A78:  BRA    0AB2
.................... 
....................          case USB_STANDARD_REQUEST_SET_FEATURE:
....................                      debug_usb_token(debug_putc,"SF");
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]);
0A7A:  MOVFF  414,1E3
0A7E:  BRA    0970
....................                      usb_put_0len_0();
0A80:  MOVLB  1
0A82:  CLRF   xE7
0A84:  MOVLB  0
0A86:  RCALL  03D2
....................                      break;
0A88:  BRA    0AB2
.................... 
....................          case USB_STANDARD_REQUEST_GET_STATUS:
....................                debug_usb_token(debug_putc,"GS");
....................                usb_ep0_tx_buffer[0]=0;
0A8A:  MOVLB  4
0A8C:  CLRF   x50
....................                usb_ep0_tx_buffer[1]=0;
0A8E:  CLRF   x51
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) {
0A90:  MOVFF  414,1E3
0A94:  MOVLB  0
0A96:  BRA    09D6
0A98:  MOVF   01,F
0A9A:  BZ    0AA4
....................                   usb_ep0_tx_buffer[0]=1;
0A9C:  MOVLW  01
0A9E:  MOVLB  4
0AA0:  MOVWF  x50
0AA2:  MOVLB  0
....................                }
....................                usb_request_send_response(2);
0AA4:  MOVLW  02
0AA6:  MOVLB  1
0AA8:  MOVWF  xE7
0AAA:  MOVLB  0
0AAC:  RCALL  03D2
....................                break;
0AAE:  BRA    0AB2
.................... 
....................          default:
....................             usb_request_stall();
0AB0:  RCALL  03D8
....................             break;
....................       }
....................    }
0AB2:  GOTO   0AF0 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_ClassInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /* Only compiled if HID_DEVICE is TRUE
.................... /***************************************************************/
.................... #IF USB_HID_DEVICE
.................... void usb_isr_tkn_setup_ClassInterface(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
0AB6:  MOVLB  4
0AB8:  MOVF   x11,W
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03
....................             debug_usb_token(debug_putc,"GP");
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]];
....................             usb_request_send_response(1);
....................             break;
....................     #ENDIF
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b
....................             debug_usb_token(debug_putc,"SP");
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
....................             usb_put_0len_0(); //send 0len packet69
....................             break;
....................     #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_SET_IDLE:   //0a
....................          #error TODO: if you want to support SET_IDLE, add code here
....................    #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_GET_IDLE:   //02
....................          #error TODO: if you want to support GET_IDLE, add code here
....................    #ENDIF
.................... 
....................       default:
....................             usb_request_stall();
0ABA:  MOVLB  0
0ABC:  RCALL  03D8
....................             break;
....................    }
0ABE:  GOTO   0AF0 (RETURN)
.................... }
.................... #ENDIF
.................... 
.................... /**************************************************************
.................... /* usb_Get_Descriptor()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept
.................... /*
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.),
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have
.................... /*          pointers to constants we must simulate or own by setting up global registers that say
.................... /*          which constant array to deal with, which position to start in this array, and the length.
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne()
.................... /*          which will send the rest of the data.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_Get_Descriptor() {
*
049A:  MOVLB  1
049C:  CLRF   xE4
....................    unsigned int8 i = 0;
....................    usb_getdesc_ptr=0;
049E:  CLRF   2C
04A0:  CLRF   2B
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE;
04A2:  CLRF   23
.................... 
....................    switch(usb_ep0_rx_buffer[3]) {
04A4:  MOVLB  4
04A6:  MOVF   x13,W
04A8:  XORLW  01
04AA:  MOVLB  0
04AC:  BZ    04C0
04AE:  XORLW  03
04B0:  BZ    04CC
04B2:  XORLW  01
04B4:  BZ    04D4
04B6:  XORLW  22
04B8:  BZ    050C
04BA:  XORLW  03
04BC:  BZ    0540
04BE:  BRA    0584
....................       case USB_DESC_DEVICE_TYPE:    //1
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN;
04C0:  CLRF   2E
04C2:  MOVLW  12
04C4:  MOVWF  2D
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE;
04C6:  MOVLW  03
04C8:  MOVWF  23
....................             break;
04CA:  BRA    0588
.................... 
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually.
....................       case USB_DESC_CONFIG_TYPE:   //2
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN;
04CC:  CLRF   2E
04CE:  MOVLW  29
04D0:  MOVWF  2D
....................             break;
04D2:  BRA    0588
.................... 
....................       case USB_DESC_STRING_TYPE: //3
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE;
04D4:  MOVLW  02
04D6:  MOVWF  23
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]];
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++)
04D8:  MOVLB  1
04DA:  CLRF   xE4
04DC:  MOVLB  4
04DE:  MOVF   x12,W
04E0:  MOVLB  1
04E2:  SUBWF  xE4,W
04E4:  BC    04FC
....................             {
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr];
04E6:  MOVFF  2C,03
04EA:  MOVF   2B,W
04EC:  MOVLB  0
04EE:  RCALL  01D2
04F0:  ADDWF  2B,F
04F2:  MOVLW  00
04F4:  ADDWFC 2C,F
04F6:  MOVLB  1
04F8:  INCF   xE4,F
04FA:  BRA    04DC
....................             }
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr];
04FC:  MOVFF  2C,03
0500:  MOVF   2B,W
0502:  MOVLB  0
0504:  RCALL  01D2
0506:  MOVWF  2D
0508:  CLRF   2E
....................             break;
050A:  BRA    0588
.................... 
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06
....................       // this is needed so host can find out about differences about this
....................       // devices ability to handle full speed verses fast speed.
....................       // since we don't support fast speed then we ignore this.
....................       //      break;
.................... 
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case USB_DESC_CLASS_TYPE:  //0x21
....................             //TODO does this work for multiple interfaces or multiple languages?
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]];
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]];
050C:  BCF    FD8.0
050E:  MOVLB  4
0510:  RLCF   x12,W
0512:  CLRF   03
0514:  MOVLB  0
0516:  RCALL  019E
0518:  TBLRD*+
051A:  MOVFF  FF5,03
051E:  MOVWF  2B
0520:  MOVFF  03,2C
....................             if (usb_getdesc_ptr!=0xFF) {
0524:  INCFSZ 2B,W
0526:  BRA    052C
0528:  MOVF   2C,F
052A:  BZ    053C
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr];
052C:  MOVFF  2C,03
0530:  MOVF   2B,W
0532:  RCALL  0152
0534:  MOVWF  2D
0536:  CLRF   2E
....................                break;
0538:  BRA    0588
....................             }
053A:  BRA    0540
....................             else {
....................                usb_request_stall();
053C:  RCALL  03D8
....................                return;
053E:  BRA    05A6
....................             }
.................... #endif
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_DESC_HIDREPORT_TYPE: //0x22
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]];
0540:  BCF    FD8.0
0542:  MOVLB  4
0544:  RLCF   x14,W
0546:  CLRF   03
0548:  MOVLB  0
054A:  RCALL  012E
054C:  TBLRD*+
054E:  MOVFF  FF5,03
0552:  MOVWF  2B
0554:  MOVFF  03,2C
....................             if (usb_getdesc_ptr !=0xFF) {
0558:  INCFSZ 2B,W
055A:  BRA    0560
055C:  MOVF   2C,F
055E:  BZ    0580
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE;
0560:  MOVLW  01
0562:  MOVWF  23
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]];
0564:  BCF    FD8.0
0566:  MOVLB  4
0568:  RLCF   x14,W
056A:  CLRF   03
056C:  MOVLB  0
056E:  RCALL  0140
0570:  TBLRD*+
0572:  MOVFF  FF5,03
0576:  MOVWF  2D
0578:  MOVFF  03,2E
....................                break;
057C:  BRA    0588
....................             }
057E:  BRA    0584
....................             else {
....................                usb_request_stall();
0580:  RCALL  03D8
....................                return;
0582:  BRA    05A6
....................             }
.................... #endif
.................... 
....................       default:
....................             usb_request_stall();
0584:  RCALL  03D8
....................             return;
0586:  BRA    05A6
....................    }
....................    if (usb_ep0_rx_buffer[7]==0) {
0588:  MOVLB  4
058A:  MOVF   x17,F
058C:  BNZ   059E
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6])
058E:  MOVF   2E,F
0590:  BNZ   0598
0592:  MOVF   2D,W
0594:  SUBWF  x16,W
0596:  BC    059E
....................          usb_getdesc_len = usb_ep0_rx_buffer[6];
0598:  CLRF   2E
059A:  MOVFF  416,2D
....................    }
....................    USB_stack_status.dev_req=GET_DESCRIPTOR;
059E:  MOVLW  01
05A0:  MOVWF  20
....................    usb_copy_desc_seg_to_ep();
05A2:  MOVLB  0
05A4:  RCALL  03DC
05A6:  RETURN 0
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_finish_set_address()
.................... /*
.................... /* Input: USB_address_pending holds the address we were asked to set to.
.................... /*
.................... /* Summary: Sets the address.
.................... /*
.................... /* This code should only be run on the PIC USB peripheral, and not the
.................... /* National peripheral.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
....................  void usb_finish_set_address() {
....................    debug_usb_token(debug_putc," FSA ");
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0
*
0DBA:  CLRF   21
.................... 
....................    #ifdef __PIC__
....................    USB_stack_status.dev_req=NONE;  // no request pending
0DBC:  CLRF   20
....................    usb_set_address(USB_address_pending);
0DBE:  MOVFF  2A,1E4
0DC2:  BRA    0DA0
....................    #endif
0DC4:  GOTO   0DE6 (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// The following function retrieve data from constant arrays.  This may
.................... /// look un-optimized, but remember that you can't create a pointer to
.................... /// a constant array.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... void usb_copy_desc_seg_to_ep(void) {
*
03DC:  MOVLB  1
03DE:  CLRF   xE5
....................    unsigned int i=0;
....................    char c;
....................    
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]);
.................... 
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH))
03E0:  MOVF   2D,W
03E2:  IORWF  2E,W
03E4:  BZ    0460
03E6:  MOVF   xE5,W
03E8:  SUBLW  3F
03EA:  BNC   0460
....................    {
....................       switch(USB_stack_status.getdesc_type) {
03EC:  MOVF   23,W
03EE:  ADDLW  FC
03F0:  BC    043C
03F2:  ADDLW  04
03F4:  MOVLB  0
03F6:  GOTO   0478
....................          case USB_GETDESC_CONFIG_TYPE:
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr];
03FA:  MOVFF  2C,03
03FE:  MOVF   2B,W
0400:  RCALL  0152
0402:  MOVFF  FE8,1E6
....................             break;
0406:  MOVLB  1
0408:  BRA    043C
.................... 
....................         #IF USB_HID_DEVICE
....................          case USB_GETDESC_HIDREPORT_TYPE:
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr];
040A:  MOVFF  2C,03
040E:  MOVF   2B,W
0410:  RCALL  00FE
0412:  MOVFF  FE8,1E6
....................             break;
0416:  MOVLB  1
0418:  BRA    043C
....................         #endif
.................... 
....................          case USB_GETDESC_STRING_TYPE:
....................             c=USB_STRING_DESC[usb_getdesc_ptr];
041A:  MOVFF  2C,03
041E:  MOVF   2B,W
0420:  RCALL  01D2
0422:  MOVFF  FE8,1E6
....................             break;
0426:  MOVLB  1
0428:  BRA    043C
.................... 
....................          case USB_GETDESC_DEVICE_TYPE:
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr];
042A:  MOVFF  2C,03
042E:  MOVF   2B,W
0430:  RCALL  01B0
0432:  MOVFF  FE8,1E6
....................             //debug_usb(debug_putc, "-%X- ", c);
....................             break;
0436:  MOVLB  1
0438:  BRA    043C
043A:  MOVLB  1
....................       }
....................       usb_getdesc_ptr++;
043C:  INCF   2B,F
043E:  BTFSC  FD8.2
0440:  INCF   2C,F
....................       usb_getdesc_len--;
0442:  MOVF   2D,W
0444:  BTFSC  FD8.2
0446:  DECF   2E,F
0448:  DECF   2D,F
....................       usb_ep0_tx_buffer[i++]=c;
044A:  MOVF   xE5,W
044C:  INCF   xE5,F
044E:  ADDLW  50
0450:  MOVWF  FE9
0452:  MOVLW  04
0454:  MOVWF  FEA
0456:  BTFSC  FD8.0
0458:  INCF   FEA,F
045A:  MOVFF  1E6,FEF
045E:  BRA    03E0
....................    }
.................... 
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) {
0460:  MOVF   2D,W
0462:  IORWF  2E,W
0464:  BNZ   046E
0466:  MOVF   xE5,W
0468:  SUBLW  40
046A:  BZ    046E
....................          USB_stack_status.dev_req = NONE;
046C:  CLRF   20
....................    }
.................... 
....................    usb_request_send_response(i);
046E:  MOVFF  1E5,1E7
0472:  MOVLB  0
0474:  RCALL  03D2
0476:  RETURN 0
.................... }
.................... 
.................... #ENDIF
.................... 
.................... 
.................... // HID command defines
.................... #define  CMD_FLASH_LED           1  //  flash the LED as a failsafe check
.................... #define  CMD_NORMAL_READ         2  //  read all of the 4 channels 64 times and display SpO2 on LCD
.................... #define  CMD_DISPLAY_VOLTAGES    3  //  voltage display mode  
.................... #define  CMD_MEASURE             4  //  measure 4 chs and return the values (for real time display)
.................... #define  CMD_MEASURE_64          5  //  measure 4 chs 64 times and prepare to return 64 values (see CMD_GET_DATA)
.................... #define  CMD_GET_DATA            6  //  return the 64 int16 values 32 at a time
.................... 
.................... // CMD_GET_DATA subcommands
.................... #define SEND_DC_PART             1  // return the 2 DC values (4 bytes total)
.................... #define SEND_AC660_1             2  // send the 1st 32 AC660 values (64 bytes)
.................... #define SEND_AC660_2             3  // send the 2nd 32 AC660 values (64 bytes)
.................... #define SEND_AC940_1             4  // send the 1st 32 AC940 values (64 bytes)
.................... #define SEND_AC940_2             5  // send the 2nd 32 AC940 values (64 bytes)
.................... 
.................... // set PWM module to 1KHz to run the oximeter
.................... #USE PWM(OUTPUT=PIN_C2, FREQUENCY=3000, DUTY=50)
.................... 
.................... #define LED           PIN_A0    // test LED define
.................... #define MEASURE_PIN   PIN_B4    // pin start measurement cycle 
.................... 
.................... // pin defines for the 16x2 LCD - used by flex_lcd.c
.................... #define LCD_E         PIN_A1  
.................... #define LCD_RS        PIN_A2  
.................... #define LCD_DB4       PIN_B0  
.................... #define LCD_DB5       PIN_B1  
.................... #define LCD_DB6       PIN_B2  
.................... #define LCD_DB7       PIN_B3 
.................... 
.................... #include <Flex_lcd.c>   // LCD driver
.................... // flex_lcd.c  - Flexible driver configured for a 16x2 LCD
.................... // My modification of some simple PIC LCD code I found online at
.................... // https://www.ccsinfo.com/forum/viewtopic.php?t=24661
.................... // These pins are what I used to test the driver and match your
.................... // example code.
.................... 
.................... // Data pins for "nibble" mode (send 4 bits twice for a BYTE)
.................... //#define LCD_DB4   PIN_B0 
.................... //#define LCD_DB5   PIN_B1 
.................... //#define LCD_DB6   PIN_B2 
.................... //#define LCD_DB7   PIN_B3 
.................... 
.................... // control pins 
.................... //#define LCD_E     PIN_A1 
.................... //#define LCD_RS    PIN_A2 
.................... //#define LCD_RW    PIN_A3 
.................... 
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and don't define 
.................... // USE_LCD_RW or set it to 0
.................... // i.e.  to use the LCD read functionality 
.................... // #define USE_LCD_RW   1      
.................... // otherwise
.................... // #define USE_LCD_RW 0  
.................... // or just leave it out and it will be set to 0 by default.
.................... 
.................... //======================================== 
.................... 
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
.................... 
.................... // global const int8 
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
....................                               
.................... 
.................... //------------------------------------- 
.................... // Sets the output nibble (4 bits) for the 
.................... // LCD to read
.................... //-----------------------------------------
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
*
1196:  MOVLB  1
1198:  BTFSC  xCF.0
119A:  BRA    11A0
119C:  BCF    F8A.0
119E:  BRA    11A2
11A0:  BSF    F8A.0
11A2:  BCF    F93.0
....................  output_bit(LCD_DB5, !!(nibble & 2));  
11A4:  BTFSC  xCF.1
11A6:  BRA    11AC
11A8:  BCF    F8A.1
11AA:  BRA    11AE
11AC:  BSF    F8A.1
11AE:  BCF    F93.1
....................  output_bit(LCD_DB6, !!(nibble & 4));    
11B0:  BTFSC  xCF.2
11B2:  BRA    11B8
11B4:  BCF    F8A.2
11B6:  BRA    11BA
11B8:  BSF    F8A.2
11BA:  BCF    F93.2
....................  output_bit(LCD_DB7, !!(nibble & 8));    
11BC:  BTFSC  xCF.3
11BE:  BRA    11C4
11C0:  BCF    F8A.3
11C2:  BRA    11C6
11C4:  BSF    F8A.3
11C6:  BCF    F93.3
.................... 
....................  delay_cycles(1); 
11C8:  NOP   
....................  output_high(LCD_E); 
11CA:  BCF    F92.1
11CC:  BSF    F89.1
....................  delay_us(2); 
11CE:  MOVLW  07
11D0:  MOVWF  00
11D2:  DECFSZ 00,F
11D4:  BRA    11D2
11D6:  BRA    11D8
....................  output_low(LCD_E); 
11D8:  BCF    F92.1
11DA:  BCF    F89.1
11DC:  MOVLB  0
11DE:  RETURN 0
.................... } 
.................... 
.................... //----------------------------------------------
.................... // This code is only compiled if you have 
.................... // defined USE_LCD_RW
.................... // The first function is called by lcd_read_byte()
.................... // You must set the R/W signal high by lcd_read_byte() before 
.................... // this routine is called.      
.................... 
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
....................    int8 retval; 
....................    // Create bit variables so that we can easily set 
....................    // individual bits in the retval variable. 
....................    #bit retval_0 = retval.0 
....................    #bit retval_1 = retval.1 
....................    #bit retval_2 = retval.2 
....................    #bit retval_3 = retval.3 
.................... 
....................    retval = 0;          // zero the bits
....................    output_high(LCD_E);  
....................    delay_cycles(1); 
....................    retval_0 = input(LCD_DB4);   // set the 4 bits
....................    retval_1 = input(LCD_DB5);   // based on what
....................    retval_2 = input(LCD_DB6);   // is displayed
....................    retval_3 = input(LCD_DB7);   // on the LCD
....................    output_low(LCD_E); 
....................    return(retval);              // return the nibble
.................... }    
.................... 
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
.................... // ----------------------------------------
.................... int8 lcd_read_byte(void) 
.................... { 
....................    int8 low = 0; 
....................    int8 high = 0; 
.................... 
....................    output_high(LCD_RW); 
....................    delay_cycles(1); 
....................    high = lcd_read_nibble(); 
....................    low = lcd_read_nibble(); 
....................    return( (high<<4) | low); 
.................... } 
.................... #endif     
.................... 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
....................    output_low(LCD_RS); 
11E0:  BCF    F92.2
11E2:  BCF    F89.2
.................... 
.................... #ifdef USE_LCD_RW 
....................    while(bit_test(lcd_read_byte(),7)) ; 
.................... #else 
....................    delay_us(60);  
11E4:  MOVLW  EF
11E6:  MOVWF  00
11E8:  DECFSZ 00,F
11EA:  BRA    11E8
11EC:  BRA    11EE
.................... #endif 
.................... 
....................    if(address) 
11EE:  MOVLB  1
11F0:  MOVF   xCC,F
11F2:  BZ    11FA
....................       output_high(LCD_RS); 
11F4:  BCF    F92.2
11F6:  BSF    F89.2
11F8:  BRA    11FE
....................    else 
....................     output_low(LCD_RS); 
11FA:  BCF    F92.2
11FC:  BCF    F89.2
....................       
....................   delay_cycles(1); 
11FE:  NOP   
.................... 
.................... #ifdef USE_LCD_RW 
....................    output_low(LCD_RW); 
....................    delay_cycles(1); 
.................... #endif 
.................... 
....................    output_low(LCD_E); 
1200:  BCF    F92.1
1202:  BCF    F89.1
....................    lcd_send_nibble(n >> 4); 
1204:  SWAPF  xCD,W
1206:  MOVWF  xCE
1208:  MOVLW  0F
120A:  ANDWF  xCE,F
120C:  MOVFF  1CE,1CF
1210:  MOVLB  0
1212:  RCALL  1196
....................    lcd_send_nibble(n & 0xf); 
1214:  MOVLB  1
1216:  MOVF   xCD,W
1218:  ANDLW  0F
121A:  MOVWF  xCE
121C:  MOVWF  xCF
121E:  MOVLB  0
1220:  RCALL  1196
1222:  RETURN 0
.................... } 
.................... 
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
....................    int8 i; 
.................... 
....................    output_low(LCD_RS); 
1224:  BCF    F92.2
1226:  BCF    F89.2
.................... 
.................... #ifdef USE_LCD_RW 
....................    output_low(LCD_RW); 
.................... #endif 
.................... 
....................    output_low(LCD_E); 
1228:  BCF    F92.1
122A:  BCF    F89.1
....................    delay_ms(15); 
122C:  MOVLW  0F
122E:  MOVLB  1
1230:  MOVWF  xC8
1232:  MOVLB  0
1234:  RCALL  116C
.................... 
....................    for(i=0; i < 3; i++)   { 
1236:  MOVLB  1
1238:  CLRF   x7B
123A:  MOVF   x7B,W
123C:  SUBLW  02
123E:  BNC   1258
....................       lcd_send_nibble(0x03); 
1240:  MOVLW  03
1242:  MOVWF  xCF
1244:  MOVLB  0
1246:  RCALL  1196
....................       delay_ms(5); 
1248:  MOVLW  05
124A:  MOVLB  1
124C:  MOVWF  xC8
124E:  MOVLB  0
1250:  RCALL  116C
1252:  MOVLB  1
1254:  INCF   x7B,F
1256:  BRA    123A
....................       } 
.................... 
....................    lcd_send_nibble(0x02); 
1258:  MOVLW  02
125A:  MOVWF  xCF
125C:  MOVLB  0
125E:  RCALL  1196
.................... 
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  { 
1260:  MOVLB  1
1262:  CLRF   x7B
1264:  MOVF   x7B,W
1266:  SUBLW  03
1268:  BNC   1290
....................       lcd_send_byte(0, LCD_INIT_STRING[i]); 
126A:  CLRF   03
126C:  MOVF   x7B,W
126E:  MOVLB  0
1270:  CALL   0202
1274:  MOVLB  1
1276:  MOVWF  x7C
1278:  CLRF   xCC
127A:  MOVWF  xCD
127C:  MOVLB  0
127E:  RCALL  11E0
....................       // If the R/W signal is not used, then 
....................       // the busy bit can't be polled.  One of 
....................       // the init commands takes longer than 
....................       // the hard-coded delay of 60 us, so in 
....................       // that case, lets just do a 5 ms delay 
....................       // after all four of them. 
....................      #ifndef USE_LCD_RW 
....................         delay_ms(5); 
1280:  MOVLW  05
1282:  MOVLB  1
1284:  MOVWF  xC8
1286:  MOVLB  0
1288:  RCALL  116C
....................      #endif 
128A:  MOVLB  1
128C:  INCF   x7B,F
128E:  BRA    1264
....................    } 
1290:  MOVLB  0
1292:  GOTO   3810 (RETURN)
.................... } 
.................... 
.................... //---------------------------- 
.................... //  Set the cursor position
.................... // -----------------------------
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
....................    int8 address; 
.................... 
....................    if(y != 1) 
1296:  MOVLB  1
1298:  DECFSZ xC9,W
129A:  BRA    129E
129C:  BRA    12A4
....................       address = lcd_line_two; 
129E:  MOVLW  40
12A0:  MOVWF  xCA
12A2:  BRA    12A6
....................    else 
....................       address=0; 
12A4:  CLRF   xCA
.................... 
....................    address += x-1; 
12A6:  MOVLW  01
12A8:  SUBWF  xC8,W
12AA:  ADDWF  xCA,F
....................    lcd_send_byte(0, 0x80 | address); 
12AC:  MOVF   xCA,W
12AE:  IORLW  80
12B0:  MOVWF  xCB
12B2:  CLRF   xCC
12B4:  MOVWF  xCD
12B6:  MOVLB  0
12B8:  RCALL  11E0
12BA:  GOTO   1316 (RETURN)
.................... } 
.................... 
.................... //---------------------------------
.................... // Write a single char to the LCD
.................... // The switch/case statement takes 
.................... // take some defined LCD format
.................... // codes into account 
.................... // \f  To clear display and set cursor to upper left
.................... // \n  To go to start of next line
.................... // \b  To move back one position
.................... //------------------------------------
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c)  { 
12BE:  MOVLB  1
12C0:  MOVF   xC7,W
12C2:  XORLW  0C
12C4:  MOVLB  0
12C6:  BZ    12D2
12C8:  XORLW  06
12CA:  BZ    12EA
12CC:  XORLW  02
12CE:  BZ    12FA
12D0:  BRA    1308
....................     case '\f': 
....................       lcd_send_byte(0,1); 
12D2:  MOVLB  1
12D4:  CLRF   xCC
12D6:  MOVLW  01
12D8:  MOVWF  xCD
12DA:  MOVLB  0
12DC:  RCALL  11E0
....................       delay_ms(2); 
12DE:  MOVLW  02
12E0:  MOVLB  1
12E2:  MOVWF  xC8
12E4:  MOVLB  0
12E6:  RCALL  116C
....................       break; 
12E8:  BRA    1316
....................     
....................     case '\n': 
....................        lcd_gotoxy(1,2); 
12EA:  MOVLW  01
12EC:  MOVLB  1
12EE:  MOVWF  xC8
12F0:  MOVLW  02
12F2:  MOVWF  xC9
12F4:  MOVLB  0
12F6:  BRA    1296
....................        break; 
12F8:  BRA    1316
....................     
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
12FA:  MOVLB  1
12FC:  CLRF   xCC
12FE:  MOVLW  10
1300:  MOVWF  xCD
1302:  MOVLB  0
1304:  RCALL  11E0
....................        break; 
1306:  BRA    1316
....................     
....................     default: 
....................        lcd_send_byte(1,c); 
1308:  MOVLW  01
130A:  MOVLB  1
130C:  MOVWF  xCC
130E:  MOVFF  1C7,1CD
1312:  MOVLB  0
1314:  RCALL  11E0
....................        break; 
....................    } 
1316:  RETURN 0
.................... } 
.................... 
.................... //-------------------------------------
.................... // Read the current char's from the LCD
.................... // if USE_LCD_RW is defined
.................... //-------------------------------------
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
....................    char value = 0; 
.................... 
....................    lcd_gotoxy(x,y); 
.................... 
....................    // Wait until busy flag is low. 
....................    while(bit_test(lcd_read_byte(),7));  
.................... 
....................    output_high(LCD_RS); 
....................    value = lcd_read_byte(); 
....................    output_low(lcd_RS); 
....................    return(value); 
.................... } 
.................... #endif
.................... 
.................... 
.................... // defines for MAX1303 ADC pins
.................... #define MAX1303_CS    PIN_A3
.................... #define MAX1303_DIN   PIN_A4
.................... #define MAX1303_SSTRB PIN_A5
.................... #define MAX1303_SCLK  PIN_C0
.................... #define MAX1303_DOUT  PIN_C1
.................... 
.................... // ADC conversion factors
.................... #define V_CONVERT   0.000125  // (65535 / (2 * 4.096V))  -- not really needed
.................... #define ADC_OFFSET  32768     // 65536/2
.................... 
.................... // macro define for creating a clock tick
.................... #define  MAX1303_CLKTIC  output_high(MAX1303_SCLK); delay_us(10); output_low(MAX1303_SCLK);
.................... 
.................... // Function prototypes
.................... void  SetupMAX1303(void);      
.................... int16 ReadMAX1303(int8 channel);
.................... void  MeasureSignals(void);
.................... void  Measure(void);
.................... void  DisplaySPO2(void);
.................... void  DisplayVoltage(void);
.................... void  BlinkLED(void);
.................... void  DataLoadStatus(void);
.................... void  LoadData(void);
.................... void  ExecuteCmd(void);
.................... 
.................... // # measurements - use power of 2 to make division fast
.................... #define NUM  64           // measure 10 times per second for about 6 seconds - 64 pts total
.................... #define NAVE 32           // number of times to average the ac signal per measurement
.................... 
.................... // global variables
.................... int16 AC660[NUM] = { 0 };  // storage for 660 nm AC signal
.................... int16 AC940[NUM] = { 0 };  // storage for 940 nm AC signal
.................... int16 DC660 = 0;           // storage for 660 nm DC value
.................... int16 DC940 = 0;           // storage for 940 nm DC value
.................... int8  cmd[NUM];            // buffer for command string received from the PC (via usb)
.................... int8  SequenceCode = 0; 
.................... float spo2 = 0.0;
.................... 
.................... // channel useage:  ch0 = AC940  ch1 = DC940 ch2 = AC660 ch3 - DC660
.................... 
.................... void main(void) {
*
3774:  CLRF   FF8
3776:  BCF    FD0.7
3778:  BSF    07.7
377A:  MOVLW  F9
377C:  MOVWF  FCB
377E:  MOVLW  06
3780:  MOVWF  FCA
3782:  BCF    F94.2
3784:  BCF    F8B.2
3786:  MOVLW  7D
3788:  MOVWF  FBE
378A:  MOVLW  0C
378C:  MOVWF  FBD
378E:  MOVLB  1
3790:  CLRF   x31
3792:  CLRF   x30
3794:  CLRF   x33
3796:  CLRF   x32
3798:  CLRF   x74
379A:  CLRF   x78
379C:  CLRF   x77
379E:  CLRF   x76
37A0:  CLRF   x75
37A2:  CLRF   x7A
37A4:  CLRF   x79
37A6:  MOVF   FC1,W
37A8:  ANDLW  C0
37AA:  IORLW  0F
37AC:  MOVWF  FC1
37AE:  MOVLW  07
37B0:  MOVWF  FB4
37B2:  BRA    37C8
37B4:  DATA 02,00
37B6:  DATA 1A,00
37B8:  DATA 00,03
37BA:  DATA 00,24
37BC:  DATA 00,04
37BE:  DATA 0C,FF
37C0:  DATA 40,30
37C2:  DATA 00,01
37C4:  DATA 80,00
37C6:  DATA 00,00
37C8:  MOVLW  00
37CA:  MOVWF  FF8
37CC:  MOVLW  37
37CE:  MOVWF  FF7
37D0:  MOVLW  B4
37D2:  MOVWF  FF6
37D4:  TBLRD*+
37D6:  MOVF   FF5,W
37D8:  MOVWF  00
37DA:  XORLW  00
37DC:  BZ    3804
37DE:  TBLRD*+
37E0:  MOVF   FF5,W
37E2:  MOVWF  01
37E4:  BTFSC  FE8.7
37E6:  BRA    37F2
37E8:  ANDLW  3F
37EA:  MOVWF  FEA
37EC:  TBLRD*+
37EE:  MOVFF  FF5,FE9
37F2:  BTFSC  01.6
37F4:  TBLRD*+
37F6:  BTFSS  01.6
37F8:  TBLRD*+
37FA:  MOVFF  FF5,FEE
37FE:  DCFSNZ 00,F
3800:  BRA    37D4
3802:  BRA    37F6
3804:  CLRF   FF8
....................    usb_init();                // initialize usb communications
3806:  MOVLB  0
3808:  GOTO   115E
....................    lcd_init();                // initialize the LCD. 
380C:  GOTO   1224
....................    lcd_putc("\fBME4390 Oximeter");  
3810:  MOVLW  62
3812:  MOVWF  FF6
3814:  MOVLW  0F
3816:  MOVWF  FF7
3818:  CALL   1318
....................    SetupMAX1303();            // initialize MAX1303
381C:  GOTO   1338
....................    BlinkLED();                // blink twice to  
3820:  CALL   13B2
....................    delay_ms(1000);            // indicate setup 
3824:  MOVLW  04
3826:  MOVLB  1
3828:  MOVWF  x7B
382A:  MOVLW  FA
382C:  MOVWF  xC8
382E:  MOVLB  0
3830:  CALL   116C
3834:  MOVLB  1
3836:  DECFSZ x7B,F
3838:  BRA    382A
....................    BlinkLED();                // was successful.
383A:  MOVLB  0
383C:  CALL   13B2
....................      
....................   // enter the endless while loop
....................    while(TRUE)   {
....................      if (usb_enumerated()) {   // if on the USB bus wait for a command
3840:  GOTO   13D2
3844:  MOVF   01,F
3846:  BZ    387A
....................         if (usb_kbhit(1)) {    // Check for USB commands
3848:  MOVLW  01
384A:  MOVLB  1
384C:  MOVWF  x8C
384E:  MOVLB  0
3850:  CALL   13DA
3854:  MOVF   01,F
3856:  BZ    3878
....................            usb_gets(1, cmd, 64, 100);
3858:  MOVLW  01
385A:  MOVLB  1
385C:  MOVWF  x7B
385E:  MOVWF  x7D
3860:  MOVLW  34
3862:  MOVWF  x7C
3864:  CLRF   x7F
3866:  MOVLW  40
3868:  MOVWF  x7E
386A:  CLRF   x81
386C:  MOVLW  64
386E:  MOVWF  x80
3870:  MOVLB  0
3872:  GOTO   1592
....................            ExecuteCmd();
3876:  BRA    364A
....................         }  // kbhit if end
....................     }   // usb enumeration check if end
3878:  BRA    388E
....................     else {   // if not on the USB bus just measure the SpO2 and display it if the measure pin is high
....................      if (input(MEASURE_PIN)) {   // measure SpO2 if pin is high
387A:  BSF    F93.4
387C:  BTFSS  F81.4
387E:  BRA    388A
....................           MeasureSignals();
3880:  CALL   1B80
....................           DisplaySPO2();
3884:  CALL   262C
....................      }
3888:  BRA    388E
....................      else {  // if MEASURE pin is low just display the voltages
....................          DisplayVoltage();
388A:  CALL   2BCE
....................      }
....................     }  // else end
388E:  BRA    3840
....................    } // while (1) end
.................... } // end of main()
.................... 
3890:  SLEEP 
.................... ///////////////////////////////////////////////////////////////////////////
.................... //   Executes a command based on the 1st byte in the HID string 
.................... //   byte 0 = cmd,  byte 1-63 = data bytes  
.................... /////////////////////////////////////////////////////////////////////////////
.................... void ExecuteCmd(void) 
.................... {
....................  
....................   switch (cmd[0]) {
*
364A:  MOVLW  01
364C:  MOVLB  1
364E:  SUBWF  x34,W
3650:  ADDLW  FA
3652:  BTFSC  FD8.0
3654:  BRA    3748
3656:  ADDLW  06
3658:  MOVLB  0
365A:  GOTO   374E
....................         case CMD_FLASH_LED:   
....................             usb_puts(1, cmd, 64, 100);    // echo string
365E:  MOVLW  01
3660:  MOVLB  1
3662:  MOVWF  x7B
3664:  MOVWF  x7D
3666:  MOVLW  34
3668:  MOVWF  x7C
366A:  CLRF   x7F
366C:  MOVLW  40
366E:  MOVWF  x7E
3670:  MOVLW  64
3672:  MOVWF  x80
3674:  MOVLB  0
3676:  CALL   1798
....................             BlinkLED();
367A:  CALL   13B2
....................             break;
367E:  MOVLB  1
3680:  BRA    3748
....................             
....................         case CMD_NORMAL_READ:
....................             usb_puts(1, cmd, 64, 100);    // echo string
3682:  MOVLW  01
3684:  MOVLB  1
3686:  MOVWF  x7B
3688:  MOVWF  x7D
368A:  MOVLW  34
368C:  MOVWF  x7C
368E:  CLRF   x7F
3690:  MOVLW  40
3692:  MOVWF  x7E
3694:  MOVLW  64
3696:  MOVWF  x80
3698:  MOVLB  0
369A:  CALL   1798
....................             MeasureSignals();
369E:  CALL   1B80
....................             DisplaySPO2();
36A2:  CALL   262C
....................             break;
36A6:  MOVLB  1
36A8:  BRA    3748
....................             
....................        case CMD_MEASURE_64:
....................             usb_puts(1, cmd, 64, 100);    // echo string
36AA:  MOVLW  01
36AC:  MOVLB  1
36AE:  MOVWF  x7B
36B0:  MOVWF  x7D
36B2:  MOVLW  34
36B4:  MOVWF  x7C
36B6:  CLRF   x7F
36B8:  MOVLW  40
36BA:  MOVWF  x7E
36BC:  MOVLW  64
36BE:  MOVWF  x80
36C0:  MOVLB  0
36C2:  CALL   1798
....................             MeasureSignals();
36C6:  CALL   1B80
....................             lcd_putc("\fData ready for\nupload");
36CA:  MOVLW  74
36CC:  MOVWF  FF6
36CE:  MOVLW  0F
36D0:  MOVWF  FF7
36D2:  CALL   1318
....................             break;
36D6:  MOVLB  1
36D8:  BRA    3748
....................       
....................        case CMD_MEASURE:       // Measure returns all 4 raw ADC values
....................             Measure();
36DA:  GOTO   2A4C
....................             usb_puts(1, cmd, 64, 100);    // echo string
36DE:  MOVLW  01
36E0:  MOVLB  1
36E2:  MOVWF  x7B
36E4:  MOVWF  x7D
36E6:  MOVLW  34
36E8:  MOVWF  x7C
36EA:  CLRF   x7F
36EC:  MOVLW  40
36EE:  MOVWF  x7E
36F0:  MOVLW  64
36F2:  MOVWF  x80
36F4:  MOVLB  0
36F6:  CALL   1798
....................             break;
36FA:  MOVLB  1
36FC:  BRA    3748
....................             
....................        case CMD_DISPLAY_VOLTAGES:
....................             usb_puts(1, cmd, 64, 100);    // echo string
36FE:  MOVLW  01
3700:  MOVLB  1
3702:  MOVWF  x7B
3704:  MOVWF  x7D
3706:  MOVLW  34
3708:  MOVWF  x7C
370A:  CLRF   x7F
370C:  MOVLW  40
370E:  MOVWF  x7E
3710:  MOVLW  64
3712:  MOVWF  x80
3714:  MOVLB  0
3716:  CALL   1798
....................             DisplayVoltage();
371A:  CALL   2BCE
....................             break;
371E:  MOVLB  1
3720:  BRA    3748
....................           
....................        case CMD_GET_DATA:
....................             LoadData();
3722:  BRA    32CC
....................             usb_puts(1, cmd, 64, 100);    // echo string
3724:  MOVLW  01
3726:  MOVLB  1
3728:  MOVWF  x7B
372A:  MOVWF  x7D
372C:  MOVLW  34
372E:  MOVWF  x7C
3730:  CLRF   x7F
3732:  MOVLW  40
3734:  MOVWF  x7E
3736:  MOVLW  64
3738:  MOVWF  x80
373A:  MOVLB  0
373C:  CALL   1798
....................             DataLoadStatus();
3740:  BRA    35D8
....................             break;
3742:  MOVLB  1
3744:  BRA    3748
3746:  MOVLB  1
....................   }
3748:  MOVLB  0
374A:  GOTO   3878 (RETURN)
.................... }
....................    
.................... ////////////////////////////////////////////////////////////////////////
.................... //  Set the mode register to internal clock
.................... //  The config register is fine with the default values
.................... //  which are +/- 4.095volts and single-ended inputs
.................... //////////////////////////////////////////////////////////////////
.................... void SetupMAX1303(void)
.................... {
....................  output_high(MAX1303_CS);
*
1338:  BCF    F92.3
133A:  BSF    F89.3
....................  output_low(MAX1303_SCLK);  // set the clk pin low
133C:  BCF    F94.0
133E:  BCF    F8B.0
....................  
....................  int8 ModeByte = 0b10101000;       //  use the internal clock
1340:  MOVLW  A8
1342:  MOVLB  1
1344:  MOVWF  x7B
....................  // write the mode byte
....................  output_low(MAX1303_CS);
1346:  BCF    F92.3
1348:  BCF    F89.3
....................  for(int8 i=0;i<8;i++) {
134A:  CLRF   x7C
134C:  MOVF   x7C,W
134E:  SUBLW  07
1350:  BNC   13A4
....................     if(bit_test(ModeByte, 7-i)) {
1352:  MOVLW  07
1354:  BSF    FD8.0
1356:  SUBFWB x7C,W
1358:  MOVWF  x7D
135A:  MOVFF  17B,00
135E:  MOVF   x7D,W
1360:  MOVWF  01
1362:  BZ    136C
1364:  BCF    FD8.0
1366:  RRCF   00,F
1368:  DECFSZ 01,F
136A:  BRA    1364
136C:  BTFSS  00.0
136E:  BRA    1376
....................       output_high(MAX1303_DIN); 
1370:  BCF    F92.4
1372:  BSF    F89.4
....................     }
1374:  BRA    137A
....................     else { 
....................       output_low(MAX1303_DIN);
1376:  BCF    F92.4
1378:  BCF    F89.4
....................     }
....................     delay_us(2);
137A:  MOVLW  07
137C:  MOVWF  00
137E:  DECFSZ 00,F
1380:  BRA    137E
1382:  BRA    1384
....................     MAX1303_CLKTIC;   // call clock tic macro
1384:  BCF    F94.0
1386:  BSF    F8B.0
1388:  MOVLW  27
138A:  MOVWF  00
138C:  DECFSZ 00,F
138E:  BRA    138C
1390:  BRA    1392
1392:  BCF    F94.0
1394:  BCF    F8B.0
....................     delay_us(2);
1396:  MOVLW  07
1398:  MOVWF  00
139A:  DECFSZ 00,F
139C:  BRA    139A
139E:  BRA    13A0
13A0:  INCF   x7C,F
13A2:  BRA    134C
....................  }
....................  output_high(MAX1303_CS);
13A4:  BCF    F92.3
13A6:  BSF    F89.3
....................  output_low(MAX1303_DIN);
13A8:  BCF    F92.4
13AA:  BCF    F89.4
13AC:  MOVLB  0
13AE:  GOTO   3820 (RETURN)
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////
.................... // Read a channel on the MAX1303 and return the value
.................... /////////////////////////////////////////////////////////////
.................... int16 ReadMAX1303(int8 channel)
*
1946:  MOVLW  80
1948:  MOVLB  1
194A:  MOVWF  xC7
.................... {
....................   int8 CommandByte = 0b10000000;
....................   channel = channel<<4; 
194C:  SWAPF  xC6,F
194E:  MOVLW  F0
1950:  ANDWF  xC6,F
....................   CommandByte = CommandByte|channel; 
1952:  MOVF   xC6,W
1954:  IORWF  xC7,F
....................   output_low(MAX1303_CS);
1956:  BCF    F92.3
1958:  BCF    F89.3
....................   for(int8 i=0;i<8;i++) {
195A:  CLRF   xC8
195C:  MOVF   xC8,W
195E:  SUBLW  07
1960:  BNC   19B4
....................     if(bit_test(CommandByte, 7-i)) {
1962:  MOVLW  07
1964:  BSF    FD8.0
1966:  SUBFWB xC8,W
1968:  MOVWF  xCC
196A:  MOVFF  1C7,00
196E:  MOVF   xCC,W
1970:  MOVWF  01
1972:  BZ    197C
1974:  BCF    FD8.0
1976:  RRCF   00,F
1978:  DECFSZ 01,F
197A:  BRA    1974
197C:  BTFSS  00.0
197E:  BRA    1986
....................        output_high(MAX1303_DIN); 
1980:  BCF    F92.4
1982:  BSF    F89.4
....................     }
1984:  BRA    198A
....................     else { 
....................       output_low(MAX1303_DIN);
1986:  BCF    F92.4
1988:  BCF    F89.4
....................     }
....................     delay_us(2);
198A:  MOVLW  07
198C:  MOVWF  00
198E:  DECFSZ 00,F
1990:  BRA    198E
1992:  BRA    1994
....................     MAX1303_CLKTIC;   
1994:  BCF    F94.0
1996:  BSF    F8B.0
1998:  MOVLW  27
199A:  MOVWF  00
199C:  DECFSZ 00,F
199E:  BRA    199C
19A0:  BRA    19A2
19A2:  BCF    F94.0
19A4:  BCF    F8B.0
....................     delay_us(2);
19A6:  MOVLW  07
19A8:  MOVWF  00
19AA:  DECFSZ 00,F
19AC:  BRA    19AA
19AE:  BRA    19B0
19B0:  INCF   xC8,F
19B2:  BRA    195C
....................  }
....................  
....................  output_low(MAX1303_DIN);
19B4:  BCF    F92.4
19B6:  BCF    F89.4
....................  output_high(MAX1303_CS);
19B8:  BCF    F92.3
19BA:  BSF    F89.3
....................  while(!input(MAX1303_SSTRB)); // wait for SSTRB to go high
19BC:  BSF    F92.5
19BE:  BTFSS  F80.5
19C0:  BRA    19BC
....................  output_low(MAX1303_CS);
19C2:  BCF    F92.3
19C4:  BCF    F89.3
....................  
....................  // read data
....................  int16 ADCval = 0;
19C6:  CLRF   xCA
19C8:  CLRF   xC9
....................  for(int8 i=0; i<16; i++)  {
19CA:  CLRF   xCB
19CC:  MOVF   xCB,W
19CE:  SUBLW  0F
19D0:  BNC   1A1E
....................     output_high(MAX1303_SCLK);   
19D2:  BCF    F94.0
19D4:  BSF    F8B.0
....................     delay_us(2);
19D6:  MOVLW  07
19D8:  MOVWF  00
19DA:  DECFSZ 00,F
19DC:  BRA    19DA
19DE:  BRA    19E0
....................     if(input(MAX1303_DOUT)) {
19E0:  BSF    F94.1
19E2:  BTFSS  F82.1
19E4:  BRA    1A0C
....................          bit_set(ADCval, 15-i);
19E6:  MOVLW  0F
19E8:  BSF    FD8.0
19EA:  SUBFWB xCB,W
19EC:  MOVWF  xCC
19EE:  CLRF   03
19F0:  MOVLW  01
19F2:  MOVWF  02
19F4:  MOVF   xCC,W
19F6:  MOVWF  00
19F8:  BZ    1A04
19FA:  BCF    FD8.0
19FC:  RLCF   02,F
19FE:  RLCF   03,F
1A00:  DECFSZ 00,F
1A02:  BRA    19FA
1A04:  MOVF   02,W
1A06:  IORWF  xC9,F
1A08:  MOVF   03,W
1A0A:  IORWF  xCA,F
....................     }
....................     output_low(MAX1303_SCLK);   
1A0C:  BCF    F94.0
1A0E:  BCF    F8B.0
....................     delay_us(2);
1A10:  MOVLW  07
1A12:  MOVWF  00
1A14:  DECFSZ 00,F
1A16:  BRA    1A14
1A18:  BRA    1A1A
1A1A:  INCF   xCB,F
1A1C:  BRA    19CC
....................  }
....................  output_high(MAX1303_CS);
1A1E:  BCF    F92.3
1A20:  BSF    F89.3
....................  return ADCval; 
1A22:  MOVFF  1C9,01
1A26:  MOVFF  1CA,02
1A2A:  MOVLB  0
1A2C:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////
.................... // Measure the 4 signals for ~6.4 seconds
.................... // Store the AC signals for analysis to find peak-peak value
.................... // Sum the DC signals in a 32 bit integer and then find the mean
.................... // NUM  = 64  measure ~10 times per second for ~6 seconds - 64 pts total
.................... // NAVE = 32 number of times to average the ac signal at each time point
.................... /////////////////////////////////////////////////////////////
.................... void MeasureSignals(void)
*
1B80:  MOVLB  1
1B82:  CLRF   x90
1B84:  CLRF   x8F
1B86:  CLRF   x8E
1B88:  CLRF   x8D
1B8A:  CLRF   x94
1B8C:  CLRF   x93
1B8E:  CLRF   x92
1B90:  CLRF   x91
.................... {
....................  char szBuf[18];
....................  int32 DC660sum = 0;
....................  int32 DC940sum = 0; 
....................  lcd_putc("\fMeasuring...    ");
1B92:  MOVLW  8C
1B94:  MOVWF  FF6
1B96:  MOVLW  0F
1B98:  MOVWF  FF7
1B9A:  MOVLB  0
1B9C:  CALL   1318
....................  int32 mean660 = 0;
....................  int32 mean940 = 0;
1BA0:  MOVLB  1
1BA2:  CLRF   x98
1BA4:  CLRF   x97
1BA6:  CLRF   x96
1BA8:  CLRF   x95
1BAA:  CLRF   x9C
1BAC:  CLRF   x9B
1BAE:  CLRF   x9A
1BB0:  CLRF   x99
....................  for(int8 i = 0; i < NUM; i++)  {
1BB2:  CLRF   x9D
1BB4:  MOVF   x9D,W
1BB6:  SUBLW  3F
1BB8:  BTFSS  FD8.0
1BBA:  BRA    1D78
....................     mean660 = 0;
1BBC:  CLRF   x98
1BBE:  CLRF   x97
1BC0:  CLRF   x96
1BC2:  CLRF   x95
....................     mean940 = 0;
1BC4:  CLRF   x9C
1BC6:  CLRF   x9B
1BC8:  CLRF   x9A
1BCA:  CLRF   x99
....................     for(int j = 0; j < NAVE; j++) {
1BCC:  CLRF   x9E
1BCE:  MOVF   x9E,W
1BD0:  SUBLW  1F
1BD2:  BNC   1C06
....................       mean940 += ReadMAX1303(0);
1BD4:  CLRF   xC6
1BD6:  MOVLB  0
1BD8:  RCALL  1946
1BDA:  MOVF   01,W
1BDC:  MOVLB  1
1BDE:  ADDWF  x99,F
1BE0:  MOVF   02,W
1BE2:  ADDWFC x9A,F
1BE4:  MOVLW  00
1BE6:  ADDWFC x9B,F
1BE8:  ADDWFC x9C,F
....................       mean660 += ReadMAX1303(2);
1BEA:  MOVLW  02
1BEC:  MOVWF  xC6
1BEE:  MOVLB  0
1BF0:  RCALL  1946
1BF2:  MOVF   01,W
1BF4:  MOVLB  1
1BF6:  ADDWF  x95,F
1BF8:  MOVF   02,W
1BFA:  ADDWFC x96,F
1BFC:  MOVLW  00
1BFE:  ADDWFC x97,F
1C00:  ADDWFC x98,F
1C02:  INCF   x9E,F
1C04:  BRA    1BCE
....................     }
....................     AC940[i] = (int16) (mean940 >> 5);   // NAVE is 32 or 2^5
1C06:  BCF    FD8.0
1C08:  RLCF   x9D,W
1C0A:  CLRF   03
1C0C:  ADDLW  B0
1C0E:  MOVWF  FE9
1C10:  MOVLW  00
1C12:  ADDWFC 03,W
1C14:  MOVWF  FEA
1C16:  RRCF   x9C,W
1C18:  MOVWF  03
1C1A:  RRCF   x9B,W
1C1C:  MOVWF  02
1C1E:  RRCF   x9A,W
1C20:  MOVWF  01
1C22:  RRCF   x99,W
1C24:  MOVWF  00
1C26:  RRCF   03,F
1C28:  RRCF   02,F
1C2A:  RRCF   01,F
1C2C:  RRCF   00,F
1C2E:  RRCF   03,F
1C30:  RRCF   02,F
1C32:  RRCF   01,F
1C34:  RRCF   00,F
1C36:  RRCF   03,F
1C38:  RRCF   02,F
1C3A:  RRCF   01,F
1C3C:  RRCF   00,F
1C3E:  RRCF   03,F
1C40:  RRCF   02,F
1C42:  RRCF   01,F
1C44:  RRCF   00,F
1C46:  MOVLW  07
1C48:  ANDWF  03,F
1C4A:  MOVFF  01,FEC
1C4E:  MOVF   FED,F
1C50:  MOVFF  00,FEF
....................     AC660[i] = (int16) (mean660 >> 5);
1C54:  BCF    FD8.0
1C56:  RLCF   x9D,W
1C58:  CLRF   03
1C5A:  ADDLW  30
1C5C:  MOVWF  FE9
1C5E:  MOVLW  00
1C60:  ADDWFC 03,W
1C62:  MOVWF  FEA
1C64:  RRCF   x98,W
1C66:  MOVWF  03
1C68:  RRCF   x97,W
1C6A:  MOVWF  02
1C6C:  RRCF   x96,W
1C6E:  MOVWF  01
1C70:  RRCF   x95,W
1C72:  MOVWF  00
1C74:  RRCF   03,F
1C76:  RRCF   02,F
1C78:  RRCF   01,F
1C7A:  RRCF   00,F
1C7C:  RRCF   03,F
1C7E:  RRCF   02,F
1C80:  RRCF   01,F
1C82:  RRCF   00,F
1C84:  RRCF   03,F
1C86:  RRCF   02,F
1C88:  RRCF   01,F
1C8A:  RRCF   00,F
1C8C:  RRCF   03,F
1C8E:  RRCF   02,F
1C90:  RRCF   01,F
1C92:  RRCF   00,F
1C94:  MOVLW  07
1C96:  ANDWF  03,F
1C98:  MOVFF  01,FEC
1C9C:  MOVF   FED,F
1C9E:  MOVFF  00,FEF
....................     DC940sum += ReadMAX1303(1);         // sum the DC value
1CA2:  MOVLW  01
1CA4:  MOVWF  xC6
1CA6:  MOVLB  0
1CA8:  RCALL  1946
1CAA:  MOVF   01,W
1CAC:  MOVLB  1
1CAE:  ADDWF  x91,F
1CB0:  MOVF   02,W
1CB2:  ADDWFC x92,F
1CB4:  MOVLW  00
1CB6:  ADDWFC x93,F
1CB8:  ADDWFC x94,F
....................     DC660sum += ReadMAX1303(3);
1CBA:  MOVLW  03
1CBC:  MOVWF  xC6
1CBE:  MOVLB  0
1CC0:  RCALL  1946
1CC2:  MOVF   01,W
1CC4:  MOVLB  1
1CC6:  ADDWF  x8D,F
1CC8:  MOVF   02,W
1CCA:  ADDWFC x8E,F
1CCC:  MOVLW  00
1CCE:  ADDWFC x8F,F
1CD0:  ADDWFC x90,F
....................     
....................     // measured the time to execute the above code and it was 2.4868 ms
....................     delay_ms(79);
1CD2:  MOVLW  4F
1CD4:  MOVWF  xC8
1CD6:  MOVLB  0
1CD8:  CALL   116C
....................     output_high(PIN_B4);
1CDC:  BCF    F93.4
1CDE:  BSF    F8A.4
....................     delay_us(500);
1CE0:  MOVLW  02
1CE2:  MOVLB  1
1CE4:  MOVWF  xA0
1CE6:  MOVLW  FA
1CE8:  MOVWF  xA1
1CEA:  MOVLB  0
1CEC:  BRA    1A2E
1CEE:  MOVLB  1
1CF0:  DECFSZ xA0,F
1CF2:  BRA    1CE6
....................     output_low(PIN_B4);
1CF4:  BCF    F93.4
1CF6:  BCF    F8A.4
....................     sprintf(szBuf, "\n  ---- %02u ----  ", i);     // display i
1CF8:  MOVLW  01
1CFA:  MOVWF  x7A
1CFC:  MOVLW  7B
1CFE:  MOVWF  x79
1D00:  MOVLW  9E
1D02:  MOVWF  FF6
1D04:  MOVLW  0F
1D06:  MOVWF  FF7
1D08:  MOVLW  08
1D0A:  MOVWF  xC6
1D0C:  MOVLB  0
1D0E:  RCALL  1A76
1D10:  MOVFF  19D,1A0
1D14:  MOVLW  01
1D16:  MOVLB  1
1D18:  MOVWF  xA1
1D1A:  MOVLB  0
1D1C:  BRA    1ACA
1D1E:  MOVLW  AA
1D20:  MOVWF  FF6
1D22:  MOVLW  0F
1D24:  MOVWF  FF7
1D26:  MOVLW  07
1D28:  MOVLB  1
1D2A:  MOVWF  xC6
1D2C:  MOVLB  0
1D2E:  RCALL  1A76
....................     for(int8 c = 0; c < strlen(szBuf);c++) {
1D30:  MOVLB  1
1D32:  CLRF   x9F
1D34:  MOVLW  01
1D36:  MOVWF  xC7
1D38:  MOVLW  7B
1D3A:  MOVWF  xC6
1D3C:  MOVLB  0
1D3E:  RCALL  1B48
1D40:  MOVFF  02,03
1D44:  MOVF   01,W
1D46:  MOVF   03,F
1D48:  BNZ   1D54
1D4A:  MOVF   01,W
1D4C:  MOVLB  1
1D4E:  SUBWF  x9F,W
1D50:  BC    1D74
1D52:  MOVLB  0
....................          lcd_putc(szBuf[c]);
1D54:  CLRF   03
1D56:  MOVLB  1
1D58:  MOVF   x9F,W
1D5A:  ADDLW  7B
1D5C:  MOVWF  FE9
1D5E:  MOVLW  01
1D60:  ADDWFC 03,W
1D62:  MOVWF  FEA
1D64:  MOVFF  FEF,1C7
1D68:  MOVLB  0
1D6A:  CALL   12BE
1D6E:  MOVLB  1
1D70:  INCF   x9F,F
1D72:  BRA    1D34
....................     }
1D74:  INCF   x9D,F
1D76:  BRA    1BB4
....................  }
....................  DC660 = (int16) (DC660sum >> 6);   // divide by 64 (2^6) )to get the 
1D78:  RRCF   x90,W
1D7A:  MOVWF  03
1D7C:  RRCF   x8F,W
1D7E:  MOVWF  02
1D80:  RRCF   x8E,W
1D82:  MOVWF  01
1D84:  RRCF   x8D,W
1D86:  MOVWF  00
1D88:  RRCF   03,F
1D8A:  RRCF   02,F
1D8C:  RRCF   01,F
1D8E:  RRCF   00,F
1D90:  RRCF   03,F
1D92:  RRCF   02,F
1D94:  RRCF   01,F
1D96:  RRCF   00,F
1D98:  RRCF   03,F
1D9A:  RRCF   02,F
1D9C:  RRCF   01,F
1D9E:  RRCF   00,F
1DA0:  RRCF   03,F
1DA2:  RRCF   02,F
1DA4:  RRCF   01,F
1DA6:  RRCF   00,F
1DA8:  RRCF   03,F
1DAA:  RRCF   02,F
1DAC:  RRCF   01,F
1DAE:  RRCF   00,F
1DB0:  MOVLW  03
1DB2:  ANDWF  03,F
1DB4:  MOVFF  01,131
1DB8:  MOVFF  00,130
....................  DC940 = (int16) (DC940sum >> 6);   // average DC value
1DBC:  RRCF   x94,W
1DBE:  MOVWF  03
1DC0:  RRCF   x93,W
1DC2:  MOVWF  02
1DC4:  RRCF   x92,W
1DC6:  MOVWF  01
1DC8:  RRCF   x91,W
1DCA:  MOVWF  00
1DCC:  RRCF   03,F
1DCE:  RRCF   02,F
1DD0:  RRCF   01,F
1DD2:  RRCF   00,F
1DD4:  RRCF   03,F
1DD6:  RRCF   02,F
1DD8:  RRCF   01,F
1DDA:  RRCF   00,F
1DDC:  RRCF   03,F
1DDE:  RRCF   02,F
1DE0:  RRCF   01,F
1DE2:  RRCF   00,F
1DE4:  RRCF   03,F
1DE6:  RRCF   02,F
1DE8:  RRCF   01,F
1DEA:  RRCF   00,F
1DEC:  RRCF   03,F
1DEE:  RRCF   02,F
1DF0:  RRCF   01,F
1DF2:  RRCF   00,F
1DF4:  MOVLW  03
1DF6:  ANDWF  03,F
1DF8:  MOVFF  01,133
1DFC:  MOVFF  00,132
1E00:  MOVLB  0
1E02:  RETURN 0
.................... }
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////
.................... // Measure the 4 signals and return 
.................... // ch0 = AC940
.................... // ch1 = DC940
.................... // ch2 = AC660
.................... // ch3 = DC660
.................... // NAVE_SINGLE  = 4    number of times to average the signals for measure command
.................... /////////////////////////////////////////////////////////////
.................... void Measure(void)
*
2A4C:  MOVLB  1
2A4E:  CLRF   x7E
2A50:  CLRF   x7D
2A52:  CLRF   x7C
2A54:  CLRF   x7B
2A56:  CLRF   x82
2A58:  CLRF   x81
2A5A:  CLRF   x80
2A5C:  CLRF   x7F
2A5E:  CLRF   x86
2A60:  CLRF   x85
2A62:  CLRF   x84
2A64:  CLRF   x83
2A66:  CLRF   x8A
2A68:  CLRF   x89
2A6A:  CLRF   x88
2A6C:  CLRF   x87
.................... {
....................    //output_high(MEASURE_PIN);
....................    int32 AC940sum = 0;
....................    int32 DC940sum = 0; 
....................    int32 DC660sum = 0;
....................    int32 AC660sum = 0;
....................    for(int i = 0; i < 4; i++) {
2A6E:  CLRF   x8B
2A70:  MOVF   x8B,W
2A72:  SUBLW  03
2A74:  BNC   2B18
....................       AC940sum += (int32) ReadMAX1303(0);
2A76:  CLRF   xC6
2A78:  MOVLB  0
2A7A:  CALL   1946
2A7E:  MOVFF  01,00
2A82:  MOVFF  02,01
2A86:  CLRF   02
2A88:  CLRF   03
2A8A:  MOVF   00,W
2A8C:  MOVLB  1
2A8E:  ADDWF  x7B,F
2A90:  MOVF   01,W
2A92:  ADDWFC x7C,F
2A94:  MOVF   02,W
2A96:  ADDWFC x7D,F
2A98:  MOVF   03,W
2A9A:  ADDWFC x7E,F
....................       DC940sum += (int32) ReadMAX1303(1);
2A9C:  MOVLW  01
2A9E:  MOVWF  xC6
2AA0:  MOVLB  0
2AA2:  CALL   1946
2AA6:  MOVFF  01,00
2AAA:  MOVFF  02,01
2AAE:  CLRF   02
2AB0:  CLRF   03
2AB2:  MOVF   00,W
2AB4:  MOVLB  1
2AB6:  ADDWF  x7F,F
2AB8:  MOVF   01,W
2ABA:  ADDWFC x80,F
2ABC:  MOVF   02,W
2ABE:  ADDWFC x81,F
2AC0:  MOVF   03,W
2AC2:  ADDWFC x82,F
....................       AC660sum += (int32) ReadMAX1303(2);
2AC4:  MOVLW  02
2AC6:  MOVWF  xC6
2AC8:  MOVLB  0
2ACA:  CALL   1946
2ACE:  MOVFF  01,00
2AD2:  MOVFF  02,01
2AD6:  CLRF   02
2AD8:  CLRF   03
2ADA:  MOVF   00,W
2ADC:  MOVLB  1
2ADE:  ADDWF  x87,F
2AE0:  MOVF   01,W
2AE2:  ADDWFC x88,F
2AE4:  MOVF   02,W
2AE6:  ADDWFC x89,F
2AE8:  MOVF   03,W
2AEA:  ADDWFC x8A,F
....................       DC660sum += (int32) ReadMAX1303(3);
2AEC:  MOVLW  03
2AEE:  MOVWF  xC6
2AF0:  MOVLB  0
2AF2:  CALL   1946
2AF6:  MOVFF  01,00
2AFA:  MOVFF  02,01
2AFE:  CLRF   02
2B00:  CLRF   03
2B02:  MOVF   00,W
2B04:  MOVLB  1
2B06:  ADDWF  x83,F
2B08:  MOVF   01,W
2B0A:  ADDWFC x84,F
2B0C:  MOVF   02,W
2B0E:  ADDWFC x85,F
2B10:  MOVF   03,W
2B12:  ADDWFC x86,F
2B14:  INCF   x8B,F
2B16:  BRA    2A70
....................    }
....................   int16 _AC940 = (int16)(AC940sum >> 2); 
2B18:  RRCF   x7E,W
2B1A:  MOVWF  03
2B1C:  RRCF   x7D,W
2B1E:  MOVWF  02
2B20:  RRCF   x7C,W
2B22:  MOVWF  01
2B24:  RRCF   x7B,W
2B26:  MOVWF  00
2B28:  RRCF   03,F
2B2A:  RRCF   02,F
2B2C:  RRCF   01,F
2B2E:  RRCF   00,F
2B30:  MOVLW  3F
2B32:  ANDWF  03,F
2B34:  MOVFF  01,18D
2B38:  MOVFF  00,18C
....................   DC940 = (int16) (DC940sum >> 2);   // average values
2B3C:  RRCF   x82,W
2B3E:  MOVWF  03
2B40:  RRCF   x81,W
2B42:  MOVWF  02
2B44:  RRCF   x80,W
2B46:  MOVWF  01
2B48:  RRCF   x7F,W
2B4A:  MOVWF  00
2B4C:  RRCF   03,F
2B4E:  RRCF   02,F
2B50:  RRCF   01,F
2B52:  RRCF   00,F
2B54:  MOVLW  3F
2B56:  ANDWF  03,F
2B58:  MOVFF  01,133
2B5C:  MOVFF  00,132
....................   int16 _AC660 = (int16)(AC660sum >> 2);
2B60:  RRCF   x8A,W
2B62:  MOVWF  03
2B64:  RRCF   x89,W
2B66:  MOVWF  02
2B68:  RRCF   x88,W
2B6A:  MOVWF  01
2B6C:  RRCF   x87,W
2B6E:  MOVWF  00
2B70:  RRCF   03,F
2B72:  RRCF   02,F
2B74:  RRCF   01,F
2B76:  RRCF   00,F
2B78:  MOVLW  3F
2B7A:  ANDWF  03,F
2B7C:  MOVFF  01,18F
2B80:  MOVFF  00,18E
....................   DC660 = (int16) (DC660sum >> 2);   // divide by 4
2B84:  RRCF   x86,W
2B86:  MOVWF  03
2B88:  RRCF   x85,W
2B8A:  MOVWF  02
2B8C:  RRCF   x84,W
2B8E:  MOVWF  01
2B90:  RRCF   x83,W
2B92:  MOVWF  00
2B94:  RRCF   03,F
2B96:  RRCF   02,F
2B98:  RRCF   01,F
2B9A:  RRCF   00,F
2B9C:  MOVLW  3F
2B9E:  ANDWF  03,F
2BA0:  MOVFF  01,131
2BA4:  MOVFF  00,130
....................   cmd[0] = make8(_AC940, 0);
2BA8:  MOVFF  18C,134
....................   cmd[1] = make8(_AC940, 1);
2BAC:  MOVFF  18D,135
....................   cmd[2] = make8(DC940, 0);
2BB0:  MOVFF  132,136
....................   cmd[3] = make8(DC940, 1);
2BB4:  MOVFF  133,137
....................   cmd[4] = make8(_AC660, 0);
2BB8:  MOVFF  18E,138
....................   cmd[5] = make8(_AC660, 1);
2BBC:  MOVFF  18F,139
....................   cmd[6] = make8(DC660, 0);
2BC0:  MOVFF  130,13A
....................   cmd[7] = make8(DC660, 1);
2BC4:  MOVFF  131,13B
2BC8:  MOVLB  0
2BCA:  GOTO   36DE (RETURN)
....................  // output_low(MEASURE_PIN);
.................... }
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////
.................... // Calulate and display the SPO2 value
.................... // Uses a simple max and min search and the difference
.................... // is taken as the AC amplitude.
.................... /////////////////////////////////////////////////////////////
.................... void  DisplaySPO2(void)
*
262C:  MOVLB  1
262E:  CLRF   x7C
2630:  CLRF   x7B
2632:  SETF   x7E
2634:  SETF   x7D
2636:  CLRF   x80
2638:  CLRF   x7F
263A:  SETF   x82
263C:  SETF   x81
.................... {
....................     // find the min and max of the AC signals
....................     int16 AC660max = 0; 
....................     int16 AC660min = 65535;
....................     int16 AC940max = 0; 
....................     int16 AC940min = 65535;
....................    
....................     for(int8 i = 0; i < NUM; i++) {
263E:  CLRF   x83
2640:  MOVF   x83,W
2642:  SUBLW  3F
2644:  BTFSS  FD8.0
2646:  BRA    2784
....................         AC660max = (AC660max < AC660[i]) ? AC660[i] : AC660max; 
2648:  BCF    FD8.0
264A:  RLCF   x83,W
264C:  CLRF   03
264E:  ADDLW  30
2650:  MOVWF  FE9
2652:  MOVLW  00
2654:  ADDWFC 03,W
2656:  MOVWF  FEA
2658:  MOVFF  FEC,03
265C:  MOVF   FED,F
265E:  MOVFF  FEF,01
2662:  MOVF   x7C,W
2664:  SUBWF  03,W
2666:  BNC   268A
2668:  BNZ   2670
266A:  MOVF   01,W
266C:  SUBWF  x7B,W
266E:  BC    268A
2670:  BCF    FD8.0
2672:  RLCF   x83,W
2674:  CLRF   03
2676:  ADDLW  30
2678:  MOVWF  FE9
267A:  MOVLW  00
267C:  ADDWFC 03,W
267E:  MOVWF  FEA
2680:  MOVFF  FEC,03
2684:  MOVF   FED,F
2686:  MOVF   FEF,W
2688:  BRA    2690
268A:  MOVFF  17C,03
268E:  MOVF   x7B,W
2690:  MOVWF  x7B
2692:  MOVFF  03,17C
....................         AC940max = (AC940max < AC940[i]) ? AC940[i] : AC940max; 
2696:  BCF    FD8.0
2698:  RLCF   x83,W
269A:  CLRF   03
269C:  ADDLW  B0
269E:  MOVWF  FE9
26A0:  MOVLW  00
26A2:  ADDWFC 03,W
26A4:  MOVWF  FEA
26A6:  MOVFF  FEC,03
26AA:  MOVF   FED,F
26AC:  MOVFF  FEF,01
26B0:  MOVF   x80,W
26B2:  SUBWF  03,W
26B4:  BNC   26D8
26B6:  BNZ   26BE
26B8:  MOVF   01,W
26BA:  SUBWF  x7F,W
26BC:  BC    26D8
26BE:  BCF    FD8.0
26C0:  RLCF   x83,W
26C2:  CLRF   03
26C4:  ADDLW  B0
26C6:  MOVWF  FE9
26C8:  MOVLW  00
26CA:  ADDWFC 03,W
26CC:  MOVWF  FEA
26CE:  MOVFF  FEC,03
26D2:  MOVF   FED,F
26D4:  MOVF   FEF,W
26D6:  BRA    26DE
26D8:  MOVFF  180,03
26DC:  MOVF   x7F,W
26DE:  MOVWF  x7F
26E0:  MOVFF  03,180
....................         AC660min = (AC660min > AC660[i]) ? AC660[i] : AC660min; 
26E4:  BCF    FD8.0
26E6:  RLCF   x83,W
26E8:  CLRF   03
26EA:  ADDLW  30
26EC:  MOVWF  FE9
26EE:  MOVLW  00
26F0:  ADDWFC 03,W
26F2:  MOVWF  FEA
26F4:  MOVFF  FEC,03
26F8:  MOVF   FED,F
26FA:  MOVFF  FEF,01
26FE:  MOVF   03,W
2700:  SUBWF  x7E,W
2702:  BNC   2726
2704:  BNZ   270C
2706:  MOVF   x7D,W
2708:  SUBWF  01,W
270A:  BC    2726
270C:  BCF    FD8.0
270E:  RLCF   x83,W
2710:  CLRF   03
2712:  ADDLW  30
2714:  MOVWF  FE9
2716:  MOVLW  00
2718:  ADDWFC 03,W
271A:  MOVWF  FEA
271C:  MOVFF  FEC,03
2720:  MOVF   FED,F
2722:  MOVF   FEF,W
2724:  BRA    272C
2726:  MOVFF  17E,03
272A:  MOVF   x7D,W
272C:  MOVWF  x7D
272E:  MOVFF  03,17E
....................         AC940min = (AC940min > AC940[i]) ? AC940[i] : AC940min; 
2732:  BCF    FD8.0
2734:  RLCF   x83,W
2736:  CLRF   03
2738:  ADDLW  B0
273A:  MOVWF  FE9
273C:  MOVLW  00
273E:  ADDWFC 03,W
2740:  MOVWF  FEA
2742:  MOVFF  FEC,03
2746:  MOVF   FED,F
2748:  MOVFF  FEF,01
274C:  MOVF   03,W
274E:  SUBWF  x82,W
2750:  BNC   2774
2752:  BNZ   275A
2754:  MOVF   x81,W
2756:  SUBWF  01,W
2758:  BC    2774
275A:  BCF    FD8.0
275C:  RLCF   x83,W
275E:  CLRF   03
2760:  ADDLW  B0
2762:  MOVWF  FE9
2764:  MOVLW  00
2766:  ADDWFC 03,W
2768:  MOVWF  FEA
276A:  MOVFF  FEC,03
276E:  MOVF   FED,F
2770:  MOVF   FEF,W
2772:  BRA    277A
2774:  MOVFF  182,03
2778:  MOVF   x81,W
277A:  MOVWF  x81
277C:  MOVFF  03,182
2780:  INCF   x83,F
2782:  BRA    2640
....................     }
....................    
....................     int16 AC660diff = AC660max - AC660min;
....................     int16 AC940diff = AC940max - AC940min;
....................     
....................     // You need to type cast as floats
....................     float Numerator = (float) AC660diff * (float) DC940;
....................     float Denominator = (float) AC940diff * (float) DC660;
....................     
....................     // Calculate R
....................     float R = Numerator/Denominator;   
2784:  MOVF   x7D,W
2786:  SUBWF  x7B,W
2788:  MOVWF  x84
278A:  MOVF   x7E,W
278C:  SUBWFB x7C,W
278E:  MOVWF  x85
2790:  MOVF   x81,W
2792:  SUBWF  x7F,W
2794:  MOVWF  x86
2796:  MOVF   x82,W
2798:  SUBWFB x80,W
279A:  MOVWF  x87
279C:  MOVFF  185,1C9
27A0:  MOVFF  184,1C8
27A4:  MOVLB  0
27A6:  CALL   1E04
27AA:  MOVFF  03,1B8
27AE:  MOVFF  02,1B7
27B2:  MOVFF  01,1B6
27B6:  MOVFF  00,1B5
27BA:  MOVFF  133,1C9
27BE:  MOVFF  132,1C8
27C2:  CALL   1E04
27C6:  MOVFF  1B8,1D6
27CA:  MOVFF  1B7,1D5
27CE:  MOVFF  1B6,1D4
27D2:  MOVFF  1B5,1D3
27D6:  MOVFF  03,1DA
27DA:  MOVFF  02,1D9
27DE:  MOVFF  01,1D8
27E2:  MOVFF  00,1D7
27E6:  CALL   1E3A
27EA:  MOVFF  03,18B
27EE:  MOVFF  02,18A
27F2:  MOVFF  01,189
27F6:  MOVFF  00,188
27FA:  MOVFF  187,1C9
27FE:  MOVFF  186,1C8
2802:  CALL   1E04
2806:  MOVFF  03,1B8
280A:  MOVFF  02,1B7
280E:  MOVFF  01,1B6
2812:  MOVFF  00,1B5
2816:  MOVFF  131,1C9
281A:  MOVFF  130,1C8
281E:  CALL   1E04
2822:  MOVFF  1B8,1D6
2826:  MOVFF  1B7,1D5
282A:  MOVFF  1B6,1D4
282E:  MOVFF  1B5,1D3
2832:  MOVFF  03,1DA
2836:  MOVFF  02,1D9
283A:  MOVFF  01,1D8
283E:  MOVFF  00,1D7
2842:  CALL   1E3A
2846:  MOVFF  03,18F
284A:  MOVFF  02,18E
284E:  MOVFF  01,18D
2852:  MOVFF  00,18C
2856:  MOVFF  18B,1B8
285A:  MOVFF  18A,1B7
285E:  MOVFF  189,1B6
2862:  MOVFF  188,1B5
2866:  MOVFF  18F,1BC
286A:  MOVFF  18E,1BB
286E:  MOVFF  18D,1BA
2872:  MOVFF  18C,1B9
2876:  GOTO   1F30
287A:  MOVFF  03,193
287E:  MOVFF  02,192
2882:  MOVFF  01,191
2886:  MOVFF  00,190
....................     
....................     // estimate SP02 using the standard industry formula
....................     spo2 = 110.0 - 25.0 * R;
288A:  MOVLB  1
288C:  CLRF   xD6
288E:  CLRF   xD5
2890:  MOVLW  48
2892:  MOVWF  xD4
2894:  MOVLW  83
2896:  MOVWF  xD3
2898:  MOVFF  193,1DA
289C:  MOVFF  192,1D9
28A0:  MOVFF  191,1D8
28A4:  MOVFF  190,1D7
28A8:  MOVLB  0
28AA:  CALL   1E3A
28AE:  BSF    FD8.1
28B0:  MOVLB  1
28B2:  CLRF   xD1
28B4:  CLRF   xD0
28B6:  MOVLW  5C
28B8:  MOVWF  xCF
28BA:  MOVLW  85
28BC:  MOVWF  xCE
28BE:  MOVFF  03,1D5
28C2:  MOVFF  02,1D4
28C6:  MOVFF  01,1D3
28CA:  MOVFF  00,1D2
28CE:  MOVLB  0
28D0:  CALL   2090
28D4:  MOVFF  03,178
28D8:  MOVFF  02,177
28DC:  MOVFF  01,176
28E0:  MOVFF  00,175
....................     
....................     // display the result and wait 3 seconds so it can be read
....................     char szBuf[32] = { 0 };
28E4:  MOVLB  1
28E6:  CLRF   x94
28E8:  CLRF   x95
28EA:  CLRF   x96
28EC:  CLRF   x97
28EE:  CLRF   x98
28F0:  CLRF   x99
28F2:  CLRF   x9A
28F4:  CLRF   x9B
28F6:  CLRF   x9C
28F8:  CLRF   x9D
28FA:  CLRF   x9E
28FC:  CLRF   x9F
28FE:  CLRF   xA0
2900:  CLRF   xA1
2902:  CLRF   xA2
2904:  CLRF   xA3
2906:  CLRF   xA4
2908:  CLRF   xA5
290A:  CLRF   xA6
290C:  CLRF   xA7
290E:  CLRF   xA8
2910:  CLRF   xA9
2912:  CLRF   xAA
2914:  CLRF   xAB
2916:  CLRF   xAC
2918:  CLRF   xAD
291A:  CLRF   xAE
291C:  CLRF   xAF
291E:  CLRF   xB0
2920:  CLRF   xB1
2922:  CLRF   xB2
2924:  CLRF   xB3
....................     if(spo2 > 101.0|| spo2 < 80.0) {
2926:  CLRF   xB8
2928:  CLRF   xB7
292A:  MOVLW  4A
292C:  MOVWF  xB6
292E:  MOVLW  85
2930:  MOVWF  xB5
2932:  MOVFF  178,1BC
2936:  MOVFF  177,1BB
293A:  MOVFF  176,1BA
293E:  MOVFF  175,1B9
2942:  MOVLB  0
2944:  RCALL  2308
2946:  BC    296C
2948:  MOVFF  178,1B8
294C:  MOVFF  177,1B7
2950:  MOVFF  176,1B6
2954:  MOVFF  175,1B5
2958:  MOVLB  1
295A:  CLRF   xBC
295C:  CLRF   xBB
295E:  MOVLW  20
2960:  MOVWF  xBA
2962:  MOVLW  85
2964:  MOVWF  xB9
2966:  MOVLB  0
2968:  RCALL  2308
296A:  BNC   2984
....................          sprintf(szBuf,"\f SPO2 Read Error");
296C:  MOVLW  01
296E:  MOVLB  1
2970:  MOVWF  x7A
2972:  MOVLW  94
2974:  MOVWF  x79
2976:  MOVLW  B2
2978:  MOVWF  FF6
297A:  MOVLW  0F
297C:  MOVWF  FF7
297E:  MOVLB  0
2980:  BRA    2382
....................     }
2982:  BRA    29EE
....................     else {
....................         sprintf(szBuf,"\f SPO2 = %3.2f\n  R = %2.4f",spo2, R);
2984:  MOVLW  01
2986:  MOVLB  1
2988:  MOVWF  x7A
298A:  MOVLW  94
298C:  MOVWF  x79
298E:  MOVLW  C4
2990:  MOVWF  FF6
2992:  MOVLW  0F
2994:  MOVWF  FF7
2996:  MOVLW  09
2998:  MOVWF  xC6
299A:  MOVLB  0
299C:  CALL   1A76
29A0:  MOVLW  02
29A2:  MOVWF  FE9
29A4:  MOVFF  178,1C9
29A8:  MOVFF  177,1C8
29AC:  MOVFF  176,1C7
29B0:  MOVFF  175,1C6
29B4:  MOVLB  1
29B6:  MOVWF  xCA
29B8:  MOVLB  0
29BA:  RCALL  247E
29BC:  MOVLW  D2
29BE:  MOVWF  FF6
29C0:  MOVLW  0F
29C2:  MOVWF  FF7
29C4:  MOVLW  07
29C6:  MOVLB  1
29C8:  MOVWF  xC6
29CA:  MOVLB  0
29CC:  CALL   1A76
29D0:  MOVLW  89
29D2:  MOVWF  FE9
29D4:  MOVFF  193,1C9
29D8:  MOVFF  192,1C8
29DC:  MOVFF  191,1C7
29E0:  MOVFF  190,1C6
29E4:  MOVLW  04
29E6:  MOVLB  1
29E8:  MOVWF  xCA
29EA:  MOVLB  0
29EC:  RCALL  247E
....................     }
....................     for(int8 i = 0; i < strlen(szBuf); i++) lcd_putc(szBuf[i]);
29EE:  MOVLB  1
29F0:  CLRF   xB4
29F2:  MOVLW  01
29F4:  MOVWF  xC7
29F6:  MOVLW  94
29F8:  MOVWF  xC6
29FA:  MOVLB  0
29FC:  CALL   1B48
2A00:  MOVFF  02,03
2A04:  MOVF   01,W
2A06:  MOVF   03,F
2A08:  BNZ   2A14
2A0A:  MOVF   01,W
2A0C:  MOVLB  1
2A0E:  SUBWF  xB4,W
2A10:  BC    2A34
2A12:  MOVLB  0
2A14:  CLRF   03
2A16:  MOVLB  1
2A18:  MOVF   xB4,W
2A1A:  ADDLW  94
2A1C:  MOVWF  FE9
2A1E:  MOVLW  01
2A20:  ADDWFC 03,W
2A22:  MOVWF  FEA
2A24:  MOVFF  FEF,1C7
2A28:  MOVLB  0
2A2A:  CALL   12BE
2A2E:  MOVLB  1
2A30:  INCF   xB4,F
2A32:  BRA    29F2
....................     delay_ms(3000);  // delay so the value can be read
2A34:  MOVLW  0C
2A36:  MOVWF  xB5
2A38:  MOVLW  FA
2A3A:  MOVWF  xC8
2A3C:  MOVLB  0
2A3E:  CALL   116C
2A42:  MOVLB  1
2A44:  DECFSZ xB5,F
2A46:  BRA    2A38
2A48:  MOVLB  0
2A4A:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////
.................... // Display the voltage readings if PIN_B5 is held high
.................... /////////////////////////////////////////////////////////////
.................... void  DisplayVoltage(void)
.................... {
....................    float voltage[4];
....................    char  szBuf[32];
....................    int32 mean[4] = {0};
*
2BCE:  MOVLB  1
2BD0:  CLRF   xAB
2BD2:  CLRF   xAC
2BD4:  CLRF   xAD
2BD6:  CLRF   xAE
2BD8:  CLRF   xAF
2BDA:  CLRF   xB0
2BDC:  CLRF   xB1
2BDE:  CLRF   xB2
2BE0:  CLRF   xB3
2BE2:  CLRF   xB4
2BE4:  CLRF   xB5
2BE6:  CLRF   xB6
2BE8:  CLRF   xB7
2BEA:  CLRF   xB8
2BEC:  CLRF   xB9
2BEE:  CLRF   xBA
....................    int16 val[4] = {0}; 
2BF0:  CLRF   xBB
2BF2:  CLRF   xBC
2BF4:  CLRF   xBD
2BF6:  CLRF   xBE
2BF8:  CLRF   xBF
2BFA:  CLRF   xC0
2BFC:  CLRF   xC1
2BFE:  CLRF   xC2
....................    
....................    for(int i = 0; i < 4; i++) {
2C00:  CLRF   xC3
2C02:  MOVF   xC3,W
2C04:  SUBLW  03
2C06:  BNC   2CAA
....................       mean[0] += (int32) ReadMAX1303(0);
2C08:  CLRF   xC6
2C0A:  MOVLB  0
2C0C:  CALL   1946
2C10:  MOVFF  01,00
2C14:  MOVFF  02,01
2C18:  CLRF   02
2C1A:  CLRF   03
2C1C:  MOVF   00,W
2C1E:  MOVLB  1
2C20:  ADDWF  xAB,F
2C22:  MOVF   01,W
2C24:  ADDWFC xAC,F
2C26:  MOVF   02,W
2C28:  ADDWFC xAD,F
2C2A:  MOVF   03,W
2C2C:  ADDWFC xAE,F
....................       mean[1] += (int32) ReadMAX1303(1);
2C2E:  MOVLW  01
2C30:  MOVWF  xC6
2C32:  MOVLB  0
2C34:  CALL   1946
2C38:  MOVFF  01,00
2C3C:  MOVFF  02,01
2C40:  CLRF   02
2C42:  CLRF   03
2C44:  MOVF   00,W
2C46:  MOVLB  1
2C48:  ADDWF  xAF,F
2C4A:  MOVF   01,W
2C4C:  ADDWFC xB0,F
2C4E:  MOVF   02,W
2C50:  ADDWFC xB1,F
2C52:  MOVF   03,W
2C54:  ADDWFC xB2,F
....................       mean[2] += (int32) ReadMAX1303(2);
2C56:  MOVLW  02
2C58:  MOVWF  xC6
2C5A:  MOVLB  0
2C5C:  CALL   1946
2C60:  MOVFF  01,00
2C64:  MOVFF  02,01
2C68:  CLRF   02
2C6A:  CLRF   03
2C6C:  MOVF   00,W
2C6E:  MOVLB  1
2C70:  ADDWF  xB3,F
2C72:  MOVF   01,W
2C74:  ADDWFC xB4,F
2C76:  MOVF   02,W
2C78:  ADDWFC xB5,F
2C7A:  MOVF   03,W
2C7C:  ADDWFC xB6,F
....................       mean[3] += (int32) ReadMAX1303(3);
2C7E:  MOVLW  03
2C80:  MOVWF  xC6
2C82:  MOVLB  0
2C84:  CALL   1946
2C88:  MOVFF  01,00
2C8C:  MOVFF  02,01
2C90:  CLRF   02
2C92:  CLRF   03
2C94:  MOVF   00,W
2C96:  MOVLB  1
2C98:  ADDWF  xB7,F
2C9A:  MOVF   01,W
2C9C:  ADDWFC xB8,F
2C9E:  MOVF   02,W
2CA0:  ADDWFC xB9,F
2CA2:  MOVF   03,W
2CA4:  ADDWFC xBA,F
2CA6:  INCF   xC3,F
2CA8:  BRA    2C02
....................     }
....................     
....................    for(int8 i = 0; i < 4; i++) {
2CAA:  CLRF   xC4
2CAC:  MOVF   xC4,W
2CAE:  SUBLW  03
2CB0:  BTFSS  FD8.0
2CB2:  BRA    2DE0
....................        val[i] = (int16) (mean[i] >> 2);
2CB4:  BCF    FD8.0
2CB6:  RLCF   xC4,W
2CB8:  CLRF   03
2CBA:  ADDLW  BB
2CBC:  MOVWF  01
2CBE:  MOVLW  01
2CC0:  ADDWFC 03,F
2CC2:  MOVFF  01,1C6
2CC6:  MOVFF  03,1C7
2CCA:  MOVF   xC4,W
2CCC:  MULLW  04
2CCE:  MOVF   FF3,W
2CD0:  CLRF   03
2CD2:  ADDLW  AB
2CD4:  MOVWF  FE9
2CD6:  MOVLW  01
2CD8:  ADDWFC 03,W
2CDA:  MOVWF  FEA
2CDC:  MOVFF  FEF,1C8
2CE0:  MOVFF  FEC,1C9
2CE4:  MOVFF  FEC,1CA
2CE8:  MOVFF  FEC,1CB
2CEC:  RRCF   xCB,W
2CEE:  MOVWF  03
2CF0:  RRCF   xCA,W
2CF2:  MOVWF  02
2CF4:  RRCF   xC9,W
2CF6:  MOVWF  01
2CF8:  RRCF   xC8,W
2CFA:  MOVWF  00
2CFC:  RRCF   03,F
2CFE:  RRCF   02,F
2D00:  RRCF   01,F
2D02:  RRCF   00,F
2D04:  MOVLW  3F
2D06:  ANDWF  03,F
2D08:  MOVFF  1C7,FEA
2D0C:  MOVFF  1C6,FE9
2D10:  MOVFF  01,FEC
2D14:  MOVF   FED,F
2D16:  MOVFF  00,FEF
....................        voltage[i] = V_CONVERT * ((float) val[i]  - ADC_OFFSET); 
2D1A:  MOVF   xC4,W
2D1C:  MULLW  04
2D1E:  MOVF   FF3,W
2D20:  CLRF   03
2D22:  ADDLW  7B
2D24:  MOVWF  01
2D26:  MOVLW  01
2D28:  ADDWFC 03,F
2D2A:  MOVFF  01,1C6
2D2E:  MOVFF  03,1C7
2D32:  BCF    FD8.0
2D34:  RLCF   xC4,W
2D36:  CLRF   03
2D38:  ADDLW  BB
2D3A:  MOVWF  FE9
2D3C:  MOVLW  01
2D3E:  ADDWFC 03,W
2D40:  MOVWF  FEA
2D42:  MOVFF  FEC,03
2D46:  MOVF   FED,F
2D48:  MOVFF  FEF,1C8
2D4C:  MOVFF  03,1C9
2D50:  MOVLB  0
2D52:  CALL   1E04
2D56:  MOVFF  03,1CB
2D5A:  MOVFF  02,1CA
2D5E:  MOVFF  01,1C9
2D62:  MOVFF  00,1C8
2D66:  MOVFF  FEA,1CD
2D6A:  MOVFF  FE9,1CC
2D6E:  BSF    FD8.1
2D70:  MOVFF  03,1D1
2D74:  MOVFF  02,1D0
2D78:  MOVFF  01,1CF
2D7C:  MOVFF  00,1CE
2D80:  MOVLB  1
2D82:  CLRF   xD5
2D84:  CLRF   xD4
2D86:  CLRF   xD3
2D88:  MOVLW  8E
2D8A:  MOVWF  xD2
2D8C:  MOVLB  0
2D8E:  CALL   2090
2D92:  MOVFF  1CD,FEA
2D96:  MOVFF  1CC,FE9
2D9A:  MOVLW  6F
2D9C:  MOVLB  1
2D9E:  MOVWF  xD6
2DA0:  MOVLW  12
2DA2:  MOVWF  xD5
2DA4:  MOVLW  03
2DA6:  MOVWF  xD4
2DA8:  MOVLW  72
2DAA:  MOVWF  xD3
2DAC:  MOVFF  03,1DA
2DB0:  MOVFF  02,1D9
2DB4:  MOVFF  01,1D8
2DB8:  MOVFF  00,1D7
2DBC:  MOVLB  0
2DBE:  CALL   1E3A
2DC2:  MOVFF  1C7,FEA
2DC6:  MOVFF  1C6,FE9
2DCA:  MOVFF  00,FEF
2DCE:  MOVFF  01,FEC
2DD2:  MOVFF  02,FEC
2DD6:  MOVFF  03,FEC
2DDA:  MOVLB  1
2DDC:  INCF   xC4,F
2DDE:  BRA    2CAC
....................    }
....................    
....................    sprintf(szBuf,"\fIR: %1.3f %1.3f\nRed:%1.3f %1.3f", voltage[0], voltage[1], voltage[2], voltage[3]);
2DE0:  MOVLW  01
2DE2:  MOVWF  x7A
2DE4:  MOVLW  8B
2DE6:  MOVWF  x79
2DE8:  MOVLW  E0
2DEA:  MOVWF  FF6
2DEC:  MOVLW  0F
2DEE:  MOVWF  FF7
2DF0:  MOVLW  05
2DF2:  MOVWF  xC6
2DF4:  MOVLB  0
2DF6:  CALL   1A76
2DFA:  MOVLW  89
2DFC:  MOVWF  FE9
2DFE:  MOVFF  17E,1C9
2E02:  MOVFF  17D,1C8
2E06:  MOVFF  17C,1C7
2E0A:  MOVFF  17B,1C6
2E0E:  MOVLW  03
2E10:  MOVLB  1
2E12:  MOVWF  xCA
2E14:  MOVLB  0
2E16:  CALL   247E
2E1A:  MOVLW  20
2E1C:  MOVLB  1
2E1E:  MOVWF  xD3
2E20:  MOVLB  0
2E22:  CALL   1A56
2E26:  MOVLW  89
2E28:  MOVWF  FE9
2E2A:  MOVFF  182,1C9
2E2E:  MOVFF  181,1C8
2E32:  MOVFF  180,1C7
2E36:  MOVFF  17F,1C6
2E3A:  MOVLW  03
2E3C:  MOVLB  1
2E3E:  MOVWF  xCA
2E40:  MOVLB  0
2E42:  CALL   247E
2E46:  MOVLW  F0
2E48:  MOVWF  FF6
2E4A:  MOVLW  0F
2E4C:  MOVWF  FF7
2E4E:  MOVLW  05
2E50:  MOVLB  1
2E52:  MOVWF  xC6
2E54:  MOVLB  0
2E56:  CALL   1A76
2E5A:  MOVLW  89
2E5C:  MOVWF  FE9
2E5E:  MOVFF  186,1C9
2E62:  MOVFF  185,1C8
2E66:  MOVFF  184,1C7
2E6A:  MOVFF  183,1C6
2E6E:  MOVLW  03
2E70:  MOVLB  1
2E72:  MOVWF  xCA
2E74:  MOVLB  0
2E76:  CALL   247E
2E7A:  MOVLW  20
2E7C:  MOVLB  1
2E7E:  MOVWF  xD3
2E80:  MOVLB  0
2E82:  CALL   1A56
2E86:  MOVLW  89
2E88:  MOVWF  FE9
2E8A:  MOVFF  18A,1C9
2E8E:  MOVFF  189,1C8
2E92:  MOVFF  188,1C7
2E96:  MOVFF  187,1C6
2E9A:  MOVLW  03
2E9C:  MOVLB  1
2E9E:  MOVWF  xCA
2EA0:  MOVLB  0
2EA2:  CALL   247E
....................    for(int8 i = 0; i < strlen(szBuf); i++) lcd_putc(szBuf[i]);
2EA6:  MOVLB  1
2EA8:  CLRF   xC5
2EAA:  MOVLW  01
2EAC:  MOVWF  xC7
2EAE:  MOVLW  8B
2EB0:  MOVWF  xC6
2EB2:  MOVLB  0
2EB4:  CALL   1B48
2EB8:  MOVFF  02,03
2EBC:  MOVF   01,W
2EBE:  MOVF   03,F
2EC0:  BNZ   2ECC
2EC2:  MOVF   01,W
2EC4:  MOVLB  1
2EC6:  SUBWF  xC5,W
2EC8:  BC    2EEC
2ECA:  MOVLB  0
2ECC:  CLRF   03
2ECE:  MOVLB  1
2ED0:  MOVF   xC5,W
2ED2:  ADDLW  8B
2ED4:  MOVWF  FE9
2ED6:  MOVLW  01
2ED8:  ADDWFC 03,W
2EDA:  MOVWF  FEA
2EDC:  MOVFF  FEF,1C7
2EE0:  MOVLB  0
2EE2:  CALL   12BE
2EE6:  MOVLB  1
2EE8:  INCF   xC5,F
2EEA:  BRA    2EAA
....................    delay_ms(1000);
2EEC:  MOVLW  04
2EEE:  MOVWF  xC6
2EF0:  MOVLW  FA
2EF2:  MOVWF  xC8
2EF4:  MOVLB  0
2EF6:  CALL   116C
2EFA:  MOVLB  1
2EFC:  DECFSZ xC6,F
2EFE:  BRA    2EF0
2F00:  MOVLB  0
2F02:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////
.................... // Load the data in the cmd array and return it.
.................... // Incoming cmd[1] the sequence number. 
.................... // The function returns:
.................... // if SequenceCode = 1 :SEND_DC_PART
.................... //    cmd[0] = HIBYTE(DC660) cmd[1] = LOBYTE(DC660)
.................... //    cmd[2] = HIBYTE(DC940) cmd[3] = LOBYTE(DC940)
.................... //    cmd[4] = whole number part of Sp02 
.................... //    cmd[5] = decimal part of SpO2
.................... // 
.................... // if SequenceCode = 2 : SEND_AC660_1 first 32 values (HIBYTE then LOBYTE) of the AC660 array
.................... // if SequenceCode = 3 : SEND_AC660_2 next 32 values of AC660
.................... // if SequenceCode = 4 : SEND_AC940_1 first 32 values (HIBYTE then LOBYTE) of the AC940 array
.................... // if SequenceCode = 5 : SEND_AC940_2 next 32 values of AC940
.................... ////////////////////////////////////////////////////////
.................... void LoadData(void)
.................... {
....................   SequenceCode = cmd[1];
*
32CC:  MOVFF  135,174
....................   int8 index = 0; 
32D0:  MOVLB  1
32D2:  CLRF   x7B
....................   // to break the 16 bit int into two 8 bit int's use make8(var, offset)
....................   // Make8 extracts the byte at offset from var. 
....................   // Same as: i8 = (((var >> (offset*8)) & 0xff) except it is done with a single byte move
....................   
....................   switch (SequenceCode) {
32D4:  MOVF   x74,W
32D6:  XORLW  01
32D8:  MOVLB  0
32DA:  BZ    32F4
32DC:  XORLW  03
32DE:  BZ    33B4
32E0:  XORLW  01
32E2:  BTFSC  FD8.2
32E4:  BRA    3438
32E6:  XORLW  07
32E8:  BTFSC  FD8.2
32EA:  BRA    34BE
32EC:  XORLW  01
32EE:  BTFSC  FD8.2
32F0:  BRA    3542
32F2:  BRA    35C8
....................     case SEND_DC_PART:
....................          cmd[0] = make8(DC660, 1);
32F4:  MOVLB  1
32F6:  MOVFF  131,134
....................          cmd[1] = make8(DC660, 0);
32FA:  MOVFF  130,135
....................          cmd[2] = make8(DC940, 1);
32FE:  MOVFF  133,136
....................          cmd[3] = make8(DC940, 0);
3302:  MOVFF  132,137
....................          // send the PIC measured spo2 value
....................          cmd[4] = (int8) floor(spo2);  
3306:  MOVFF  178,183
330A:  MOVFF  177,182
330E:  MOVFF  176,181
3312:  MOVFF  175,180
3316:  MOVLB  0
3318:  RCALL  32B2
331A:  MOVFF  03,197
331E:  MOVFF  02,196
3322:  MOVFF  01,195
3326:  MOVFF  00,194
332A:  RCALL  2F04
332C:  MOVFF  01,138
....................          cmd[5] = (int8) (1000.0 * (spo2 - floor(spo2)));
3330:  MOVFF  178,183
3334:  MOVFF  177,182
3338:  MOVFF  176,181
333C:  MOVFF  175,180
3340:  RCALL  32B2
3342:  MOVFF  FEA,181
3346:  MOVFF  FE9,180
334A:  BSF    FD8.1
334C:  MOVFF  178,1D1
3350:  MOVFF  177,1D0
3354:  MOVFF  176,1CF
3358:  MOVFF  175,1CE
335C:  MOVFF  03,1D5
3360:  MOVFF  02,1D4
3364:  MOVFF  01,1D3
3368:  MOVFF  00,1D2
336C:  CALL   2090
3370:  MOVFF  181,FEA
3374:  MOVFF  180,FE9
3378:  MOVLB  1
337A:  CLRF   xD6
337C:  CLRF   xD5
337E:  MOVLW  7A
3380:  MOVWF  xD4
3382:  MOVLW  88
3384:  MOVWF  xD3
3386:  MOVFF  03,1DA
338A:  MOVFF  02,1D9
338E:  MOVFF  01,1D8
3392:  MOVFF  00,1D7
3396:  MOVLB  0
3398:  CALL   1E3A
339C:  MOVFF  03,197
33A0:  MOVFF  02,196
33A4:  MOVFF  01,195
33A8:  MOVFF  00,194
33AC:  RCALL  2F04
33AE:  MOVFF  01,139
....................          break;
33B2:  BRA    35D4
....................   
....................     case SEND_AC660_1:
....................          index = 0;
33B4:  MOVLB  1
33B6:  CLRF   x7B
....................          for(int8 i = 0; i < 32; i++) {  
33B8:  CLRF   x7C
33BA:  MOVF   x7C,W
33BC:  SUBLW  1F
33BE:  BNC   3434
....................              cmd[index++] = MAKE8(AC660[i], 1);     
33C0:  MOVF   x7B,W
33C2:  INCF   x7B,F
33C4:  CLRF   03
33C6:  ADDLW  34
33C8:  MOVWF  01
33CA:  MOVLW  01
33CC:  ADDWFC 03,F
33CE:  MOVFF  03,181
33D2:  BCF    FD8.0
33D4:  RLCF   x7C,W
33D6:  CLRF   03
33D8:  ADDLW  30
33DA:  MOVWF  FE9
33DC:  MOVLW  00
33DE:  ADDWFC 03,W
33E0:  MOVWF  FEA
33E2:  MOVFF  FEC,183
33E6:  MOVF   FED,F
33E8:  MOVFF  FEF,182
33EC:  MOVFF  181,FEA
33F0:  MOVFF  01,FE9
33F4:  MOVFF  183,FEF
....................              cmd[index++] = MAKE8(AC660[i], 0); 
33F8:  MOVF   x7B,W
33FA:  INCF   x7B,F
33FC:  CLRF   03
33FE:  ADDLW  34
3400:  MOVWF  01
3402:  MOVLW  01
3404:  ADDWFC 03,F
3406:  MOVFF  03,181
340A:  BCF    FD8.0
340C:  RLCF   x7C,W
340E:  CLRF   03
3410:  ADDLW  30
3412:  MOVWF  FE9
3414:  MOVLW  00
3416:  ADDWFC 03,W
3418:  MOVWF  FEA
341A:  MOVFF  FEC,183
341E:  MOVF   FED,F
3420:  MOVFF  FEF,182
3424:  MOVFF  181,FEA
3428:  MOVFF  01,FE9
342C:  MOVFF  182,FEF
3430:  INCF   x7C,F
3432:  BRA    33BA
....................          }
....................          break;
3434:  MOVLB  0
3436:  BRA    35D4
....................   
....................     case SEND_AC660_2:
....................          index = 0;
3438:  MOVLB  1
343A:  CLRF   x7B
....................          for(int8 i = 32; i < 64; i++) {  
343C:  MOVLW  20
343E:  MOVWF  x7D
3440:  MOVF   x7D,W
3442:  SUBLW  3F
3444:  BNC   34BA
....................              cmd[index++] = MAKE8(AC660[i], 1);     
3446:  MOVF   x7B,W
3448:  INCF   x7B,F
344A:  CLRF   03
344C:  ADDLW  34
344E:  MOVWF  01
3450:  MOVLW  01
3452:  ADDWFC 03,F
3454:  MOVFF  03,181
3458:  BCF    FD8.0
345A:  RLCF   x7D,W
345C:  CLRF   03
345E:  ADDLW  30
3460:  MOVWF  FE9
3462:  MOVLW  00
3464:  ADDWFC 03,W
3466:  MOVWF  FEA
3468:  MOVFF  FEC,183
346C:  MOVF   FED,F
346E:  MOVFF  FEF,182
3472:  MOVFF  181,FEA
3476:  MOVFF  01,FE9
347A:  MOVFF  183,FEF
....................              cmd[index++] = MAKE8(AC660[i], 0); 
347E:  MOVF   x7B,W
3480:  INCF   x7B,F
3482:  CLRF   03
3484:  ADDLW  34
3486:  MOVWF  01
3488:  MOVLW  01
348A:  ADDWFC 03,F
348C:  MOVFF  03,181
3490:  BCF    FD8.0
3492:  RLCF   x7D,W
3494:  CLRF   03
3496:  ADDLW  30
3498:  MOVWF  FE9
349A:  MOVLW  00
349C:  ADDWFC 03,W
349E:  MOVWF  FEA
34A0:  MOVFF  FEC,183
34A4:  MOVF   FED,F
34A6:  MOVFF  FEF,182
34AA:  MOVFF  181,FEA
34AE:  MOVFF  01,FE9
34B2:  MOVFF  182,FEF
34B6:  INCF   x7D,F
34B8:  BRA    3440
....................          }
....................          break;
34BA:  MOVLB  0
34BC:  BRA    35D4
....................   
....................     case SEND_AC940_1:
....................          index = 0;
34BE:  MOVLB  1
34C0:  CLRF   x7B
....................          for(int8 i = 0; i < 32; i++) {  
34C2:  CLRF   x7E
34C4:  MOVF   x7E,W
34C6:  SUBLW  1F
34C8:  BNC   353E
....................              cmd[index++] = MAKE8(AC940[i], 1);     
34CA:  MOVF   x7B,W
34CC:  INCF   x7B,F
34CE:  CLRF   03
34D0:  ADDLW  34
34D2:  MOVWF  01
34D4:  MOVLW  01
34D6:  ADDWFC 03,F
34D8:  MOVFF  03,181
34DC:  BCF    FD8.0
34DE:  RLCF   x7E,W
34E0:  CLRF   03
34E2:  ADDLW  B0
34E4:  MOVWF  FE9
34E6:  MOVLW  00
34E8:  ADDWFC 03,W
34EA:  MOVWF  FEA
34EC:  MOVFF  FEC,183
34F0:  MOVF   FED,F
34F2:  MOVFF  FEF,182
34F6:  MOVFF  181,FEA
34FA:  MOVFF  01,FE9
34FE:  MOVFF  183,FEF
....................              cmd[index++] = MAKE8(AC940[i], 0); 
3502:  MOVF   x7B,W
3504:  INCF   x7B,F
3506:  CLRF   03
3508:  ADDLW  34
350A:  MOVWF  01
350C:  MOVLW  01
350E:  ADDWFC 03,F
3510:  MOVFF  03,181
3514:  BCF    FD8.0
3516:  RLCF   x7E,W
3518:  CLRF   03
351A:  ADDLW  B0
351C:  MOVWF  FE9
351E:  MOVLW  00
3520:  ADDWFC 03,W
3522:  MOVWF  FEA
3524:  MOVFF  FEC,183
3528:  MOVF   FED,F
352A:  MOVFF  FEF,182
352E:  MOVFF  181,FEA
3532:  MOVFF  01,FE9
3536:  MOVFF  182,FEF
353A:  INCF   x7E,F
353C:  BRA    34C4
....................          }
....................          break;
353E:  MOVLB  0
3540:  BRA    35D4
....................    
....................   
....................     case SEND_AC940_2:
....................          index = 0;
3542:  MOVLB  1
3544:  CLRF   x7B
....................          for(int8 i = 32; i < 64; i++) {  
3546:  MOVLW  20
3548:  MOVWF  x7F
354A:  MOVF   x7F,W
354C:  SUBLW  3F
354E:  BNC   35C4
....................              cmd[index++] = MAKE8(AC940[i], 1);     
3550:  MOVF   x7B,W
3552:  INCF   x7B,F
3554:  CLRF   03
3556:  ADDLW  34
3558:  MOVWF  01
355A:  MOVLW  01
355C:  ADDWFC 03,F
355E:  MOVFF  03,181
3562:  BCF    FD8.0
3564:  RLCF   x7F,W
3566:  CLRF   03
3568:  ADDLW  B0
356A:  MOVWF  FE9
356C:  MOVLW  00
356E:  ADDWFC 03,W
3570:  MOVWF  FEA
3572:  MOVFF  FEC,183
3576:  MOVF   FED,F
3578:  MOVFF  FEF,182
357C:  MOVFF  181,FEA
3580:  MOVFF  01,FE9
3584:  MOVFF  183,FEF
....................              cmd[index++] = MAKE8(AC940[i], 0); 
3588:  MOVF   x7B,W
358A:  INCF   x7B,F
358C:  CLRF   03
358E:  ADDLW  34
3590:  MOVWF  01
3592:  MOVLW  01
3594:  ADDWFC 03,F
3596:  MOVFF  03,181
359A:  BCF    FD8.0
359C:  RLCF   x7F,W
359E:  CLRF   03
35A0:  ADDLW  B0
35A2:  MOVWF  FE9
35A4:  MOVLW  00
35A6:  ADDWFC 03,W
35A8:  MOVWF  FEA
35AA:  MOVFF  FEC,183
35AE:  MOVF   FED,F
35B0:  MOVFF  FEF,182
35B4:  MOVFF  181,FEA
35B8:  MOVFF  01,FE9
35BC:  MOVFF  182,FEF
35C0:  INCF   x7F,F
35C2:  BRA    354A
....................          }
....................          break;
35C4:  MOVLB  0
35C6:  BRA    35D4
....................      
....................     default:
....................         lcd_putc("\fBad Data load\ncode sent."); 
35C8:  MOVLW  02
35CA:  MOVWF  FF6
35CC:  MOVLW  10
35CE:  MOVWF  FF7
35D0:  CALL   1318
....................         break;
....................   }
35D4:  GOTO   3724 (RETURN)
....................   
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////
.................... // Displays the data segment number after sending it to the PC
.................... //////////////////////////////////////////////////////////////
.................... void DataLoadStatus(void)
.................... {
....................   
....................    switch (SequenceCode) {
35D8:  MOVLB  1
35DA:  MOVF   x74,W
35DC:  XORLW  01
35DE:  MOVLB  0
35E0:  BZ    35F4
35E2:  XORLW  03
35E4:  BZ    3602
35E6:  XORLW  01
35E8:  BZ    3610
35EA:  XORLW  07
35EC:  BZ    361E
35EE:  XORLW  01
35F0:  BZ    362C
35F2:  BRA    363A
....................       case SEND_DC_PART:
....................           lcd_putc("\fDC data sent\nto PC");
35F4:  MOVLW  1C
35F6:  MOVWF  FF6
35F8:  MOVLW  10
35FA:  MOVWF  FF7
35FC:  CALL   1318
....................           break;
3600:  BRA    3646
....................   
....................       case SEND_AC660_1:
....................           lcd_putc("\f1st half of AC660\ndata sent to PC");
3602:  MOVLW  30
3604:  MOVWF  FF6
3606:  MOVLW  10
3608:  MOVWF  FF7
360A:  CALL   1318
....................           break;
360E:  BRA    3646
....................   
....................       case SEND_AC660_2:
....................           lcd_putc("\f2nd half of AC660\ndata sent to PC");
3610:  MOVLW  54
3612:  MOVWF  FF6
3614:  MOVLW  10
3616:  MOVWF  FF7
3618:  CALL   1318
....................           break;
361C:  BRA    3646
....................   
....................      case SEND_AC940_1:
....................          lcd_putc("\f1st half of AC940\ndata sent to PC");
361E:  MOVLW  78
3620:  MOVWF  FF6
3622:  MOVLW  10
3624:  MOVWF  FF7
3626:  CALL   1318
....................          break;
362A:  BRA    3646
....................   
....................      case SEND_AC940_2:
....................          lcd_putc("\f2nd half of AC940\ndata sent to PC");
362C:  MOVLW  9C
362E:  MOVWF  FF6
3630:  MOVLW  10
3632:  MOVWF  FF7
3634:  CALL   1318
....................          break;
3638:  BRA    3646
....................         
....................      default:
....................          lcd_putc("/fBad Data load/ncode sent."); 
363A:  MOVLW  C0
363C:  MOVWF  FF6
363E:  MOVLW  10
3640:  MOVWF  FF7
3642:  CALL   1318
....................          break;
....................    }
3646:  GOTO   3742 (RETURN)
.................... }
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////
.................... // Blink the LED for 500 ms 
.................... /////////////////////////////////////////////////////////////
.................... void BlinkLED(void)
.................... {
....................    output_high(LED);
*
13B2:  BCF    F92.0
13B4:  BSF    F89.0
....................    delay_ms(500);
13B6:  MOVLW  02
13B8:  MOVLB  1
13BA:  MOVWF  x7B
13BC:  MOVLW  FA
13BE:  MOVWF  xC8
13C0:  MOVLB  0
13C2:  RCALL  116C
13C4:  MOVLB  1
13C6:  DECFSZ x7B,F
13C8:  BRA    13BC
....................    output_low(LED);
13CA:  BCF    F92.0
13CC:  BCF    F89.0
13CE:  MOVLB  0
13D0:  RETURN 0
.................... }
.................... 
.................... 
.................... 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
